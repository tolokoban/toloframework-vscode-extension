{"version":3,"sources":["../webpack/bootstrap","../external \"stream\"",".././src/util.ts","../external \"zlib\"","../external \"vscode\"",".././node_modules/yaml/dist/PlainValue-ec8e588e.js","../external \"fs\"","../external \"path\"",".././node_modules/yaml/dist/resolveSeq-4a68b39b.js","../external \"url\"",".././src/inputs/index.ts","../external \"http\"",".././node_modules/yaml/dist/Schema-42e9705c.js",".././node_modules/yaml/dist/warnings-39684f17.js","../external \"https\"",".././src/extension.ts",".././src/view/index.ts",".././src/view/view.ts",".././src/inputs/inputs.ts",".././src/view/tpl/view.ts",".././src/view/tpl/style.ts",".././src/view/tpl/tester.ts",".././src/view/tpl/container.ts",".././src/fonts/index.ts",".././src/fonts/fonts.ts",".././node_modules/node-fetch/lib/index.mjs",".././src/fonts/slicer.ts",".././src/module/index.ts",".././src/module/module.ts",".././src/translation.ts",".././node_modules/yaml/index.js",".././node_modules/yaml/dist/index.js",".././node_modules/yaml/dist/parse-cst.js",".././node_modules/yaml/dist/Document-2cf6b08c.js",".././node_modules/yaml/util.js",".././node_modules/yaml/dist/util.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","IViewColumn","exists","path","FS","existsSync","openTextDocument","filename","Promise","resolve","reject","X","workspace","then","removeExtension","idxDot","lastIndexOf","substr","findFilenameInAncestors","startingPath","oldPath","currentFilename","Path","getSourceFolder","editor","window","activeTextEditor","document","fileName","dirname","packagePath","sourcePath","getSourceFolderFromActiveTextEditor","changeExtension","newExtension","getBasename","idxSlash","substring","getDirectory","isKebabCase","input","RX_KEBAB_CASE","lastIndex","test","kebabCaseToLowerPascalCase","pascal","kebabCaseToPascalCase","charAt","toLowerCase","makeRelativeToSource","relative","openFileInEditor","viewColumn","ViewColumn","Active","doc","showTextDocument","valueOf","writeTextFile","content","writeFileSync","split","map","x","toUpperCase","join","Char","ANCHOR","COMMENT","TAG","DIRECTIVES_END","DOCUMENT_END","Type","ALIAS","BLANK_LINE","BLOCK_FOLDED","BLOCK_LITERAL","DIRECTIVE","DOCUMENT","FLOW_MAP","FLOW_SEQ","MAP","MAP_KEY","MAP_VALUE","PLAIN","QUOTE_DOUBLE","QUOTE_SINGLE","SEQ","SEQ_ITEM","findLineStarts","src","ls","offset","indexOf","push","getSrcInfo","cst","lineStarts","Array","isArray","context","getLinePos","length","start","line","col","getPrettyContext","end","maxWidth","slice","getLine","halfWidth","Math","round","errLen","errEnd","min","repeat","Range","orig","this","cr","origStart","origEnd","nextOffset","Node","str","next","endOfWhiteSpace","sep","ch0","prev","ch1","ch2","ch3","ch","isVerbatim","notOk","indent","lineStart","inEnd","endOfIndent","wsEnd","endAsBlank","indentDiff","indicatorAsIndent","inCount","error","fold","type","props","writable","range","valueRange","idx","skipKey","prop","anchor","getPropValue","comments","comment","header","atBlank","root","tag","verbatim","_","handle","suffix","match","endOfLine","commentRange","setOrigRange","forEach","addStringTerminator","YAMLError","Error","source","message","super","nodeType","linePos","rangeAsLinePos","ctx","YAMLSemanticError","PlainValue","inFlow","foldNewline","wsStart","errors","valueEnd","atDocumentBoundary","endOfBlockIndent","isEmpty","parseComment","hasComment","parseBlockValue","YAMLReferenceError","YAMLSyntaxError","YAMLWarning","_defineProperty","obj","configurable","defaultTagPrefix","defaultTags","STR","addComment","replace","toJSON","arg","v","String","anchors","onCreate","res","keep","Number","Scalar","collectionFromPath","schema","k","isInteger","createNode","isEmptyPath","iterator","done","Collection","add","rest","node","addIn","undefined","set","delete","deleteIn","keepScalar","getIn","items","every","commentBefore","has","hasIn","setIn","blockItem","flowChars","isMap","itemIndent","onComment","onChompKeep","indentStep","stringify","allNullValues","hasAllNullValues","assign","chompKeep","hasItemWithNewLine","nodes","reduce","item","spaceBefore","includes","strings","sum","maxFlowStringSingleLineLength","shift","asItemIndex","YAMLSeq","splice","it","seq","toString","JSON","Pair","PAIR","cb","Map","Set","stringKey","jsKey","inStringifyKey","stringifyKey","pair","mapAsMap","addToJSMap","indentSize","indentSeq","simpleKeys","options","keyComment","explicitKey","implicitKey","vcb","valueComment","indentAtStart","getName","valueStr","ws","MERGE_PAIR","getAliasCount","Alias","count","aliasCount","kc","vc","max","keys","find","a","newName","msg","maxAliasCount","cstNode","ReferenceError","findPair","YAMLMap","overwrite","sortEntries","sortMapEntries","findIndex","Merge","srcMap","binaryOptions","defaultType","lineWidth","strOptions","doubleQuoted","jsonEncoding","minMultiLineLength","minContentWidth","resolveScalar","tags","scalarFallback","format","apply","consumeMoreIndentedLines","text","foldFlowLines","onFold","onOverflow","endStep","folds","escapedFolds","overflow","getFoldOptions","containsDocumentMarker","doubleQuotedString","json","code","singleQuotedString","blockString","forceBlockIndent","literal","limit","strLen","lineLengthOverLimit","body","checkFlowCollectionEnd","char","lastItem","err","checkFlowCommentSpace","getLongKeyError","sk","resolveComments","collection","afterKey","before","resolveString","strValue","resolveTagName","nonSpecific","prefix","tagPrefixes","dtp","getDefaults","version","warnings","vocab","decodeURIComponent","resolveTagHandle","resolveByTagName","tagName","matchWithTest","resolveTag","fallback","getFallbackTagName","refError","stack","resolveNodeProps","after","hasAnchor","hasTag","isCollectionItem","parent","concat","commentHasRequiredWhitespace","resolveNode","getNode","rawValue","_cstAliases","resolveNodeValue","keepCstNodes","keepNodeTypes","ca","resolved","resolvePairComment","valueHasPairComment","found","startsWith","cc","boolOptions","trueStr","falseStr","intOptions","asBigInt","nullOptions","nullStr","resolveMap","resolveFlowMapItems","keyStart","atLineStart","valueNode","pos","origPos","j","nextItem","valueRangeContainsNewline","resolveBlockMapItems","hasCollectionKey","iKey","merge","sources","some","jKey","warn","resolveSeq","prevItem","pop","keyEnd","resolveFlowSeqItems","hasProps","resolveBlockSeqItems","stringifyNumber","minFractionDigits","isFinite","isNaN","stringifyString","_stringify","_type","actualString","addCommentBefore","plainString","default","createPair","sort","nodeClass","wrapScalars","string","identify","failsafe","intIdentify","intResolve","part","radix","BigInt","parseInt","intStringify","nullObj","boolObj","octObj","oct","intObj","hexObj","hex","nanObj","nan","NaN","NEGATIVE_INFINITY","POSITIVE_INFINITY","expObj","parseFloat","toExponential","floatObj","frac1","frac2","frac","core","intIdentify$1","stringifyJSON","SyntaxError","boolStringify","intIdentify$2","intResolve$1","sign","intStringify$1","yaml11","bin","abs","f","binary","omap","pairs","intTime","floatTime","timestamp","schemas","bool","float","floatExp","floatNaN","int","intHex","intOct","null","defaultPrefix","onTagObj","prevObjects","tagObj","filter","class","findTagObject","alias","aliasNodes","sortMapEntriesByKey","b","Schema","customTags","deprecatedCustomTags","warnOptionDeprecation","knownTags","schemaId","getSchemaTags","baseCtx","Uint8Array","Buffer","from","atob","buffer","charCodeAt","btoa","fromCharCode","ceil","lines","parsePairs","createPairs","iterable","TypeError","YAMLOMap","seenKeys","YAMLSet","keepPair","parseSexagesimal","parts","stringifySexagesimal","unshift","Date","RegExp","year","month","day","hour","minute","second","millisec","tz","date","UTC","toISOString","shouldWarn","deprecation","env","process","YAML_SILENCE_DEPRECATION_WARNINGS","YAML_SILENCE_WARNINGS","warning","emit","emitWarning","console","warned","warnFileDeprecation","alternative","actions","action","extension","id","disposable","VSC","commands","registerCommand","switchTo","subscriptions","compileYAML","load","exec","createWebviewPanel","Beside","enableScripts","enableCommandUris","webview","html","EXTENSION_FALLBACKS","tsx","ts","js","yaml","activeEditor","showErrorMessage","extensions","fallbacks","ext","openFileIfExists","originFileName","getInitialContent","writeFile","folder","ex","selectFolder","relativeFolder","folderName","basename","viewName","promptForName","destinationFolder","modal","fs","createDirectory","Uri","file","moduleSuffix","showInputBox","prompt","validateInput","trim","save","fileToOpen","title","sourceFolder","selectedFolder","folders","recursiveSearchForFolders","currentFolder","dirs","readdirSync","withFileTypes","dir","isDirectory","label","picker","createQuickPick","onDidAccept","dispose","onDidChangeActive","activeItems","show","viewname","getExtension","dotIndex","fontURL","disposableMessage","setStatusBarMessage","asyncContentLoading","url","styleResponse","loadContentFromURL","fontName","cssContent","asyncLoadAll","slices","urls","response","ok","status","statusText","arrayBuffer","data","css","pieces","piece","index","fonts","loadAllFonts","destination","showInformationMessage","files","fontFile","cssFilename","fontClassFilename","modFilename","Readable","BUFFER","TYPE","Blob","blobParts","arguments","buffers","size","element","ArrayBuffer","isView","byteOffset","byteLength","buf","ab","readable","_read","relativeStart","relativeEnd","span","slicedBuffer","blob","FetchError","systemError","errno","captureStackTrace","constructor","convert","defineProperties","e","INTERNALS","PassThrough","Body","_this","_ref","_ref$size","_ref$timeout","timeout","isURLSearchParams","isBlob","isBuffer","disturbed","on","consumeBody","_this4","alloc","stream","accum","accumBytes","abort","resTimeout","setTimeout","chunk","clearTimeout","append","getAll","clone","instance","p1","p2","bodyUsed","getBoundary","pipe","extractContentType","getTotalBytes","getLengthSync","_lengthRetrievers","hasKnownLength","ct","headers","_this2","parse","_this3","charset","convertBody","mixIn","proto","getOwnPropertyNames","desc","getOwnPropertyDescriptor","global","invalidTokenRegex","invalidHeaderCharRegex","validateName","validateValue","Headers","init","rawHeaders","raw","headerNames","headerName","method","callback","thisArg","getHeaders","_pairs$i","createHeadersIterator","kind","entries","values","INTERNAL","target","HeadersIteratorPrototype","setPrototypeOf","getPrototypeOf","_INTERNAL","exportNodeCompatibleHeaders","__proto__","hostHeaderKey","INTERNALS$1","STATUS_CODES","Response","opts","contentType","counter","redirected","INTERNALS$2","parse_url","format_url","streamDestructionSupported","isRequest","Request","parsedURL","href","inputBody","signal","isAbortSignal","redirect","follow","compress","agent","AbortError","PassThrough$1","resolve_url","fetch","request","protocol","hostname","contentLengthValue","totalBytes","getNodeRequestOptions","send","destroy","aborted","abortAndFinalize","finalize","req","reqTimeout","removeEventListener","addEventListener","once","socket","val","createHeadersLenient","isRedirect","statusCode","location","locationURL","requestOpts","response_options","statusMessage","codings","zlibOptions","flush","Z_SYNC_FLUSH","finishFlush","createGunzip","createBrotliDecompress","createInflate","createInflateRaw","dest","write","writeToStream","removeComments","cursor","indexOpen","indexClose","moduleName","getTestContent","endsWith","getText","YAML","prettyErrors","errorMessage","parseCst","Document$1","Document","defaultOptions","parseDocument","errMsg","defaults","parseAllDocuments","cstDoc","parseCST","scalarOptions","contents","BlankLine","CollectionItem","includesTrailingLines","parseNode","inlineComment","blankLine","nextNodeIsIndented","inCollection","setOrigRanges","Comment","grabCollectionEndComments","cnode","len","ci","prevEnd","nextContentHasIndent","firstItem","itemRange","ec","startOfLine","copy","normalizeOffset","prevIncludesTrailingLines","Directive","parseName","parseParameters","directives","directivesEndMarker","documentEndMarker","hasDirectives","startCommentOrEndBlankLine","directive","iEnd","parseDirectives","parseContents","endOfIdentifier","Chomp","BlockValue","blockIndent","chomping","lastNewLine","keepStart","bi","folded","atStart","prevMoreIndented","lineEnd","explicit","minBlockIndent","lineIndent","parseBlockHeader","FlowCollection","jsonLike","prevNodeIsJsonLike","origOffset","QuoteDouble","parseCharCode","fromCodePoint","endOfQuote","QuoteSingle","ParseContext","overlay","valueStart","parseProps","createNewNode","parseEnd","nodeStartsCollection","lineHasProps","noIndicatorAsIndent","parseType","documents","crOffset","opt","documentOptions","stringifyTag","priv","createCtx","getTagObject","stringifyProps","Anchors","setAnchor","createAlias","names","validAnchorNode","visit","resolveTagDirective","parameters","resolveYamlDirective","assertCollection","anchorPrefix","toFixed","prevDoc","directiveComments","copyTagPrefix","setSchema","cbNode","resolveNodes","makePretty","onAnchor","keepBlobsInJSON","anchorNames","vd","tagNames","listNonDefaultTags","contentComment","util","parseMap","parseSeq"],"mappings":"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","file":"extension.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 14);\n","module.exports = require(\"stream\");","// tslint:disable-next-line: no-implicit-dependencies\nimport * as X from 'vscode'\nimport FS = require(\"fs\")\nimport Path = require(\"path\")\n\nexport default {\n    changeExtension,\n    exists,\n    findFilenameInAncestors,\n    getBasename,\n    getDirectory,\n    getSourceFolder,\n    isKebabCase,\n    kebabCaseToLowerPascalCase,\n    kebabCaseToPascalCase,\n    makeRelativeToSource,\n    openFileInEditor,\n    openTextDocument,\n    removeExtension,\n    writeTextFile\n}\n\nenum IViewColumn {\n    ACTIVE = -1,\n    BESIDE = -2,\n    ONE = 1,\n    TWO = 2\n}\n\nfunction changeExtension(filename: string, newExtension: string): string {\n    return `${removeExtension(filename)}.${newExtension}`\n}\n\nfunction exists(path: string): boolean {\n    return FS.existsSync(path)\n}\n\nasync function openTextDocument(filename: string):\n    Promise<X.TextDocument | null> {\n    return new Promise((resolve, reject) => {\n        if (!exists(filename)) {\n            resolve(null)\n            return\n        }\n        X.workspace.openTextDocument(filename).then(\n            resolve,\n            reject\n        )\n    })\n}\n\nasync function openFileInEditor(\n    filename: string,\n    viewColumn: X.ViewColumn = X.ViewColumn.Active\n): Promise<boolean> {\n    const doc = await openTextDocument(filename)\n    if (!doc) return false\n    X.window.showTextDocument(\n        doc,\n        viewColumn.valueOf()\n    )\n    return true\n}\n\nfunction removeExtension(filename: string): string {\n    const idxDot = filename.lastIndexOf(\".\")\n    return filename.substr(0, idxDot)\n}\n\nfunction getBasename(filename: string): string {\n    const idxSlash = filename.lastIndexOf(\"/\")\n    return filename.substring(idxSlash)\n}\n\nfunction getDirectory(filename: string): string {\n    const idxSlash = filename.lastIndexOf(\"/\")\n    return filename.substr(0, idxSlash)\n}\n\nfunction writeTextFile(filename: string, content: string) {\n    FS.writeFileSync(filename, content)\n}\n\n/**\n * Find a `filename` in the `startingPath`.\n * If not found, try in the parent directory.\n * When found, return its path.\n * If not found, return `null`.\n *\n * @param filename - Name of the file to search without any path.\n * @param startingPath - Path from where to start the search.\n */\nfunction findFilenameInAncestors(\n    filename: string,\n    startingPath: string\n): string | null {\n    let path = startingPath\n    let oldPath = \"\"\n\n    while (oldPath !== path) {\n        oldPath = path\n        const currentFilename = Path.resolve(path, filename)\n        if (FS.existsSync(currentFilename)) return currentFilename\n        // Go to parent.\n        path = Path.resolve(path, \"..\")\n    }\n\n    return null\n}\n\n/**\n * Look for the nearest \"package.json\" file in the parents\n * of the current opened file, on in the children of the current\n * workspace.\n * Then, return the \"src\" folder that lies in the same directory\n * tham \"package.json\".\n */\nfunction getSourceFolder(): string | null {\n    const editor = X.window.activeTextEditor\n    if (editor) return getSourceFolderFromActiveTextEditor(editor)\n    return null\n}\n\nfunction getSourceFolderFromActiveTextEditor(editor: X.TextEditor): string | null {\n    const path = editor.document.fileName\n    const filename = \"package.json\"\n    const startingPath = Path.dirname(path)\n    const packagePath = findFilenameInAncestors(filename, startingPath)\n    if (!packagePath) return null\n\n    const sourcePath = Path.resolve(\n        Path.dirname(packagePath),\n        \"src\"\n    )\n    if (exists(sourcePath)) return sourcePath\n    return Path.dirname(packagePath)\n}\n\n/**\n * Return a path relative to \"src/\".\n * @param path Absolute path\n */\nfunction makeRelativeToSource(path: string): string {\n    return Path.relative(getSourceFolder() ?? '/', path)\n}\n\nconst RX_KEBAB_CASE = /^[a-z][a-z0-9]+(-[a-z0-9]+)*$/g\n\nfunction isKebabCase(input: string): string {\n    RX_KEBAB_CASE.lastIndex = -1\n    return RX_KEBAB_CASE.test(input) ? \"\" : \"Kebab case name expected (ex.: \\\"wonder-woman\\\")! Minimum length is 2.\"\n}\n\nfunction kebabCaseToPascalCase(name: string): string {\n    return name.split(\"-\")\n        .map(x => `${x.charAt(0).toUpperCase()}${x.substr(1).toLowerCase()}`)\n        .join(\"\")\n}\n\nfunction kebabCaseToLowerPascalCase(name: string): string {\n    const pascal = kebabCaseToPascalCase(name)\n    return pascal.charAt(0).toLowerCase() + pascal.substr(1)\n}\n","module.exports = require(\"zlib\");","module.exports = require(\"vscode\");","'use strict';\n\nconst Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nconst Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nconst defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  const ls = [0];\n  let offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  let lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts,\n    src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (let i = 0; i < lineStarts.length; ++i) {\n    const start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  const line = lineStarts.length;\n  return {\n    line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\nfunction getLine(line, cst) {\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  const start = lineStarts[line - 1];\n  let end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') --end;\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `…` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\nfunction getPrettyContext({\n  start,\n  end\n}, cst, maxWidth = 80) {\n  let src = getLine(start.line, cst);\n  if (!src) return null;\n  let {\n    col\n  } = start;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '…';\n    } else {\n      const halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';\n      col -= src.length - maxWidth;\n      src = '…' + src.substr(1 - maxWidth);\n    }\n  }\n\n  let errLen = 1;\n  let errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '…';\n    }\n  }\n\n  const offset = col > 1 ? ' '.repeat(col - 1) : '';\n  const err = '^'.repeat(errLen);\n  return `${src}\\n${offset}${err}${errEnd}`;\n}\n\nclass Range {\n  static copy(orig) {\n    return new Range(orig.start, orig.end);\n  }\n\n  constructor(start, end) {\n    this.start = start;\n    this.end = end || start;\n  }\n\n  isEmpty() {\n    return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n  }\n  /**\n   * Set `origStart` and `origEnd` to point to the original source range for\n   * this node, which may differ due to dropped CR characters.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRange(cr, offset) {\n    const {\n      start,\n      end\n    } = this;\n\n    if (cr.length === 0 || end <= cr[0]) {\n      this.origStart = start;\n      this.origEnd = end;\n      return offset;\n    }\n\n    let i = offset;\n\n    while (i < cr.length) {\n      if (cr[i] > start) break;else ++i;\n    }\n\n    this.origStart = start + i;\n    const nextOffset = i;\n\n    while (i < cr.length) {\n      // if end was at \\n, it should now be at \\r\n      if (cr[i] >= end) break;else ++i;\n    }\n\n    this.origEnd = end + i;\n    return nextOffset;\n  }\n\n}\n\n/** Root class of all nodes */\n\nclass Node {\n  static addStringTerminator(src, offset, str) {\n    if (str[str.length - 1] === '\\n') return str;\n    const next = Node.endOfWhiteSpace(src, offset);\n    return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n  } // ^(---|...)\n\n\n  static atDocumentBoundary(src, offset, sep) {\n    const ch0 = src[offset];\n    if (!ch0) return true;\n    const prev = src[offset - 1];\n    if (prev && prev !== '\\n') return false;\n\n    if (sep) {\n      if (ch0 !== sep) return false;\n    } else {\n      if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n    }\n\n    const ch1 = src[offset + 1];\n    const ch2 = src[offset + 2];\n    if (ch1 !== ch0 || ch2 !== ch0) return false;\n    const ch3 = src[offset + 3];\n    return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n  }\n\n  static endOfIdentifier(src, offset) {\n    let ch = src[offset];\n    const isVerbatim = ch === '<';\n    const notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n    while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];\n\n    if (isVerbatim && ch === '>') offset += 1;\n    return offset;\n  }\n\n  static endOfIndent(src, offset) {\n    let ch = src[offset];\n\n    while (ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfLine(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfWhiteSpace(src, offset) {\n    let ch = src[offset];\n\n    while (ch === '\\t' || ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static startOfLine(src, offset) {\n    let ch = src[offset - 1];\n    if (ch === '\\n') return offset;\n\n    while (ch && ch !== '\\n') ch = src[offset -= 1];\n\n    return offset + 1;\n  }\n  /**\n   * End of indentation, or null if the line's indent level is not more\n   * than `indent`\n   *\n   * @param {string} src\n   * @param {number} indent\n   * @param {number} lineStart\n   * @returns {?number}\n   */\n\n\n  static endOfBlockIndent(src, indent, lineStart) {\n    const inEnd = Node.endOfIndent(src, lineStart);\n\n    if (inEnd > lineStart + indent) {\n      return inEnd;\n    } else {\n      const wsEnd = Node.endOfWhiteSpace(src, inEnd);\n      const ch = src[wsEnd];\n      if (!ch || ch === '\\n') return wsEnd;\n    }\n\n    return null;\n  }\n\n  static atBlank(src, offset, endAsBlank) {\n    const ch = src[offset];\n    return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n  }\n\n  static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n    if (!ch || indentDiff < 0) return false;\n    if (indentDiff > 0) return true;\n    return indicatorAsIndent && ch === '-';\n  } // should be at line or string end, or at next non-whitespace char\n\n\n  static normalizeOffset(src, offset) {\n    const ch = src[offset];\n    return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n  } // fold single newline into space, multiple newlines to N - 1 newlines\n  // presumes src[offset] === '\\n'\n\n\n  static foldNewline(src, offset, indent) {\n    let inCount = 0;\n    let error = false;\n    let fold = '';\n    let ch = src[offset + 1];\n\n    while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n      switch (ch) {\n        case '\\n':\n          inCount = 0;\n          offset += 1;\n          fold += '\\n';\n          break;\n\n        case '\\t':\n          if (inCount <= indent) error = true;\n          offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n          break;\n\n        case ' ':\n          inCount += 1;\n          offset += 1;\n          break;\n      }\n\n      ch = src[offset + 1];\n    }\n\n    if (!fold) fold = ' ';\n    if (ch && inCount <= indent) error = true;\n    return {\n      fold,\n      offset,\n      error\n    };\n  }\n\n  constructor(type, props, context) {\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  getPropValue(idx, key, skipKey) {\n    if (!this.context) return null;\n    const {\n      src\n    } = this.context;\n    const prop = this.props[idx];\n    return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n  }\n\n  get anchor() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const anchor = this.getPropValue(i, Char.ANCHOR, true);\n      if (anchor != null) return anchor;\n    }\n\n    return null;\n  }\n\n  get comment() {\n    const comments = [];\n\n    for (let i = 0; i < this.props.length; ++i) {\n      const comment = this.getPropValue(i, Char.COMMENT, true);\n      if (comment != null) comments.push(comment);\n    }\n\n    return comments.length > 0 ? comments.join('\\n') : null;\n  }\n\n  commentHasRequiredWhitespace(start) {\n    const {\n      src\n    } = this.context;\n    if (this.header && start === this.header.end) return false;\n    if (!this.valueRange) return false;\n    const {\n      end\n    } = this.valueRange;\n    return start !== end || Node.atBlank(src, end - 1);\n  }\n\n  get hasComment() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] === Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get hasProps() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] !== Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get includesTrailingLines() {\n    return false;\n  }\n\n  get jsonLike() {\n    const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n    return jsonLikeTypes.indexOf(this.type) !== -1;\n  }\n\n  get rangeAsLinePos() {\n    if (!this.range || !this.context) return undefined;\n    const start = getLinePos(this.range.start, this.context.root);\n    if (!start) return undefined;\n    const end = getLinePos(this.range.end, this.context.root);\n    return {\n      start,\n      end\n    };\n  }\n\n  get rawValue() {\n    if (!this.valueRange || !this.context) return null;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    return this.context.src.slice(start, end);\n  }\n\n  get tag() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const tag = this.getPropValue(i, Char.TAG, false);\n\n      if (tag != null) {\n        if (tag[1] === '<') {\n          return {\n            verbatim: tag.slice(2, -1)\n          };\n        } else {\n          // eslint-disable-next-line no-unused-vars\n          const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);\n          return {\n            handle,\n            suffix\n          };\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get valueRangeContainsNewline() {\n    if (!this.valueRange || !this.context) return false;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n\n    for (let i = start; i < end; ++i) {\n      if (src[i] === '\\n') return true;\n    }\n\n    return false;\n  }\n\n  parseComment(start) {\n    const {\n      src\n    } = this.context;\n\n    if (src[start] === Char.COMMENT) {\n      const end = Node.endOfLine(src, start + 1);\n      const commentRange = new Range(start, end);\n      this.props.push(commentRange);\n      return end;\n    }\n\n    return start;\n  }\n  /**\n   * Populates the `origStart` and `origEnd` values of all ranges for this\n   * node. Extended by child classes to handle descendant nodes.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRanges(cr, offset) {\n    if (this.range) offset = this.range.setOrigRange(cr, offset);\n    if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n    this.props.forEach(prop => prop.setOrigRange(cr, offset));\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = src.slice(range.start, range.end);\n    return Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass YAMLError extends Error {\n  constructor(name, source, message) {\n    if (!message || !(source instanceof Node)) throw new Error(`Invalid arguments for new ${name}`);\n    super();\n    this.name = name;\n    this.message = message;\n    this.source = source;\n  }\n\n  makePretty() {\n    if (!this.source) return;\n    this.nodeType = this.source.type;\n    const cst = this.source.context && this.source.context.root;\n\n    if (typeof this.offset === 'number') {\n      this.range = new Range(this.offset, this.offset + 1);\n      const start = cst && getLinePos(this.offset, cst);\n\n      if (start) {\n        const end = {\n          line: start.line,\n          col: start.col + 1\n        };\n        this.linePos = {\n          start,\n          end\n        };\n      }\n\n      delete this.offset;\n    } else {\n      this.range = this.source.range;\n      this.linePos = this.source.rangeAsLinePos;\n    }\n\n    if (this.linePos) {\n      const {\n        line,\n        col\n      } = this.linePos.start;\n      this.message += ` at line ${line}, column ${col}`;\n      const ctx = cst && getPrettyContext(this.linePos, cst);\n      if (ctx) this.message += `:\\n\\n${ctx}\\n`;\n    }\n\n    delete this.source;\n  }\n\n}\nclass YAMLReferenceError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLReferenceError', source, message);\n  }\n\n}\nclass YAMLSemanticError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSemanticError', source, message);\n  }\n\n}\nclass YAMLSyntaxError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSyntaxError', source, message);\n  }\n\n}\nclass YAMLWarning extends YAMLError {\n  constructor(source, message) {\n    super('YAMLWarning', source, message);\n  }\n\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass PlainValue extends Node {\n  static endOfLine(src, start, inFlow) {\n    let ch = src[start];\n    let offset = start;\n\n    while (ch && ch !== '\\n') {\n      if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n      const next = src[offset + 1];\n      if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n      if ((ch === ' ' || ch === '\\t') && next === '#') break;\n      offset += 1;\n      ch = next;\n    }\n\n    return offset;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n    let ch = src[end - 1];\n\n    while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) ch = src[--end - 1];\n\n    let str = '';\n\n    for (let i = start; i < end; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        const {\n          fold,\n          offset\n        } = Node.foldNewline(src, i, -1);\n        str += fold;\n        i = offset;\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (i < end && (next === ' ' || next === '\\t')) {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    const ch0 = src[start];\n\n    switch (ch0) {\n      case '\\t':\n        {\n          const msg = 'Plain value cannot start with a tab character';\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      case '@':\n      case '`':\n        {\n          const msg = `Plain value cannot start with reserved character ${ch0}`;\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      default:\n        return str;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      inFlow,\n      src\n    } = this.context;\n    let offset = start;\n    let valueEnd = start;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      if (Node.atDocumentBoundary(src, offset + 1)) break;\n      const end = Node.endOfBlockIndent(src, indent, offset + 1);\n      if (end === null || src[end] === '#') break;\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        valueEnd = PlainValue.endOfLine(src, end, inFlow);\n        offset = valueEnd;\n      }\n    }\n\n    if (this.valueRange.isEmpty()) this.valueRange.start = start;\n    this.valueRange.end = valueEnd;\n    return valueEnd;\n  }\n  /**\n   * Parses a plain value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * #comment\n   *\n   * first line\n   *\n   * first line #comment\n   *\n   * first line\n   * block\n   * lines\n   *\n   * #comment\n   * block\n   * lines\n   * ```\n   * where block lines are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar, may be `\\n`\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      inFlow,\n      src\n    } = context;\n    let offset = start;\n    const ch = src[offset];\n\n    if (ch && ch !== '#' && ch !== '\\n') {\n      offset = PlainValue.endOfLine(src, start, inFlow);\n    }\n\n    this.valueRange = new Range(start, offset);\n    offset = Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n\n    if (!this.hasComment || this.valueRange.isEmpty()) {\n      offset = this.parseBlockValue(offset);\n    }\n\n    return offset;\n  }\n\n}\n\nexports.Char = Char;\nexports.Node = Node;\nexports.PlainValue = PlainValue;\nexports.Range = Range;\nexports.Type = Type;\nexports.YAMLError = YAMLError;\nexports.YAMLReferenceError = YAMLReferenceError;\nexports.YAMLSemanticError = YAMLSemanticError;\nexports.YAMLSyntaxError = YAMLSyntaxError;\nexports.YAMLWarning = YAMLWarning;\nexports._defineProperty = _defineProperty;\nexports.defaultTagPrefix = defaultTagPrefix;\nexports.defaultTags = defaultTags;\n","module.exports = require(\"fs\");","module.exports = require(\"path\");","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nfunction addCommentBefore(str, indent, comment) {\n  if (!comment) return str;\n  const cc = comment.replace(/[\\s\\S]^/gm, `$&${indent}#`);\n  return `#${cc}\\n${indent}${str}`;\n}\nfunction addComment(str, indent, comment) {\n  return !comment ? str : comment.indexOf('\\n') === -1 ? `${str} #${comment}` : `${str}\\n` + comment.replace(/^/gm, `${indent || ''}#`);\n}\n\nclass Node {}\n\nfunction toJSON(value, arg, ctx) {\n  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));\n\n  if (value && typeof value.toJSON === 'function') {\n    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);\n    if (anchor) ctx.onCreate = res => {\n      anchor.res = res;\n      delete ctx.onCreate;\n    };\n    const res = value.toJSON(arg, ctx);\n    if (anchor && ctx.onCreate) ctx.onCreate(res);\n    return res;\n  }\n\n  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);\n  return value;\n}\n\nclass Scalar extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n  toJSON(arg, ctx) {\n    return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);\n  }\n\n  toString() {\n    return String(this.value);\n  }\n\n}\n\nfunction collectionFromPath(schema, path, value) {\n  let v = value;\n\n  for (let i = path.length - 1; i >= 0; --i) {\n    const k = path[i];\n    const o = Number.isInteger(k) && k >= 0 ? [] : {};\n    o[k] = v;\n    v = o;\n  }\n\n  return schema.createNode(v, false);\n} // null, undefined, or an empty non-string iterable (e.g. [])\n\n\nconst isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;\nclass Collection extends Node {\n  constructor(schema) {\n    super();\n\n    PlainValue._defineProperty(this, \"items\", []);\n\n    this.schema = schema;\n  }\n\n  addIn(path, value) {\n    if (isEmptyPath(path)) this.add(value);else {\n      const [key, ...rest] = path;\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  }\n\n  deleteIn([key, ...rest]) {\n    if (rest.length === 0) return this.delete(key);\n    const node = this.get(key, true);\n    if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n  }\n\n  getIn([key, ...rest], keepScalar) {\n    const node = this.get(key, true);\n    if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;\n  }\n\n  hasAllNullValues() {\n    return this.items.every(node => {\n      if (!node || node.type !== 'PAIR') return false;\n      const n = node.value;\n      return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n    });\n  }\n\n  hasIn([key, ...rest]) {\n    if (rest.length === 0) return this.has(key);\n    const node = this.get(key, true);\n    return node instanceof Collection ? node.hasIn(rest) : false;\n  }\n\n  setIn([key, ...rest], value) {\n    if (rest.length === 0) {\n      this.set(key, value);\n    } else {\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  } // overridden in implementations\n\n  /* istanbul ignore next */\n\n\n  toJSON() {\n    return null;\n  }\n\n  toString(ctx, {\n    blockItem,\n    flowChars,\n    isMap,\n    itemIndent\n  }, onComment, onChompKeep) {\n    const {\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;\n    if (inFlow) itemIndent += indentStep;\n    const allNullValues = isMap && this.hasAllNullValues();\n    ctx = Object.assign({}, ctx, {\n      allNullValues,\n      indent: itemIndent,\n      inFlow,\n      type: null\n    });\n    let chompKeep = false;\n    let hasItemWithNewLine = false;\n    const nodes = this.items.reduce((nodes, item, i) => {\n      let comment;\n\n      if (item) {\n        if (!chompKeep && item.spaceBefore) nodes.push({\n          type: 'comment',\n          str: ''\n        });\n        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => {\n          nodes.push({\n            type: 'comment',\n            str: `#${line}`\n          });\n        });\n        if (item.comment) comment = item.comment;\n        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;\n      }\n\n      chompKeep = false;\n      let str = stringify(item, ctx, () => comment = null, () => chompKeep = true);\n      if (inFlow && !hasItemWithNewLine && str.includes('\\n')) hasItemWithNewLine = true;\n      if (inFlow && i < this.items.length - 1) str += ',';\n      str = addComment(str, itemIndent, comment);\n      if (chompKeep && (comment || inFlow)) chompKeep = false;\n      nodes.push({\n        type: 'item',\n        str\n      });\n      return nodes;\n    }, []);\n    let str;\n\n    if (nodes.length === 0) {\n      str = flowChars.start + flowChars.end;\n    } else if (inFlow) {\n      const {\n        start,\n        end\n      } = flowChars;\n      const strings = nodes.map(n => n.str);\n\n      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {\n        str = start;\n\n        for (const s of strings) {\n          str += s ? `\\n${indentStep}${indent}${s}` : '\\n';\n        }\n\n        str += `\\n${indent}${end}`;\n      } else {\n        str = `${start} ${strings.join(' ')} ${end}`;\n      }\n    } else {\n      const strings = nodes.map(blockItem);\n      str = strings.shift();\n\n      for (const s of strings) str += s ? `\\n${indent}${s}` : '\\n';\n    }\n\n    if (this.comment) {\n      str += '\\n' + this.comment.replace(/^/gm, `${indent}#`);\n      if (onComment) onComment();\n    } else if (chompKeep && onChompKeep) onChompKeep();\n\n    return str;\n  }\n\n}\n\nPlainValue._defineProperty(Collection, \"maxFlowStringSingleLineLength\", 60);\n\nfunction asItemIndex(key) {\n  let idx = key instanceof Scalar ? key.value : key;\n  if (idx && typeof idx === 'string') idx = Number(idx);\n  return Number.isInteger(idx) && idx >= 0 ? idx : null;\n}\n\nclass YAMLSeq extends Collection {\n  add(value) {\n    this.items.push(value);\n  }\n\n  delete(key) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return false;\n    const del = this.items.splice(idx, 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return undefined;\n    const it = this.items[idx];\n    return !keepScalar && it instanceof Scalar ? it.value : it;\n  }\n\n  has(key) {\n    const idx = asItemIndex(key);\n    return typeof idx === 'number' && idx < this.items.length;\n  }\n\n  set(key, value) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);\n    this.items[idx] = value;\n  }\n\n  toJSON(_, ctx) {\n    const seq = [];\n    if (ctx && ctx.onCreate) ctx.onCreate(seq);\n    let i = 0;\n\n    for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));\n\n    return seq;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    return super.toString(ctx, {\n      blockItem: n => n.type === 'comment' ? n.str : `- ${n.str}`,\n      flowChars: {\n        start: '[',\n        end: ']'\n      },\n      isMap: false,\n      itemIndent: (ctx.indent || '') + '  '\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst stringifyKey = (key, jsKey, ctx) => {\n  if (jsKey === null) return '';\n  if (typeof jsKey !== 'object') return String(jsKey);\n  if (key instanceof Node && ctx && ctx.doc) return key.toString({\n    anchors: {},\n    doc: ctx.doc,\n    indent: '',\n    indentStep: ctx.indentStep,\n    inFlow: true,\n    inStringifyKey: true,\n    stringify: ctx.stringify\n  });\n  return JSON.stringify(jsKey);\n};\n\nclass Pair extends Node {\n  constructor(key, value = null) {\n    super();\n    this.key = key;\n    this.value = value;\n    this.type = Pair.Type.PAIR;\n  }\n\n  get commentBefore() {\n    return this.key instanceof Node ? this.key.commentBefore : undefined;\n  }\n\n  set commentBefore(cb) {\n    if (this.key == null) this.key = new Scalar(null);\n    if (this.key instanceof Node) this.key.commentBefore = cb;else {\n      const msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';\n      throw new Error(msg);\n    }\n  }\n\n  addToJSMap(ctx, map) {\n    const key = toJSON(this.key, '', ctx);\n\n    if (map instanceof Map) {\n      const value = toJSON(this.value, key, ctx);\n      map.set(key, value);\n    } else if (map instanceof Set) {\n      map.add(key);\n    } else {\n      const stringKey = stringifyKey(this.key, key, ctx);\n      map[stringKey] = toJSON(this.value, stringKey, ctx);\n    }\n\n    return map;\n  }\n\n  toJSON(_, ctx) {\n    const pair = ctx && ctx.mapAsMap ? new Map() : {};\n    return this.addToJSMap(ctx, pair);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx || !ctx.doc) return JSON.stringify(this);\n    const {\n      indent: indentSize,\n      indentSeq,\n      simpleKeys\n    } = ctx.doc.options;\n    let {\n      key,\n      value\n    } = this;\n    let keyComment = key instanceof Node && key.comment;\n\n    if (simpleKeys) {\n      if (keyComment) {\n        throw new Error('With simple keys, key nodes cannot have comments');\n      }\n\n      if (key instanceof Collection) {\n        const msg = 'With simple keys, collection cannot be used as a key value';\n        throw new Error(msg);\n      }\n    }\n\n    const explicitKey = !simpleKeys && (!key || keyComment || key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL);\n    const {\n      doc,\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    ctx = Object.assign({}, ctx, {\n      implicitKey: !explicitKey,\n      indent: indent + indentStep\n    });\n    let chompKeep = false;\n    let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);\n    str = addComment(str, ctx.indent, keyComment);\n\n    if (ctx.allNullValues && !simpleKeys) {\n      if (this.comment) {\n        str = addComment(str, ctx.indent, this.comment);\n        if (onComment) onComment();\n      } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();\n\n      return ctx.inFlow ? str : `? ${str}`;\n    }\n\n    str = explicitKey ? `? ${str}\\n${indent}:` : `${str}:`;\n\n    if (this.comment) {\n      // expected (but not strictly required) to be a single-line comment\n      str = addComment(str, ctx.indent, this.comment);\n      if (onComment) onComment();\n    }\n\n    let vcb = '';\n    let valueComment = null;\n\n    if (value instanceof Node) {\n      if (value.spaceBefore) vcb = '\\n';\n\n      if (value.commentBefore) {\n        const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);\n        vcb += `\\n${cs}`;\n      }\n\n      valueComment = value.comment;\n    } else if (value && typeof value === 'object') {\n      value = doc.schema.createNode(value, true);\n    }\n\n    ctx.implicitKey = false;\n    if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n\n    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {\n      // If indentSeq === false, consider '- ' as part of indentation where possible\n      ctx.indent = ctx.indent.substr(2);\n    }\n\n    const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);\n    let ws = ' ';\n\n    if (vcb || this.comment) {\n      ws = `${vcb}\\n${ctx.indent}`;\n    } else if (!explicitKey && value instanceof Collection) {\n      const flow = valueStr[0] === '[' || valueStr[0] === '{';\n      if (!flow || valueStr.includes('\\n')) ws = `\\n${ctx.indent}`;\n    }\n\n    if (chompKeep && !valueComment && onChompKeep) onChompKeep();\n    return addComment(str + ws + valueStr, ctx.indent, valueComment);\n  }\n\n}\n\nPlainValue._defineProperty(Pair, \"Type\", {\n  PAIR: 'PAIR',\n  MERGE_PAIR: 'MERGE_PAIR'\n});\n\nconst getAliasCount = (node, anchors) => {\n  if (node instanceof Alias) {\n    const anchor = anchors.get(node.source);\n    return anchor.count * anchor.aliasCount;\n  } else if (node instanceof Collection) {\n    let count = 0;\n\n    for (const item of node.items) {\n      const c = getAliasCount(item, anchors);\n      if (c > count) count = c;\n    }\n\n    return count;\n  } else if (node instanceof Pair) {\n    const kc = getAliasCount(node.key, anchors);\n    const vc = getAliasCount(node.value, anchors);\n    return Math.max(kc, vc);\n  }\n\n  return 1;\n};\n\nclass Alias extends Node {\n  static stringify({\n    range,\n    source\n  }, {\n    anchors,\n    doc,\n    implicitKey,\n    inStringifyKey\n  }) {\n    let anchor = Object.keys(anchors).find(a => anchors[a] === source);\n    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();\n    if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;\n    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';\n    throw new Error(`${msg} [${range}]`);\n  }\n\n  constructor(source) {\n    super();\n    this.source = source;\n    this.type = PlainValue.Type.ALIAS;\n  }\n\n  set tag(t) {\n    throw new Error('Alias nodes cannot have tags');\n  }\n\n  toJSON(arg, ctx) {\n    if (!ctx) return toJSON(this.source, arg, ctx);\n    const {\n      anchors,\n      maxAliasCount\n    } = ctx;\n    const anchor = anchors.get(this.source);\n    /* istanbul ignore if */\n\n    if (!anchor || anchor.res === undefined) {\n      const msg = 'This should not happen: Alias anchor was not resolved?';\n      if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n    }\n\n    if (maxAliasCount >= 0) {\n      anchor.count += 1;\n      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);\n\n      if (anchor.count * anchor.aliasCount > maxAliasCount) {\n        const msg = 'Excessive alias count indicates a resource exhaustion attack';\n        if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n      }\n    }\n\n    return anchor.res;\n  } // Only called when stringifying an alias mapping key while constructing\n  // Object output.\n\n\n  toString(ctx) {\n    return Alias.stringify(this, ctx);\n  }\n\n}\n\nPlainValue._defineProperty(Alias, \"default\", true);\n\nfunction findPair(items, key) {\n  const k = key instanceof Scalar ? key.value : key;\n\n  for (const it of items) {\n    if (it instanceof Pair) {\n      if (it.key === key || it.key === k) return it;\n      if (it.key && it.key.value === k) return it;\n    }\n  }\n\n  return undefined;\n}\nclass YAMLMap extends Collection {\n  add(pair, overwrite) {\n    if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);\n    const prev = findPair(this.items, pair.key);\n    const sortEntries = this.schema && this.schema.sortMapEntries;\n\n    if (prev) {\n      if (overwrite) prev.value = pair.value;else throw new Error(`Key ${pair.key} already set`);\n    } else if (sortEntries) {\n      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);\n      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);\n    } else {\n      this.items.push(pair);\n    }\n  }\n\n  delete(key) {\n    const it = findPair(this.items, key);\n    if (!it) return false;\n    const del = this.items.splice(this.items.indexOf(it), 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const it = findPair(this.items, key);\n    const node = it && it.value;\n    return !keepScalar && node instanceof Scalar ? node.value : node;\n  }\n\n  has(key) {\n    return !!findPair(this.items, key);\n  }\n\n  set(key, value) {\n    this.add(new Pair(key, value), true);\n  }\n  /**\n   * @param {*} arg ignored\n   * @param {*} ctx Conversion context, originally set in Document#toJSON()\n   * @param {Class} Type If set, forces the returned collection type\n   * @returns {*} Instance of Type, Map, or Object\n   */\n\n\n  toJSON(_, ctx, Type) {\n    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const item of this.items) item.addToJSMap(ctx, map);\n\n    return map;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n\n    for (const item of this.items) {\n      if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n    }\n\n    return super.toString(ctx, {\n      blockItem: n => n.str,\n      flowChars: {\n        start: '{',\n        end: '}'\n      },\n      isMap: true,\n      itemIndent: ctx.indent || ''\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst MERGE_KEY = '<<';\nclass Merge extends Pair {\n  constructor(pair) {\n    if (pair instanceof Pair) {\n      let seq = pair.value;\n\n      if (!(seq instanceof YAMLSeq)) {\n        seq = new YAMLSeq();\n        seq.items.push(pair.value);\n        seq.range = pair.value.range;\n      }\n\n      super(pair.key, seq);\n      this.range = pair.range;\n    } else {\n      super(new Scalar(MERGE_KEY), new YAMLSeq());\n    }\n\n    this.type = Pair.Type.MERGE_PAIR;\n  } // If the value associated with a merge key is a single mapping node, each of\n  // its key/value pairs is inserted into the current mapping, unless the key\n  // already exists in it. If the value associated with the merge key is a\n  // sequence, then this sequence is expected to contain mapping nodes and each\n  // of these nodes is merged in turn according to its order in the sequence.\n  // Keys in mapping nodes earlier in the sequence override keys specified in\n  // later mapping nodes. -- http://yaml.org/type/merge.html\n\n\n  addToJSMap(ctx, map) {\n    for (const {\n      source\n    } of this.value.items) {\n      if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');\n      const srcMap = source.toJSON(null, ctx, Map);\n\n      for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n          if (!map.has(key)) map.set(key, value);\n        } else if (map instanceof Set) {\n          map.add(key);\n        } else {\n          if (!Object.prototype.hasOwnProperty.call(map, key)) map[key] = value;\n        }\n      }\n    }\n\n    return map;\n  }\n\n  toString(ctx, onComment) {\n    const seq = this.value;\n    if (seq.items.length > 1) return super.toString(ctx, onComment);\n    this.value = seq.items[0];\n    const str = super.toString(ctx, onComment);\n    this.value = seq;\n    return str;\n  }\n\n}\n\nconst binaryOptions = {\n  defaultType: PlainValue.Type.BLOCK_LITERAL,\n  lineWidth: 76\n};\nconst boolOptions = {\n  trueStr: 'true',\n  falseStr: 'false'\n};\nconst intOptions = {\n  asBigInt: false\n};\nconst nullOptions = {\n  nullStr: 'null'\n};\nconst strOptions = {\n  defaultType: PlainValue.Type.PLAIN,\n  doubleQuoted: {\n    jsonEncoding: false,\n    minMultiLineLength: 40\n  },\n  fold: {\n    lineWidth: 80,\n    minContentWidth: 20\n  }\n};\n\nfunction resolveScalar(str, tags, scalarFallback) {\n  for (const {\n    format,\n    test,\n    resolve\n  } of tags) {\n    if (test) {\n      const match = str.match(test);\n\n      if (match) {\n        let res = resolve.apply(null, match);\n        if (!(res instanceof Scalar)) res = new Scalar(res);\n        if (format) res.format = format;\n        return res;\n      }\n    }\n  }\n\n  if (scalarFallback) str = scalarFallback(str);\n  return new Scalar(str);\n}\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line\n// returns index of last newline in more-indented block\n\nconst consumeMoreIndentedLines = (text, i) => {\n  let ch = text[i + 1];\n\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n\n    ch = text[i + 1];\n  }\n\n  return i;\n};\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n *\n * @param {string} text\n * @param {string} indent\n * @param {string} [mode='flow'] `'block'` prevents more-indented lines\n *   from being folded; `'quoted'` allows for `\\` escapes, including escaped\n *   newlines\n * @param {Object} options\n * @param {number} [options.indentAtStart] Accounts for leading contents on\n *   the first line, defaulting to `indent.length`\n * @param {number} [options.lineWidth=80]\n * @param {number} [options.minContentWidth=20] Allow highly indented lines to\n *   stretch the line width\n * @param {function} options.onFold Called once if the text is folded\n * @param {function} options.onFold Called once if any line of text exceeds\n *   lineWidth characters\n */\n\n\nfunction foldFlowLines(text, indent, mode, {\n  indentAtStart,\n  lineWidth = 80,\n  minContentWidth = 20,\n  onFold,\n  onOverflow\n}) {\n  if (!lineWidth || lineWidth < 0) return text;\n  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  const folds = [];\n  const escapedFolds = {};\n  let end = lineWidth - (typeof indentAtStart === 'number' ? indentAtStart : indent.length);\n  let split = undefined;\n  let prev = undefined;\n  let overflow = false;\n  let i = -1;\n\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n\n  for (let ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n\n        case 'u':\n          i += 5;\n          break;\n\n        case 'U':\n          i += 9;\n          break;\n\n        default:\n          i += 1;\n      }\n    }\n\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        const next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          } // i - 2 accounts for not-dropped last char + newline-escaping \\\n\n\n          folds.push(i - 2);\n          escapedFolds[i - 2] = true;\n          end = i - 2 + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n\n    prev = ch;\n  }\n\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  let res = text.slice(0, folds[0]);\n\n  for (let i = 0; i < folds.length; ++i) {\n    const fold = folds[i];\n    const end = folds[i + 1] || text.length;\n    if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\\\`;\n    res += `\\n${indent}${text.slice(fold + 1, end)}`;\n  }\n\n  return res;\n}\n\nconst getFoldOptions = ({\n  indentAtStart\n}) => indentAtStart ? Object.assign({\n  indentAtStart\n}, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\n\n\nconst containsDocumentMarker = str => /^(%|---|\\.\\.\\.)/m.test(str);\n\nfunction lineLengthOverLimit(str, limit) {\n  const strLen = str.length;\n  if (strLen <= limit) return false;\n\n  for (let i = 0, start = 0; i < strLen; ++i) {\n    if (str[i] === '\\n') {\n      if (i - start > limit) return true;\n      start = i + 1;\n      if (strLen - start <= limit) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction doubleQuotedString(value, ctx) {\n  const {\n    implicitKey\n  } = ctx;\n  const {\n    jsonEncoding,\n    minMultiLineLength\n  } = strOptions.doubleQuoted;\n  const json = JSON.stringify(value);\n  if (jsonEncoding) return json;\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  let str = '';\n  let start = 0;\n\n  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n    if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n      // space before newline needs to be escaped to not be folded\n      str += json.slice(start, i) + '\\\\ ';\n      i += 1;\n      start = i;\n      ch = '\\\\';\n    }\n\n    if (ch === '\\\\') switch (json[i + 1]) {\n      case 'u':\n        {\n          str += json.slice(start, i);\n          const code = json.substr(i + 2, 4);\n\n          switch (code) {\n            case '0000':\n              str += '\\\\0';\n              break;\n\n            case '0007':\n              str += '\\\\a';\n              break;\n\n            case '000b':\n              str += '\\\\v';\n              break;\n\n            case '001b':\n              str += '\\\\e';\n              break;\n\n            case '0085':\n              str += '\\\\N';\n              break;\n\n            case '00a0':\n              str += '\\\\_';\n              break;\n\n            case '2028':\n              str += '\\\\L';\n              break;\n\n            case '2029':\n              str += '\\\\P';\n              break;\n\n            default:\n              if (code.substr(0, 2) === '00') str += '\\\\x' + code.substr(2);else str += json.substr(i, 6);\n          }\n\n          i += 5;\n          start = i + 1;\n        }\n        break;\n\n      case 'n':\n        if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n          i += 1;\n        } else {\n          // folding will eat first newline\n          str += json.slice(start, i) + '\\n\\n';\n\n          while (json[i + 2] === '\\\\' && json[i + 3] === 'n' && json[i + 4] !== '\"') {\n            str += '\\n';\n            i += 2;\n          }\n\n          str += indent; // space after newline needs to be escaped to not be folded\n\n          if (json[i + 2] === ' ') str += '\\\\';\n          i += 1;\n          start = i + 1;\n        }\n\n        break;\n\n      default:\n        i += 1;\n    }\n  }\n\n  str = start ? str + json.slice(start) : json;\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\n\nfunction singleQuotedString(value, ctx) {\n  if (ctx.implicitKey) {\n    if (/\\n/.test(value)) return doubleQuotedString(value, ctx);\n  } else {\n    // single quoted string can't have leading or trailing whitespace around newline\n    if (/[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\n\nfunction blockString({\n  comment,\n  type,\n  value\n}, ctx, onComment, onChompKeep) {\n  // 1. Block can't end in whitespace unless the last line is non-empty.\n  // 2. Strings consisting of only whitespace are best rendered explicitly.\n  if (/\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n  const indentSize = indent ? '2' : '1'; // root is at -1\n\n  const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth - indent.length);\n  let header = literal ? '|' : '>';\n  if (!value) return header + '\\n';\n  let wsStart = '';\n  let wsEnd = '';\n  value = value.replace(/[\\n\\t ]*$/, ws => {\n    const n = ws.indexOf('\\n');\n\n    if (n === -1) {\n      header += '-'; // strip\n    } else if (value === ws || n !== ws.length - 1) {\n      header += '+'; // keep\n\n      if (onChompKeep) onChompKeep();\n    }\n\n    wsEnd = ws.replace(/\\n$/, '');\n    return '';\n  }).replace(/^[\\n ]*/, ws => {\n    if (ws.indexOf(' ') !== -1) header += indentSize;\n    const m = ws.match(/ +$/);\n\n    if (m) {\n      wsStart = ws.slice(0, -m[0].length);\n      return m[0];\n    } else {\n      wsStart = ws;\n      return '';\n    }\n  });\n  if (wsEnd) wsEnd = wsEnd.replace(/\\n+(?!\\n|$)/g, `$&${indent}`);\n  if (wsStart) wsStart = wsStart.replace(/\\n+/g, `$&${indent}`);\n\n  if (comment) {\n    header += ' #' + comment.replace(/ ?[\\r\\n]+/g, ' ');\n    if (onComment) onComment();\n  }\n\n  if (!value) return `${header}${indentSize}\\n${indent}${wsEnd}`;\n\n  if (literal) {\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `${header}\\n${indent}${wsStart}${value}${wsEnd}`;\n  }\n\n  value = value.replace(/\\n+/g, '\\n$&').replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent\n  .replace(/\\n+/g, `$&${indent}`);\n  const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);\n  return `${header}\\n${indent}${body}`;\n}\n\nfunction plainString(item, ctx, onComment, onChompKeep) {\n  const {\n    comment,\n    type,\n    value\n  } = item;\n  const {\n    actualString,\n    implicitKey,\n    indent,\n    inFlow\n  } = ctx;\n\n  if (implicitKey && /[\\n[\\]{},]/.test(value) || inFlow && /[[\\]{},]/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n    // not allowed:\n    // - empty string, '-' or '?'\n    // - start with an indicator character (except [?:-]) or /[?-] /\n    // - '\\n ', ': ' or ' \\n' anywhere\n    // - '#' not preceded by a non-space char\n    // - end with ' ' or ':'\n    return implicitKey || inFlow || value.indexOf('\\n') === -1 ? value.indexOf('\"') !== -1 && value.indexOf(\"'\") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf('\\n') !== -1) {\n    // Where allowed & type not set explicitly, prefer block style for multiline strings\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (indent === '' && containsDocumentMarker(value)) {\n    ctx.forceBlockIndent = true;\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  const str = value.replace(/\\n+/g, `$&\\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and\n  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n  // and others in v1.1.\n\n  if (actualString) {\n    const {\n      tags\n    } = ctx.doc.schema;\n    const resolved = resolveScalar(str, tags, tags.scalarFallback).value;\n    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);\n  }\n\n  const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n\n  if (comment && !inFlow && (body.indexOf('\\n') !== -1 || comment.indexOf('\\n') !== -1)) {\n    if (onComment) onComment();\n    return addCommentBefore(body, indent, comment);\n  }\n\n  return body;\n}\n\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n  const {\n    defaultType\n  } = strOptions;\n  const {\n    implicitKey,\n    inFlow\n  } = ctx;\n  let {\n    type,\n    value\n  } = item;\n\n  if (typeof value !== 'string') {\n    value = String(value);\n    item = Object.assign({}, item, {\n      value\n    });\n  }\n\n  const _stringify = _type => {\n    switch (_type) {\n      case PlainValue.Type.BLOCK_FOLDED:\n      case PlainValue.Type.BLOCK_LITERAL:\n        return blockString(item, ctx, onComment, onChompKeep);\n\n      case PlainValue.Type.QUOTE_DOUBLE:\n        return doubleQuotedString(value, ctx);\n\n      case PlainValue.Type.QUOTE_SINGLE:\n        return singleQuotedString(value, ctx);\n\n      case PlainValue.Type.PLAIN:\n        return plainString(item, ctx, onComment, onChompKeep);\n\n      default:\n        return null;\n    }\n  };\n\n  if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f]/.test(value)) {\n    // force double quotes on control characters\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {\n    // should not happen; blocks are not valid inside flow containers\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  }\n\n  let res = _stringify(type);\n\n  if (res === null) {\n    res = _stringify(defaultType);\n    if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);\n  }\n\n  return res;\n}\n\nfunction stringifyNumber({\n  format,\n  minFractionDigits,\n  tag,\n  value\n}) {\n  if (typeof value === 'bigint') return String(value);\n  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';\n  let n = JSON.stringify(value);\n\n  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\\d/.test(n)) {\n    let i = n.indexOf('.');\n\n    if (i < 0) {\n      i = n.length;\n      n += '.';\n    }\n\n    let d = minFractionDigits - (n.length - i - 1);\n\n    while (d-- > 0) n += '0';\n  }\n\n  return n;\n}\n\nfunction checkFlowCollectionEnd(errors, cst) {\n  let char, name;\n\n  switch (cst.type) {\n    case PlainValue.Type.FLOW_MAP:\n      char = '}';\n      name = 'flow map';\n      break;\n\n    case PlainValue.Type.FLOW_SEQ:\n      char = ']';\n      name = 'flow sequence';\n      break;\n\n    default:\n      errors.push(new PlainValue.YAMLSemanticError(cst, 'Not a flow collection!?'));\n      return;\n  }\n\n  let lastItem;\n\n  for (let i = cst.items.length - 1; i >= 0; --i) {\n    const item = cst.items[i];\n\n    if (!item || item.type !== PlainValue.Type.COMMENT) {\n      lastItem = item;\n      break;\n    }\n  }\n\n  if (lastItem && lastItem.char !== char) {\n    const msg = `Expected ${name} to end with ${char}`;\n    let err;\n\n    if (typeof lastItem.offset === 'number') {\n      err = new PlainValue.YAMLSemanticError(cst, msg);\n      err.offset = lastItem.offset + 1;\n    } else {\n      err = new PlainValue.YAMLSemanticError(lastItem, msg);\n      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;\n    }\n\n    errors.push(err);\n  }\n}\nfunction checkFlowCommentSpace(errors, comment) {\n  const prev = comment.context.src[comment.range.start - 1];\n\n  if (prev !== '\\n' && prev !== '\\t' && prev !== ' ') {\n    const msg = 'Comments must be separated from other tokens by white space characters';\n    errors.push(new PlainValue.YAMLSemanticError(comment, msg));\n  }\n}\nfunction getLongKeyError(source, key) {\n  const sk = String(key);\n  const k = sk.substr(0, 8) + '...' + sk.substr(-8);\n  return new PlainValue.YAMLSemanticError(source, `The \"${k}\" key is too long`);\n}\nfunction resolveComments(collection, comments) {\n  for (const {\n    afterKey,\n    before,\n    comment\n  } of comments) {\n    let item = collection.items[before];\n\n    if (!item) {\n      if (comment !== undefined) {\n        if (collection.comment) collection.comment += '\\n' + comment;else collection.comment = comment;\n      }\n    } else {\n      if (afterKey && item.value) item = item.value;\n\n      if (comment === undefined) {\n        if (afterKey || !item.commentBefore) item.spaceBefore = true;\n      } else {\n        if (item.commentBefore) item.commentBefore += '\\n' + comment;else item.commentBefore = comment;\n      }\n    }\n  }\n}\n\n// on error, will return { str: string, errors: Error[] }\nfunction resolveString(doc, node) {\n  const res = node.strValue;\n  if (!res) return '';\n  if (typeof res === 'string') return res;\n  res.errors.forEach(error => {\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n  });\n  return res.str;\n}\n\nfunction resolveTagHandle(doc, node) {\n  const {\n    handle,\n    suffix\n  } = node.tag;\n  let prefix = doc.tagPrefixes.find(p => p.handle === handle);\n\n  if (!prefix) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    if (dtp) prefix = dtp.find(p => p.handle === handle);\n    if (!prefix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);\n  }\n\n  if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);\n\n  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {\n    if (suffix[0] === '^') {\n      doc.warnings.push(new PlainValue.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));\n      return suffix;\n    }\n\n    if (/[:/]/.test(suffix)) {\n      // word/foo -> tag:word.yaml.org,2002:foo\n      const vocab = suffix.match(/^([a-z0-9-]+)\\/(.*)/i);\n      return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;\n    }\n  }\n\n  return prefix.prefix + decodeURIComponent(suffix);\n}\n\nfunction resolveTagName(doc, node) {\n  const {\n    tag,\n    type\n  } = node;\n  let nonSpecific = false;\n\n  if (tag) {\n    const {\n      handle,\n      suffix,\n      verbatim\n    } = tag;\n\n    if (verbatim) {\n      if (verbatim !== '!' && verbatim !== '!!') return verbatim;\n      const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;\n      doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n    } else if (handle === '!' && !suffix) {\n      nonSpecific = true;\n    } else {\n      try {\n        return resolveTagHandle(doc, node);\n      } catch (error) {\n        doc.errors.push(error);\n      }\n    }\n  }\n\n  switch (type) {\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n    case PlainValue.Type.QUOTE_DOUBLE:\n    case PlainValue.Type.QUOTE_SINGLE:\n      return PlainValue.defaultTags.STR;\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    case PlainValue.Type.PLAIN:\n      return nonSpecific ? PlainValue.defaultTags.STR : null;\n\n    default:\n      return null;\n  }\n}\n\nfunction resolveByTagName(doc, node, tagName) {\n  const {\n    tags\n  } = doc.schema;\n  const matchWithTest = [];\n\n  for (const tag of tags) {\n    if (tag.tag === tagName) {\n      if (tag.test) matchWithTest.push(tag);else {\n        const res = tag.resolve(doc, node);\n        return res instanceof Collection ? res : new Scalar(res);\n      }\n    }\n  }\n\n  const str = resolveString(doc, node);\n  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);\n  return null;\n}\n\nfunction getFallbackTagName({\n  type\n}) {\n  switch (type) {\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    default:\n      return PlainValue.defaultTags.STR;\n  }\n}\n\nfunction resolveTag(doc, node, tagName) {\n  try {\n    const res = resolveByTagName(doc, node, tagName);\n\n    if (res) {\n      if (tagName && node.tag) res.tag = tagName;\n      return res;\n    }\n  } catch (error) {\n    /* istanbul ignore if */\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n    return null;\n  }\n\n  try {\n    const fallback = getFallbackTagName(node);\n    if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);\n    const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(node, msg));\n    const res = resolveByTagName(doc, node, fallback);\n    res.tag = tagName;\n    return res;\n  } catch (error) {\n    const refError = new PlainValue.YAMLReferenceError(node, error.message);\n    refError.stack = error.stack;\n    doc.errors.push(refError);\n    return null;\n  }\n}\n\nconst isCollectionItem = node => {\n  if (!node) return false;\n  const {\n    type\n  } = node;\n  return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;\n};\n\nfunction resolveNodeProps(errors, node) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let hasAnchor = false;\n  let hasTag = false;\n  const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;\n\n  for (const {\n    start,\n    end\n  } of props) {\n    switch (node.context.src[start]) {\n      case PlainValue.Char.COMMENT:\n        {\n          if (!node.commentHasRequiredWhitespace(start)) {\n            const msg = 'Comments must be separated from other tokens by white space characters';\n            errors.push(new PlainValue.YAMLSemanticError(node, msg));\n          }\n\n          const {\n            header,\n            valueRange\n          } = node;\n          const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;\n          cc.push(node.context.src.slice(start + 1, end));\n          break;\n        }\n      // Actual anchor & tag resolution is handled by schema, here we just complain\n\n      case PlainValue.Char.ANCHOR:\n        if (hasAnchor) {\n          const msg = 'A node can have at most one anchor';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasAnchor = true;\n        break;\n\n      case PlainValue.Char.TAG:\n        if (hasTag) {\n          const msg = 'A node can have at most one tag';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasTag = true;\n        break;\n    }\n  }\n\n  return {\n    comments,\n    hasAnchor,\n    hasTag\n  };\n}\n\nfunction resolveNodeValue(doc, node) {\n  const {\n    anchors,\n    errors,\n    schema\n  } = doc;\n\n  if (node.type === PlainValue.Type.ALIAS) {\n    const name = node.rawValue;\n    const src = anchors.getNode(name);\n\n    if (!src) {\n      const msg = `Aliased anchor not found: ${name}`;\n      errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    } // Lazy resolution for circular references\n\n\n    const res = new Alias(src);\n\n    anchors._cstAliases.push(res);\n\n    return res;\n  }\n\n  const tagName = resolveTagName(doc, node);\n  if (tagName) return resolveTag(doc, node, tagName);\n\n  if (node.type !== PlainValue.Type.PLAIN) {\n    const msg = `Failed to resolve ${node.type} node here`;\n    errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n    return null;\n  }\n\n  try {\n    const str = resolveString(doc, node);\n    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);\n  } catch (error) {\n    if (!error.source) error.source = node;\n    errors.push(error);\n    return null;\n  }\n} // sets node.resolved on success\n\n\nfunction resolveNode(doc, node) {\n  if (!node) return null;\n  if (node.error) doc.errors.push(node.error);\n  const {\n    comments,\n    hasAnchor,\n    hasTag\n  } = resolveNodeProps(doc.errors, node);\n\n  if (hasAnchor) {\n    const {\n      anchors\n    } = doc;\n    const name = node.anchor;\n    const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor\n    // name have already been resolved, so it may safely be renamed.\n\n    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as\n    // anchors need to be available during resolution to allow for\n    // circular references.\n\n    anchors.map[name] = node;\n  }\n\n  if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {\n    const msg = 'An alias node must not specify any properties';\n    doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n  }\n\n  const res = resolveNodeValue(doc, node);\n\n  if (res) {\n    res.range = [node.range.start, node.range.end];\n    if (doc.options.keepCstNodes) res.cstNode = node;\n    if (doc.options.keepNodeTypes) res.type = node.type;\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      res.commentBefore = res.commentBefore ? `${res.commentBefore}\\n${cb}` : cb;\n    }\n\n    const ca = comments.after.join('\\n');\n    if (ca) res.comment = res.comment ? `${res.comment}\\n${ca}` : ca;\n  }\n\n  return node.resolved = res;\n}\n\nfunction resolveMap(doc, cst) {\n  if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {\n    const msg = `A ${cst.type} node cannot be resolved as a mapping`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);\n  const map = new YAMLMap();\n  map.items = items;\n  resolveComments(map, comments);\n  let hasCollectionKey = false;\n\n  for (let i = 0; i < items.length; ++i) {\n    const {\n      key: iKey\n    } = items[i];\n    if (iKey instanceof Collection) hasCollectionKey = true;\n\n    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {\n      items[i] = new Merge(items[i]);\n      const sources = items[i].value.items;\n      let error = null;\n      sources.some(node => {\n        if (node instanceof Alias) {\n          // During parsing, alias sources are CST nodes; to account for\n          // circular references their resolved values can't be used here.\n          const {\n            type\n          } = node.source;\n          if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;\n          return error = 'Merge nodes aliases can only point to maps';\n        }\n\n        return error = 'Merge nodes can only have Alias nodes as values';\n      });\n      if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));\n    } else {\n      for (let j = i + 1; j < items.length; ++j) {\n        const {\n          key: jKey\n        } = items[j];\n\n        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {\n          const msg = `Map keys must be unique; \"${iKey}\" is repeated`;\n          doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));\n          break;\n        }\n      }\n    }\n  }\n\n  if (hasCollectionKey && !doc.options.mapAsMap) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = map;\n  return map;\n}\n\nconst valueHasPairComment = ({\n  context: {\n    lineStart,\n    node,\n    src\n  },\n  props\n}) => {\n  if (props.length === 0) return false;\n  const {\n    start\n  } = props[0];\n  if (node && start > node.valueRange.start) return false;\n  if (src[start] !== PlainValue.Char.COMMENT) return false;\n\n  for (let i = lineStart; i < start; ++i) if (src[i] === '\\n') return false;\n\n  return true;\n};\n\nfunction resolvePairComment(item, pair) {\n  if (!valueHasPairComment(item)) return;\n  const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);\n  let found = false;\n  const cb = pair.value.commentBefore;\n\n  if (cb && cb.startsWith(comment)) {\n    pair.value.commentBefore = cb.substr(comment.length + 1);\n    found = true;\n  } else {\n    const cc = pair.value.comment;\n\n    if (!item.node && cc && cc.startsWith(comment)) {\n      pair.value.comment = cc.substr(comment.length + 1);\n      found = true;\n    }\n  }\n\n  if (found) pair.comment = comment;\n}\n\nfunction resolveBlockMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let keyStart = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          afterKey: !!key,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          afterKey: !!key,\n          before: items.length,\n          comment: item.comment\n        });\n        break;\n\n      case PlainValue.Type.MAP_KEY:\n        if (key !== undefined) items.push(new Pair(key));\n        if (item.error) doc.errors.push(item.error);\n        key = resolveNode(doc, item.node);\n        keyStart = null;\n        break;\n\n      case PlainValue.Type.MAP_VALUE:\n        {\n          if (key === undefined) key = null;\n          if (item.error) doc.errors.push(item.error);\n\n          if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {\n            const msg = 'Nested mappings are not allowed in compact mappings';\n            doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));\n          }\n\n          let valueNode = item.node;\n\n          if (!valueNode && item.props.length > 0) {\n            // Comments on an empty mapping value need to be preserved, so we\n            // need to construct a minimal empty node here to use instead of the\n            // missing `item.node`. -- eemeli/yaml#19\n            valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);\n            valueNode.context = {\n              parent: item,\n              src: item.context.src\n            };\n            const pos = item.range.start + 1;\n            valueNode.range = {\n              start: pos,\n              end: pos\n            };\n            valueNode.valueRange = {\n              start: pos,\n              end: pos\n            };\n\n            if (typeof item.range.origStart === 'number') {\n              const origPos = item.range.origStart + 1;\n              valueNode.range.origStart = valueNode.range.origEnd = origPos;\n              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;\n            }\n          }\n\n          const pair = new Pair(key, resolveNode(doc, valueNode));\n          resolvePairComment(item, pair);\n          items.push(pair);\n\n          if (key && typeof keyStart === 'number') {\n            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n          }\n\n          key = undefined;\n          keyStart = null;\n        }\n        break;\n\n      default:\n        if (key !== undefined) items.push(new Pair(key));\n        key = resolveNode(doc, item);\n        keyStart = item.range.start;\n        if (item.error) doc.errors.push(item.error);\n\n        next: for (let j = i + 1;; ++j) {\n          const nextItem = cst.items[j];\n\n          switch (nextItem && nextItem.type) {\n            case PlainValue.Type.BLANK_LINE:\n            case PlainValue.Type.COMMENT:\n              continue next;\n\n            case PlainValue.Type.MAP_VALUE:\n              break next;\n\n            default:\n              {\n                const msg = 'Implicit map keys need to be followed by map values';\n                doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n                break next;\n              }\n          }\n        }\n\n        if (item.valueRangeContainsNewline) {\n          const msg = 'Implicit map keys need to be on a single line';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n    }\n  }\n\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let explicitKey = false;\n  let next = '{';\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char === '?' && key === undefined && !explicitKey) {\n        explicitKey = true;\n        next = ':';\n        continue;\n      }\n\n      if (char === ':') {\n        if (key === undefined) key = null;\n\n        if (next === ':') {\n          next = ',';\n          continue;\n        }\n      } else {\n        if (explicitKey) {\n          if (key === undefined && char !== ',') key = null;\n          explicitKey = false;\n        }\n\n        if (key !== undefined) {\n          items.push(new Pair(key));\n          key = undefined;\n\n          if (char === ',') {\n            next = ':';\n            continue;\n          }\n        }\n      }\n\n      if (char === '}') {\n        if (i === cst.items.length - 1) continue;\n      } else if (char === next) {\n        next = ':';\n        continue;\n      }\n\n      const msg = `Flow map contains an unexpected ${char}`;\n      const err = new PlainValue.YAMLSyntaxError(cst, msg);\n      err.offset = offset;\n      doc.errors.push(err);\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        afterKey: !!key,\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        afterKey: !!key,\n        before: items.length,\n        comment: item.comment\n      });\n    } else if (key === undefined) {\n      if (next === ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Separator , missing in flow map'));\n      key = resolveNode(doc, item);\n    } else {\n      if (next !== ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));\n      items.push(new Pair(key, resolveNode(doc, item)));\n      key = undefined;\n      explicitKey = false;\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveSeq(doc, cst) {\n  if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {\n    const msg = `A ${cst.type} node cannot be resolved as a sequence`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);\n  const seq = new YAMLSeq();\n  seq.items = items;\n  resolveComments(seq, comments);\n\n  if (!doc.options.mapAsMap && items.some(it => it instanceof Pair && it.key instanceof Collection)) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = seq;\n  return seq;\n}\n\nfunction resolveBlockSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          comment: item.comment,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.SEQ_ITEM:\n        if (item.error) doc.errors.push(item.error);\n        items.push(resolveNode(doc, item.node));\n\n        if (item.hasProps) {\n          const msg = 'Sequence items cannot have tags or anchors before the - indicator';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n        break;\n\n      default:\n        if (item.error) doc.errors.push(item.error);\n        doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));\n    }\n  }\n\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let explicitKey = false;\n  let key = undefined;\n  let keyStart = null;\n  let next = '[';\n  let prevItem = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char !== ':' && (explicitKey || key !== undefined)) {\n        if (explicitKey && key === undefined) key = next ? items.pop() : null;\n        items.push(new Pair(key));\n        explicitKey = false;\n        key = undefined;\n        keyStart = null;\n      }\n\n      if (char === next) {\n        next = null;\n      } else if (!next && char === '?') {\n        explicitKey = true;\n      } else if (next !== '[' && char === ':' && key === undefined) {\n        if (next === ',') {\n          key = items.pop();\n\n          if (key instanceof Pair) {\n            const msg = 'Chaining flow sequence pairs is invalid';\n            const err = new PlainValue.YAMLSemanticError(cst, msg);\n            err.offset = offset;\n            doc.errors.push(err);\n          }\n\n          if (!explicitKey && typeof keyStart === 'number') {\n            const keyEnd = item.range ? item.range.start : item.offset;\n            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n            const {\n              src\n            } = prevItem.context;\n\n            for (let i = keyStart; i < keyEnd; ++i) if (src[i] === '\\n') {\n              const msg = 'Implicit keys of flow sequence pairs need to be on a single line';\n              doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));\n              break;\n            }\n          }\n        } else {\n          key = null;\n        }\n\n        keyStart = null;\n        explicitKey = false;\n        next = null;\n      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {\n        const msg = `Flow sequence contains an unexpected ${char}`;\n        const err = new PlainValue.YAMLSyntaxError(cst, msg);\n        err.offset = offset;\n        doc.errors.push(err);\n      }\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        comment: item.comment,\n        before: items.length\n      });\n    } else {\n      if (next) {\n        const msg = `Expected a ${next} in flow sequence`;\n        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n      }\n\n      const value = resolveNode(doc, item);\n\n      if (key === undefined) {\n        items.push(value);\n        prevItem = item;\n      } else {\n        items.push(new Pair(key, value));\n        key = undefined;\n      }\n\n      keyStart = item.range.start;\n      next = ',';\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nexports.Alias = Alias;\nexports.Collection = Collection;\nexports.Merge = Merge;\nexports.Node = Node;\nexports.Pair = Pair;\nexports.Scalar = Scalar;\nexports.YAMLMap = YAMLMap;\nexports.YAMLSeq = YAMLSeq;\nexports.addComment = addComment;\nexports.binaryOptions = binaryOptions;\nexports.boolOptions = boolOptions;\nexports.findPair = findPair;\nexports.intOptions = intOptions;\nexports.isEmptyPath = isEmptyPath;\nexports.nullOptions = nullOptions;\nexports.resolveMap = resolveMap;\nexports.resolveNode = resolveNode;\nexports.resolveSeq = resolveSeq;\nexports.resolveString = resolveString;\nexports.strOptions = strOptions;\nexports.stringifyNumber = stringifyNumber;\nexports.stringifyString = stringifyString;\nexports.toJSON = toJSON;\n","module.exports = require(\"url\");","export { default } from \"./inputs\"\n","module.exports = require(\"http\");","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\nvar warnings = require('./warnings-39684f17.js');\n\nfunction createMap(schema, obj, ctx) {\n  const map = new resolveSeq.YAMLMap(schema);\n\n  if (obj instanceof Map) {\n    for (const [key, value] of obj) map.items.push(schema.createPair(key, value, ctx));\n  } else if (obj && typeof obj === 'object') {\n    for (const key of Object.keys(obj)) map.items.push(schema.createPair(key, obj[key], ctx));\n  }\n\n  if (typeof schema.sortMapEntries === 'function') {\n    map.items.sort(schema.sortMapEntries);\n  }\n\n  return map;\n}\n\nconst map = {\n  createNode: createMap,\n  default: true,\n  nodeClass: resolveSeq.YAMLMap,\n  tag: 'tag:yaml.org,2002:map',\n  resolve: resolveSeq.resolveMap\n};\n\nfunction createSeq(schema, obj, ctx) {\n  const seq = new resolveSeq.YAMLSeq(schema);\n\n  if (obj && obj[Symbol.iterator]) {\n    for (const it of obj) {\n      const v = schema.createNode(it, ctx.wrapScalars, null, ctx);\n      seq.items.push(v);\n    }\n  }\n\n  return seq;\n}\n\nconst seq = {\n  createNode: createSeq,\n  default: true,\n  nodeClass: resolveSeq.YAMLSeq,\n  tag: 'tag:yaml.org,2002:seq',\n  resolve: resolveSeq.resolveSeq\n};\n\nconst string = {\n  identify: value => typeof value === 'string',\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveSeq.resolveString,\n\n  stringify(item, ctx, onComment, onChompKeep) {\n    ctx = Object.assign({\n      actualString: true\n    }, ctx);\n    return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);\n  },\n\n  options: resolveSeq.strOptions\n};\n\nconst failsafe = [map, seq, string];\n\n/* global BigInt */\n\nconst intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);\n\nconst intResolve = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);\n\nfunction intStringify(node, radix, prefix) {\n  const {\n    value\n  } = node;\n  if (intIdentify(value) && value >= 0) return prefix + value.toString(radix);\n  return resolveSeq.stringifyNumber(node);\n}\n\nconst nullObj = {\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: () => null,\n  options: resolveSeq.nullOptions,\n  stringify: () => resolveSeq.nullOptions.nullStr\n};\nconst boolObj = {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n  resolve: str => str[0] === 't' || str[0] === 'T',\n  options: resolveSeq.boolOptions,\n  stringify: ({\n    value\n  }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr\n};\nconst octObj = {\n  identify: value => intIdentify(value) && value >= 0,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^0o([0-7]+)$/,\n  resolve: (str, oct) => intResolve(str, oct, 8),\n  options: resolveSeq.intOptions,\n  stringify: node => intStringify(node, 8, '0o')\n};\nconst intObj = {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^[-+]?[0-9]+$/,\n  resolve: str => intResolve(str, str, 10),\n  options: resolveSeq.intOptions,\n  stringify: resolveSeq.stringifyNumber\n};\nconst hexObj = {\n  identify: value => intIdentify(value) && value >= 0,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^0x([0-9a-fA-F]+)$/,\n  resolve: (str, hex) => intResolve(str, hex, 16),\n  options: resolveSeq.intOptions,\n  stringify: node => intStringify(node, 16, '0x')\n};\nconst nanObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,\n  stringify: resolveSeq.stringifyNumber\n};\nconst expObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n  resolve: str => parseFloat(str),\n  stringify: ({\n    value\n  }) => Number(value).toExponential()\n};\nconst floatObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:\\.([0-9]+)|[0-9]+\\.([0-9]*))$/,\n\n  resolve(str, frac1, frac2) {\n    const frac = frac1 || frac2;\n    const node = new resolveSeq.Scalar(parseFloat(str));\n    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;\n    return node;\n  },\n\n  stringify: resolveSeq.stringifyNumber\n};\nconst core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);\n\n/* global BigInt */\n\nconst intIdentify$1 = value => typeof value === 'bigint' || Number.isInteger(value);\n\nconst stringifyJSON = ({\n  value\n}) => JSON.stringify(value);\n\nconst json = [map, seq, {\n  identify: value => typeof value === 'string',\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveSeq.resolveString,\n  stringify: stringifyJSON\n}, {\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^null$/,\n  resolve: () => null,\n  stringify: stringifyJSON\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^true|false$/,\n  resolve: str => str === 'true',\n  stringify: stringifyJSON\n}, {\n  identify: intIdentify$1,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^-?(?:0|[1-9][0-9]*)$/,\n  resolve: str => resolveSeq.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),\n  stringify: ({\n    value\n  }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n  resolve: str => parseFloat(str),\n  stringify: stringifyJSON\n}];\n\njson.scalarFallback = str => {\n  throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n};\n\n/* global BigInt */\n\nconst boolStringify = ({\n  value\n}) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;\n\nconst intIdentify$2 = value => typeof value === 'bigint' || Number.isInteger(value);\n\nfunction intResolve$1(sign, src, radix) {\n  let str = src.replace(/_/g, '');\n\n  if (resolveSeq.intOptions.asBigInt) {\n    switch (radix) {\n      case 2:\n        str = `0b${str}`;\n        break;\n\n      case 8:\n        str = `0o${str}`;\n        break;\n\n      case 16:\n        str = `0x${str}`;\n        break;\n    }\n\n    const n = BigInt(str);\n    return sign === '-' ? BigInt(-1) * n : n;\n  }\n\n  const n = parseInt(str, radix);\n  return sign === '-' ? -1 * n : n;\n}\n\nfunction intStringify$1(node, radix, prefix) {\n  const {\n    value\n  } = node;\n\n  if (intIdentify$2(value)) {\n    const str = value.toString(radix);\n    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n  }\n\n  return resolveSeq.stringifyNumber(node);\n}\n\nconst yaml11 = failsafe.concat([{\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: () => null,\n  options: resolveSeq.nullOptions,\n  stringify: () => resolveSeq.nullOptions.nullStr\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n  resolve: () => true,\n  options: resolveSeq.boolOptions,\n  stringify: boolStringify\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,\n  resolve: () => false,\n  options: resolveSeq.boolOptions,\n  stringify: boolStringify\n}, {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'BIN',\n  test: /^([-+]?)0b([0-1_]+)$/,\n  resolve: (str, sign, bin) => intResolve$1(sign, bin, 2),\n  stringify: node => intStringify$1(node, 2, '0b')\n}, {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^([-+]?)0([0-7_]+)$/,\n  resolve: (str, sign, oct) => intResolve$1(sign, oct, 8),\n  stringify: node => intStringify$1(node, 8, '0')\n}, {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^([-+]?)([0-9][0-9_]*)$/,\n  resolve: (str, sign, abs) => intResolve$1(sign, abs, 10),\n  stringify: resolveSeq.stringifyNumber\n}, {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,\n  resolve: (str, sign, hex) => intResolve$1(sign, hex, 16),\n  stringify: node => intStringify$1(node, 16, '0x')\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,\n  stringify: resolveSeq.stringifyNumber\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?([0-9][0-9_]*)?(\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n  resolve: str => parseFloat(str.replace(/_/g, '')),\n  stringify: ({\n    value\n  }) => Number(value).toExponential()\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:[0-9][0-9_]*)?\\.([0-9_]*)$/,\n\n  resolve(str, frac) {\n    const node = new resolveSeq.Scalar(parseFloat(str.replace(/_/g, '')));\n\n    if (frac) {\n      const f = frac.replace(/_/g, '');\n      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;\n    }\n\n    return node;\n  },\n\n  stringify: resolveSeq.stringifyNumber\n}], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);\n\nconst schemas = {\n  core,\n  failsafe,\n  json,\n  yaml11\n};\nconst tags = {\n  binary: warnings.binary,\n  bool: boolObj,\n  float: floatObj,\n  floatExp: expObj,\n  floatNaN: nanObj,\n  floatTime: warnings.floatTime,\n  int: intObj,\n  intHex: hexObj,\n  intOct: octObj,\n  intTime: warnings.intTime,\n  map,\n  null: nullObj,\n  omap: warnings.omap,\n  pairs: warnings.pairs,\n  seq,\n  set: warnings.set,\n  timestamp: warnings.timestamp\n};\n\nfunction findTagObject(value, tagName, tags) {\n  if (tagName) {\n    const match = tags.filter(t => t.tag === tagName);\n    const tagObj = match.find(t => !t.format) || match[0];\n    if (!tagObj) throw new Error(`Tag ${tagName} not found`);\n    return tagObj;\n  } // TODO: deprecate/remove class check\n\n\n  return tags.find(t => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);\n}\n\nfunction createNode(value, tagName, ctx) {\n  if (value instanceof resolveSeq.Node) return value;\n  const {\n    defaultPrefix,\n    onTagObj,\n    prevObjects,\n    schema,\n    wrapScalars\n  } = ctx;\n  if (tagName && tagName.startsWith('!!')) tagName = defaultPrefix + tagName.slice(2);\n  let tagObj = findTagObject(value, tagName, schema.tags);\n\n  if (!tagObj) {\n    if (typeof value.toJSON === 'function') value = value.toJSON();\n    if (typeof value !== 'object') return wrapScalars ? new resolveSeq.Scalar(value) : value;\n    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;\n  }\n\n  if (onTagObj) {\n    onTagObj(tagObj);\n    delete ctx.onTagObj;\n  } // Detect duplicate references to the same object & use Alias nodes for all\n  // after first. The `obj` wrapper allows for circular references to resolve.\n\n\n  const obj = {};\n\n  if (value && typeof value === 'object' && prevObjects) {\n    const prev = prevObjects.get(value);\n\n    if (prev) {\n      const alias = new resolveSeq.Alias(prev); // leaves source dirty; must be cleaned by caller\n\n      ctx.aliasNodes.push(alias); // defined along with prevObjects\n\n      return alias;\n    }\n\n    obj.value = value;\n    prevObjects.set(value, obj);\n  }\n\n  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;\n  if (tagName && obj.node instanceof resolveSeq.Node) obj.node.tag = tagName;\n  return obj.node;\n}\n\nfunction getSchemaTags(schemas, knownTags, customTags, schemaId) {\n  let tags = schemas[schemaId.replace(/\\W/g, '')]; // 'yaml-1.1' -> 'yaml11'\n\n  if (!tags) {\n    const keys = Object.keys(schemas).map(key => JSON.stringify(key)).join(', ');\n    throw new Error(`Unknown schema \"${schemaId}\"; use one of ${keys}`);\n  }\n\n  if (Array.isArray(customTags)) {\n    for (const tag of customTags) tags = tags.concat(tag);\n  } else if (typeof customTags === 'function') {\n    tags = customTags(tags.slice());\n  }\n\n  for (let i = 0; i < tags.length; ++i) {\n    const tag = tags[i];\n\n    if (typeof tag === 'string') {\n      const tagObj = knownTags[tag];\n\n      if (!tagObj) {\n        const keys = Object.keys(knownTags).map(key => JSON.stringify(key)).join(', ');\n        throw new Error(`Unknown custom tag \"${tag}\"; use one of ${keys}`);\n      }\n\n      tags[i] = tagObj;\n    }\n  }\n\n  return tags;\n}\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\n\nclass Schema {\n  // TODO: remove in v2\n  // TODO: remove in v2\n  constructor({\n    customTags,\n    merge,\n    schema,\n    sortMapEntries,\n    tags: deprecatedCustomTags\n  }) {\n    this.merge = !!merge;\n    this.name = schema;\n    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;\n    if (!customTags && deprecatedCustomTags) warnings.warnOptionDeprecation('tags', 'customTags');\n    this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);\n  }\n\n  createNode(value, wrapScalars, tagName, ctx) {\n    const baseCtx = {\n      defaultPrefix: Schema.defaultPrefix,\n      schema: this,\n      wrapScalars\n    };\n    const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;\n    return createNode(value, tagName, createCtx);\n  }\n\n  createPair(key, value, ctx) {\n    if (!ctx) ctx = {\n      wrapScalars: true\n    };\n    const k = this.createNode(key, ctx.wrapScalars, null, ctx);\n    const v = this.createNode(value, ctx.wrapScalars, null, ctx);\n    return new resolveSeq.Pair(k, v);\n  }\n\n}\n\nPlainValue._defineProperty(Schema, \"defaultPrefix\", PlainValue.defaultTagPrefix);\n\nPlainValue._defineProperty(Schema, \"defaultTags\", PlainValue.defaultTags);\n\nexports.Schema = Schema;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\n\n/* global atob, btoa, Buffer */\nconst binary = {\n  identify: value => value instanceof Uint8Array,\n  // Buffer inherits from Uint8Array\n  default: false,\n  tag: 'tag:yaml.org,2002:binary',\n\n  /**\n   * Returns a Buffer in node and an Uint8Array in browsers\n   *\n   * To use the resulting buffer as an image, you'll want to do something like:\n   *\n   *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n   *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n   */\n  resolve: (doc, node) => {\n    const src = resolveSeq.resolveString(doc, node);\n\n    if (typeof Buffer === 'function') {\n      return Buffer.from(src, 'base64');\n    } else if (typeof atob === 'function') {\n      // On IE 11, atob() can't handle newlines\n      const str = atob(src.replace(/[\\n\\r]/g, ''));\n      const buffer = new Uint8Array(str.length);\n\n      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);\n\n      return buffer;\n    } else {\n      const msg = 'This environment does not support reading binary tags; either Buffer or atob is required';\n      doc.errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    }\n  },\n  options: resolveSeq.binaryOptions,\n  stringify: ({\n    comment,\n    type,\n    value\n  }, ctx, onComment, onChompKeep) => {\n    let src;\n\n    if (typeof Buffer === 'function') {\n      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');\n    } else if (typeof btoa === 'function') {\n      let s = '';\n\n      for (let i = 0; i < value.length; ++i) s += String.fromCharCode(value[i]);\n\n      src = btoa(s);\n    } else {\n      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n    }\n\n    if (!type) type = resolveSeq.binaryOptions.defaultType;\n\n    if (type === PlainValue.Type.QUOTE_DOUBLE) {\n      value = src;\n    } else {\n      const {\n        lineWidth\n      } = resolveSeq.binaryOptions;\n      const n = Math.ceil(src.length / lineWidth);\n      const lines = new Array(n);\n\n      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n        lines[i] = src.substr(o, lineWidth);\n      }\n\n      value = lines.join(type === PlainValue.Type.BLOCK_LITERAL ? '\\n' : ' ');\n    }\n\n    return resolveSeq.stringifyString({\n      comment,\n      type,\n      value\n    }, ctx, onComment, onChompKeep);\n  }\n};\n\nfunction parsePairs(doc, cst) {\n  const seq = resolveSeq.resolveSeq(doc, cst);\n\n  for (let i = 0; i < seq.items.length; ++i) {\n    let item = seq.items[i];\n    if (item instanceof resolveSeq.Pair) continue;else if (item instanceof resolveSeq.YAMLMap) {\n      if (item.items.length > 1) {\n        const msg = 'Each pair must have its own sequence indicator';\n        throw new PlainValue.YAMLSemanticError(cst, msg);\n      }\n\n      const pair = item.items[0] || new resolveSeq.Pair();\n      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? `${item.commentBefore}\\n${pair.commentBefore}` : item.commentBefore;\n      if (item.comment) pair.comment = pair.comment ? `${item.comment}\\n${pair.comment}` : item.comment;\n      item = pair;\n    }\n    seq.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);\n  }\n\n  return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n  const pairs = new resolveSeq.YAMLSeq(schema);\n  pairs.tag = 'tag:yaml.org,2002:pairs';\n\n  for (const it of iterable) {\n    let key, value;\n\n    if (Array.isArray(it)) {\n      if (it.length === 2) {\n        key = it[0];\n        value = it[1];\n      } else throw new TypeError(`Expected [key, value] tuple: ${it}`);\n    } else if (it && it instanceof Object) {\n      const keys = Object.keys(it);\n\n      if (keys.length === 1) {\n        key = keys[0];\n        value = it[key];\n      } else throw new TypeError(`Expected { key: value } tuple: ${it}`);\n    } else {\n      key = it;\n    }\n\n    const pair = schema.createPair(key, value, ctx);\n    pairs.items.push(pair);\n  }\n\n  return pairs;\n}\nconst pairs = {\n  default: false,\n  tag: 'tag:yaml.org,2002:pairs',\n  resolve: parsePairs,\n  createNode: createPairs\n};\n\nclass YAMLOMap extends resolveSeq.YAMLSeq {\n  constructor() {\n    super();\n\n    PlainValue._defineProperty(this, \"add\", resolveSeq.YAMLMap.prototype.add.bind(this));\n\n    PlainValue._defineProperty(this, \"delete\", resolveSeq.YAMLMap.prototype.delete.bind(this));\n\n    PlainValue._defineProperty(this, \"get\", resolveSeq.YAMLMap.prototype.get.bind(this));\n\n    PlainValue._defineProperty(this, \"has\", resolveSeq.YAMLMap.prototype.has.bind(this));\n\n    PlainValue._defineProperty(this, \"set\", resolveSeq.YAMLMap.prototype.set.bind(this));\n\n    this.tag = YAMLOMap.tag;\n  }\n\n  toJSON(_, ctx) {\n    const map = new Map();\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const pair of this.items) {\n      let key, value;\n\n      if (pair instanceof resolveSeq.Pair) {\n        key = resolveSeq.toJSON(pair.key, '', ctx);\n        value = resolveSeq.toJSON(pair.value, key, ctx);\n      } else {\n        key = resolveSeq.toJSON(pair, '', ctx);\n      }\n\n      if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');\n      map.set(key, value);\n    }\n\n    return map;\n  }\n\n}\n\nPlainValue._defineProperty(YAMLOMap, \"tag\", 'tag:yaml.org,2002:omap');\n\nfunction parseOMap(doc, cst) {\n  const pairs = parsePairs(doc, cst);\n  const seenKeys = [];\n\n  for (const {\n    key\n  } of pairs.items) {\n    if (key instanceof resolveSeq.Scalar) {\n      if (seenKeys.includes(key.value)) {\n        const msg = 'Ordered maps must not include duplicate keys';\n        throw new PlainValue.YAMLSemanticError(cst, msg);\n      } else {\n        seenKeys.push(key.value);\n      }\n    }\n  }\n\n  return Object.assign(new YAMLOMap(), pairs);\n}\n\nfunction createOMap(schema, iterable, ctx) {\n  const pairs = createPairs(schema, iterable, ctx);\n  const omap = new YAMLOMap();\n  omap.items = pairs.items;\n  return omap;\n}\n\nconst omap = {\n  identify: value => value instanceof Map,\n  nodeClass: YAMLOMap,\n  default: false,\n  tag: 'tag:yaml.org,2002:omap',\n  resolve: parseOMap,\n  createNode: createOMap\n};\n\nclass YAMLSet extends resolveSeq.YAMLMap {\n  constructor() {\n    super();\n    this.tag = YAMLSet.tag;\n  }\n\n  add(key) {\n    const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);\n    const prev = resolveSeq.findPair(this.items, pair.key);\n    if (!prev) this.items.push(pair);\n  }\n\n  get(key, keepPair) {\n    const pair = resolveSeq.findPair(this.items, key);\n    return !keepPair && pair instanceof resolveSeq.Pair ? pair.key instanceof resolveSeq.Scalar ? pair.key.value : pair.key : pair;\n  }\n\n  set(key, value) {\n    if (typeof value !== 'boolean') throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n    const prev = resolveSeq.findPair(this.items, key);\n\n    if (prev && !value) {\n      this.items.splice(this.items.indexOf(prev), 1);\n    } else if (!prev && value) {\n      this.items.push(new resolveSeq.Pair(key));\n    }\n  }\n\n  toJSON(_, ctx) {\n    return super.toJSON(_, ctx, Set);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');\n  }\n\n}\n\nPlainValue._defineProperty(YAMLSet, \"tag\", 'tag:yaml.org,2002:set');\n\nfunction parseSet(doc, cst) {\n  const map = resolveSeq.resolveMap(doc, cst);\n  if (!map.hasAllNullValues()) throw new PlainValue.YAMLSemanticError(cst, 'Set items must all have null values');\n  return Object.assign(new YAMLSet(), map);\n}\n\nfunction createSet(schema, iterable, ctx) {\n  const set = new YAMLSet();\n\n  for (const value of iterable) set.items.push(schema.createPair(value, null, ctx));\n\n  return set;\n}\n\nconst set = {\n  identify: value => value instanceof Set,\n  nodeClass: YAMLSet,\n  default: false,\n  tag: 'tag:yaml.org,2002:set',\n  resolve: parseSet,\n  createNode: createSet\n};\n\nconst parseSexagesimal = (sign, parts) => {\n  const n = parts.split(':').reduce((n, p) => n * 60 + Number(p), 0);\n  return sign === '-' ? -n : n;\n}; // hhhh:mm:ss.sss\n\n\nconst stringifySexagesimal = ({\n  value\n}) => {\n  if (isNaN(value) || !isFinite(value)) return resolveSeq.stringifyNumber(value);\n  let sign = '';\n\n  if (value < 0) {\n    sign = '-';\n    value = Math.abs(value);\n  }\n\n  const parts = [value % 60]; // seconds, including ms\n\n  if (value < 60) {\n    parts.unshift(0); // at least one : is required\n  } else {\n    value = Math.round((value - parts[0]) / 60);\n    parts.unshift(value % 60); // minutes\n\n    if (value >= 60) {\n      value = Math.round((value - parts[0]) / 60);\n      parts.unshift(value); // hours\n    }\n  }\n\n  return sign + parts.map(n => n < 10 ? '0' + String(n) : String(n)).join(':').replace(/000000\\d*$/, '') // % 60 may introduce error\n  ;\n};\n\nconst intTime = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,\n  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),\n  stringify: stringifySexagesimal\n};\nconst floatTime = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*)$/,\n  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),\n  stringify: stringifySexagesimal\n};\nconst timestamp = {\n  identify: value => value instanceof Date,\n  default: true,\n  tag: 'tag:yaml.org,2002:timestamp',\n  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n  // may be omitted altogether, resulting in a date format. In such a case, the time part is\n  // assumed to be 00:00:00Z (start of day, UTC).\n  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n  '(?:(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n  '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n  ')?' + ')$'),\n  resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {\n    if (millisec) millisec = (millisec + '00').substr(1, 3);\n    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);\n\n    if (tz && tz !== 'Z') {\n      let d = parseSexagesimal(tz[0], tz.slice(1));\n      if (Math.abs(d) < 30) d *= 60;\n      date -= 60000 * d;\n    }\n\n    return new Date(date);\n  },\n  stringify: ({\n    value\n  }) => value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, '')\n};\n\n/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */\nfunction shouldWarn(deprecation) {\n  const env = typeof process !== 'undefined' && process.env || {};\n\n  if (deprecation) {\n    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;\n    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;\n  }\n\n  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;\n  return !env.YAML_SILENCE_WARNINGS;\n}\n\nfunction warn(warning, type) {\n  if (shouldWarn(false)) {\n    const emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to\n    // https://github.com/facebook/jest/issues/2549\n\n    if (emit) emit(warning, type);else {\n      // eslint-disable-next-line no-console\n      console.warn(type ? `${type}: ${warning}` : warning);\n    }\n  }\n}\nfunction warnFileDeprecation(filename) {\n  if (shouldWarn(true)) {\n    const path = filename.replace(/.*yaml[/\\\\]/i, '').replace(/\\.js$/, '').replace(/\\\\/g, '/');\n    warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, 'DeprecationWarning');\n  }\n}\nconst warned = {};\nfunction warnOptionDeprecation(name, alternative) {\n  if (!warned[name] && shouldWarn(true)) {\n    warned[name] = true;\n    let msg = `The option '${name}' will be removed in a future release`;\n    msg += alternative ? `, use '${alternative}' instead.` : '.';\n    warn(msg, 'DeprecationWarning');\n  }\n}\n\nexports.binary = binary;\nexports.floatTime = floatTime;\nexports.intTime = intTime;\nexports.omap = omap;\nexports.pairs = pairs;\nexports.set = set;\nexports.timestamp = timestamp;\nexports.warn = warn;\nexports.warnFileDeprecation = warnFileDeprecation;\nexports.warnOptionDeprecation = warnOptionDeprecation;\n","module.exports = require(\"https\");","// The module 'vscode' contains the VS Code extensibility API\n// tslint:disable-next-line: no-implicit-dependencies\nimport * as VSC from 'vscode'\nimport Util from './util'\nimport View from './view'\nimport Fonts from './fonts'\nimport Module from './module'\nimport Translation from './translation'\n\n// this method is called when your extension is activated\nexport function activate(context: VSC.ExtensionContext) {\n    // The command has been defined in the package.json file\n    // Now provide the implementation of the command with registerCommand\n    // The commandId parameter must match the command field in package.json\n    const LEFT = 1\n    const RIGHT = 2\n    const actions: Array<[string, number]> = [\n        [\"css\", RIGHT],\n        [\"js\", LEFT],\n        [\"ts\", LEFT],\n        [\"tsx\", LEFT],\n        [\"json\", RIGHT],\n        [\"yaml\", RIGHT],\n        [\"frag\", LEFT],\n        [\"vert\", LEFT]\n    ]\n    for (const action of actions) {\n        const [extension, viewColumn] = action\n        const id = `toloframework-vscode-extension.switchTo${extension.toUpperCase()}`\n        const disposable = VSC.commands.registerCommand(\n            id,\n            () => switchTo(extension, viewColumn)\n        )\n        context.subscriptions.push(disposable)\n    }\n\n    context.subscriptions.push(\n        VSC.commands.registerCommand(\n            \"toloframework-vscode-extension.compileTranslationYAML\",\n            Translation.compileYAML\n        )\n    )\n\n    context.subscriptions.push(\n        VSC.commands.registerCommand(\n            \"toloframework-vscode-extension.importFont\",\n            Fonts.load\n        )\n    )\n\n    context.subscriptions.push(\n        VSC.commands.registerCommand(\n            \"toloframework-vscode-extension.createModule\",\n            Module.exec\n        )\n    )\n\n    context.subscriptions.push(\n        VSC.commands.registerCommand(\n            \"toloframework-vscode-extension.createView\",\n            View.exec\n        )\n    )\n\n    context.subscriptions.push(\n        VSC.commands.registerCommand(\n            'toloframework-vscode-extension.help',\n            () => {\n                const panel = VSC.window.createWebviewPanel(\n                    'help',\n                    'TFW Documentation',\n                    VSC.ViewColumn.Beside,\n                    {\n                        enableScripts: true,\n                        enableCommandUris: true\n                    }\n                )\n                panel.webview.html = `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <style>\n        html, body, iframe {\n            position: absolute;\n            left: 0;\n            top: 0;\n            bottom: 0;\n            right: 0;\n            border: none;\n            margin: 0;\n            padding: 0;\n        }\n    </style>\n</head>\n<body>\n    <iframe src=\"https://tolokoban.github.io/tfw\"></iframe>\n</body>\n</html>`\n            }\n        )\n    )\n}\n\n// this method is called when your extension is deactivated\n// tslint:disable-next-line: no-empty\nexport function deactivate() { }\n\n\nconst EXTENSION_FALLBACKS: { [key: string]: string[] } = {\n    tsx: [\"jsx\", \"ts\", \"js\"],\n    ts: [\"tsx\", \"js\", \"jsx\"],\n    js: [\"jsx\", \"ts\", \"tsx\"],\n    json: [\"jsn\", \"yaml\", \"yml\"],\n    yaml: [\"yml\", \"json\", \"jsn\"]\n}\nasync function switchTo(extension: string, viewColumn: number) {\n    const activeEditor = VSC.window.activeTextEditor\n    if (!activeEditor) {\n        VSC.window.showErrorMessage(\"No active text editor!\")\n        return\n    }\n\n    if (await openFileIfExists(extension, viewColumn, activeEditor)) return\n\n    // File does not exist.\n    // We need to create it.\n    const filename: string = Util.changeExtension(\n        activeEditor.document.fileName,\n        extension\n    )\n    Util.writeTextFile(filename, getInitialContent(extension, activeEditor.document.fileName))\n    const doc = await Util.openTextDocument(filename)\n    if (doc !== null) {\n        VSC.window.showTextDocument(doc, { viewColumn })\n    } else {\n        VSC.window.showErrorMessage(\n            `File not found:  \\n\\`${filename}\\``\n        )\n    }\n}\n\nasync function openFileIfExists(\n    extension: string,\n    viewColumn: number,\n    activeEditor: VSC.TextEditor\n) {\n    const extensions: string[] = [extension]\n    const fallbacks = EXTENSION_FALLBACKS[extension]\n    if (Array.isArray(fallbacks)) {\n        extensions.push(...fallbacks)\n    }\n\n    for (const ext of extensions) {\n        const filename: string = Util.changeExtension(\n            activeEditor.document.fileName,\n            ext\n        )\n        if (!Util.exists(filename)) continue\n\n        const doc = await Util.openTextDocument(filename)\n        if (doc === null) return false\n        VSC.window.showTextDocument(doc, { viewColumn })\n        return true\n    }\n\n    return false\n}\n\nfunction getInitialContent(extension: string, originFileName: string) {\n    switch (extension) {\n        case \"yaml\": return getInitialContentYAML(originFileName)\n    }\n    return \"\"\n}\n\nfunction getInitialContentYAML(originFileName: string) {\n    return \"en:\\n    cancel: Cancel\\n    ok: Ok\\nfr:\\n    cancel: Annuler\\n    ok: Valider\\n\"\n}\n","export { default } from \"./view\"","import * as X from 'vscode'\nimport * as FS from \"fs\"\nimport * as Path from \"path\"\nimport Util from '../util'\nimport Inputs from '../inputs'\nimport TplView from './tpl/view'\nimport TplStyle from './tpl/style'\nimport TplTester from './tpl/tester'\nimport TplContainer from './tpl/container'\n\nexport default {\n    exec\n}\n\nasync function exec() {\n    const folder = await Inputs.selectFolder(\"Root folder for your new VIEW\")\n    if (!folder) return\n    const relativeFolder = Util.makeRelativeToSource(folder)\n    const folderName = Path.basename(folder)\n    let viewName = await Inputs.promptForName(\"View's filename:\")\n    if (!viewName) return\n    const destinationFolder = Path.resolve(folder, viewName)\n    if (Util.exists(destinationFolder)) {\n        X.window.showErrorMessage(\n            `This folder already exists!\\n${destinationFolder}`,\n            { modal: true }\n        )\n        return\n    }\n    await X.workspace.fs.createDirectory(X.Uri.file(destinationFolder))\n\n    if (folderName !== 'src') {\n        const moduleSuffix = await X.window.showInputBox({\n            prompt: \"View's name suffix (press ESC if you don't want any)\",\n            value: folderName,\n            validateInput: Util.isKebabCase\n        })\n        if (moduleSuffix) {\n            viewName += `-${moduleSuffix.trim()}`\n        }\n    }\n\n    const save = writeFile.bind(null, destinationFolder)\n    save(\"index.ts\", `export { default } from './${viewName}'\\n// export { default } from './${viewName}.container'\\n`)\n    save(`${viewName}.yaml`, `en:\\n    ok: OK\\nfr:\\n    ok: Valider\\n`)\n    save(`${viewName}.tsx`, TplView(viewName, relativeFolder))\n    save(`${viewName}.css`, TplStyle(viewName, relativeFolder))\n    save(`${viewName}.test.tsx`, TplTester(viewName, relativeFolder))\n    save(`${viewName}.container.tsx`, TplContainer(viewName, relativeFolder))\n\n    const fileToOpen = Path.resolve(destinationFolder, `${viewName}.tsx`)\n    await Util.openFileInEditor(fileToOpen)\n}\n\n\nfunction writeFile(folder: string, filename: string, content: string) {\n    const path = Path.resolve(folder, filename)\n    try {\n        FS.writeFileSync(path, content)\n    } catch (ex) {\n        console.error(\"Unable to write file: \", path)\n        console.error(ex)\n        X.window.showErrorMessage(`${ex}`)\n    }\n}\n","// tslint:disable-next-line: no-implicit-dependencies\nimport * as X from 'vscode'\nimport * as Path from 'path'\nimport * as  FS from 'fs'\nimport Util from '../util'\n\n\nexport default {\n    promptForName,\n    selectFolder\n}\n\nasync function promptForName(prompt: string): Promise<string | undefined> {\n    return X.window.showInputBox({\n        prompt, validateInput: Util.isKebabCase\n    })\n}\n\nasync function selectFolder(title = \"Select a folder for the font\"): Promise<string | null> {\n    // tslint:disable-next-line: no-null-undefined-union\n    return new Promise<string | null>((resolve, reject) => {\n        const sourceFolder = Util.getSourceFolder()\n        if (!sourceFolder) {\n            reject(\"Unable to find source folder!\")\n            return null\n        }\n\n        let selectedFolder: string | null = null\n        const folders: string[] = []\n        recursiveSearchForFolders(sourceFolder, folders)\n        const items = folders.map(\n            dir => ({\n                label: `./${Path.relative(sourceFolder, dir)}`\n            }))\n        const picker = X.window.createQuickPick<X.QuickPickItem>()\n        picker.items = items\n        picker.title = title\n        picker.onDidAccept(() => {\n            resolve(selectedFolder)\n            picker.dispose()\n        })\n        picker.onDidChangeActive(\n            activeItems => {\n                selectedFolder = Path.resolve(sourceFolder, activeItems[0].label)\n            }\n        )\n        picker.show()\n    })\n}\n\n\nfunction recursiveSearchForFolders(currentFolder: string, folders: string[]) {\n    folders.push(currentFolder)\n    const dirs = FS.readdirSync(currentFolder, { withFileTypes: true })\n    for (const dir of dirs) {\n        if (dir.name === '.' || dir.name === '..') continue\n\n        if (dir.isDirectory()) {\n            recursiveSearchForFolders(\n                Path.resolve(currentFolder, dir.name),\n                folders\n            )\n        }\n    }\n}\n","import Util from '../../util'\n\nexport default function(filename: string, folder: string) {\n    const viewname = Util.kebabCaseToPascalCase(filename)\n    const className = `${\n        folder.split(\"/\").map(Util.kebabCaseToLowerPascalCase).join(\"-\")\n    }-${viewname}`\n\n    return `import * as React from \"react\"\nimport Tfw from 'tfw'\n\nimport './${filename}.css'\n\n// const _ = Tfw.Intl.make(require('./${filename}.json'))\n\nexport interface I${viewname}Props {\n    className?: string\n}\n\n// tslint:disable-next-line: no-empty-interface\ninterface I${viewname}State {}\n\nexport default class ${viewname} extends React.Component<I${viewname}Props, I${viewname}State> {\n    state: I${viewname}State = {}\n\n    render() {\n        const classNames = ['custom', '${className}']\n        if (typeof this.props.className === 'string') {\n            classNames.push(this.props.className)\n        }\n\n        return <div className={classNames.join(\" \")}>\n        </div>\n    }\n}\n`\n}","import Util from '../../util'\n\nexport default function(filename: string, folder: string) {\n    const viewname = Util.kebabCaseToPascalCase(filename)\n    const className = `${\n        folder.split(\"/\").map(Util.kebabCaseToLowerPascalCase).join(\"-\")\n    }-${viewname}`\n\n    return `.${className} {}\\n`\n}\n\n","import Util from '../../util'\n\nexport default function(filename: string, folder: string) {\n    const viewname = Util.kebabCaseToPascalCase(filename)\n\n    return `// To test a React component, you need to install few modules:\n// yarn add --dev @types/jest @testing-library/react @testing-library/jest-dom jest ts-jest\n// @see https://github.com/testing-library/react-testing-library\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport ${viewname}, { I${viewname}Props } from './${filename}'\n\nfunction view(partialProps: Partial<I${viewname}Props>): EventBag {\n    const bag = new EventBag()\n    const props: I${viewname}Props = {\n        // @TODO Set default props.\n        ...partialProps\n    }\n    render(<${viewname}\n        {...props}\n        onChange={bag.on(\"onChange\")}\n    />)\n    return bag\n}\n\ndescribe('<${viewname}/> in ${folder}', () => {\n    it('should render without crashing', () => {\n        view({})\n        // expect(screen.getByText(/Search:?/)).toBeInTheDocument()\n        // screen.debug()\n    })\n})\n\n/**\n * Use this class to keep track on events fireing.\n */\nclass EventBag {\n    private mapFiredEvents = new Map<string, Array<any[]>>()\n\n    on(eventName: string) {\n        return (...args: any[]) => {\n            const { mapFiredEvents } = this\n            if (mapFiredEvents.has(eventName)) {\n                const arr = mapFiredEvents.get(eventName)\n                app.push(args)\n            } else {\n                mapFiredEvents.set(eventName, [args])\n            }\n        }\n    }\n\n    get(eventName: string): any[] {\n        const { mapFiredEvents } = this\n        if (mapFiredEvents.has(eventName)) {\n            return mapFiredEvents.get(eventName)\n        }\n        return []\n    }\n}\n`\n}","import Util from '../../util'\n\nexport default function(filename: string, folder: string) {\n    const viewname = Util.kebabCaseToPascalCase(filename)\n    const back = folder.split(\"/\")\n        .map(x => \"..\")\n        .join(\"/\")\n\n    return `import { connect } from 'react-redux'\nimport ${viewname}, { I${viewname}Props } from './${filename}'\nimport { IAppState, IAction } from '${back}/../types'\n\nfunction mapStateToProps(\n    state: IAppState,\n    props: Partial<I${viewname}Props>\n): I${viewname}Props {\n    return { ...props }\n}\n\nfunction mapDispatchToProps(\n    dispatch: (action: IAction) => void,\n    props: Partial<I${viewname}Props>\n) {\n    // @see https://redux.js.org/basics/usage-with-react/#implementing-container-components\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${viewname})\n`\n}","export { default } from \"./fonts\"","// tslint:disable: no-implicit-dependencies\nimport * as X from 'vscode'\nimport * as FS from 'fs'\nimport * as Path from 'path'\nimport fetch from 'node-fetch'\nimport Util from '../util'\nimport Slicer from './slicer'\nimport Inputs from '../inputs'\n\nexport default {\n    load\n}\n\nasync function load() {\n    try {\n        const fontURL = await X.window.showInputBox({\n            prompt: \"Please enter the URL of the font CSS.\\nYou will find it after the @import directive.\",\n            value: \"https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap\"\n        })\n        if (!fontURL) return\n        const disposableMessage = X.window.setStatusBarMessage(`Fetching ${fontURL}`)\n        const asyncContentLoading = loadContentFromURL(fontURL)\n\n        const fontName = await X.window.showInputBox({\n            prompt: \"Please enter the font family name.\",\n            value: \"noto\",\n            validateInput: Util.isKebabCase\n        })\n        if (!fontName) return\n        const cssContent = await asyncContentLoading\n        disposableMessage.dispose()\n        if (!cssContent) return\n\n        const asyncLoadAll = loadAllFonts(cssContent)\n\n        const destination = await Inputs.selectFolder()\n        X.window.showInformationMessage(destination || \"NULL\")\n        if (!destination) return\n\n        const path = Path.resolve(destination, fontName)\n        if (FS.existsSync(path)) {\n            X.window.showErrorMessage(\n                `This directory already exists:\\n${path}`,\n                { modal: true }\n            )\n            return\n        }\n        await X.workspace.fs.createDirectory(X.Uri.file(path))\n        const files = await asyncLoadAll\n        for (const fontFile of files.fonts) {\n            if (!fontFile.data) continue\n\n            FS.writeFileSync(\n                Path.resolve(path, fontFile.filename),\n                new Uint8Array(fontFile.data)\n            )\n        }\n        const cssFilename = Path.resolve(path, `${fontName}.css`)\n        FS.writeFileSync(cssFilename, files.css)\n        await Util.openFileInEditor(cssFilename, X.ViewColumn.Active)\n\n        const fontClassFilename = Path.resolve(path, \"..\", \"font.ts\")\n        if (FS.existsSync(fontClassFilename)) {\n            FS.writeFileSync(\n                Path.resolve(path, \"index.ts\"),\n                `export { default } from './${fontName}'\\n`\n            )\n            const modFilename = Path.resolve(path, `${fontName}.ts`)\n            FS.writeFileSync(\n                modFilename,\n                `import FontClass from '../font'\nimport './${fontName}.css'\n\n// @TODO Check the font name in the CSS file: \"${fontName}.css\"\nexport default new FontClass(\"${fontName}\")\n`\n            )\n            await Util.openFileInEditor(modFilename, X.ViewColumn.Beside)\n        } else {\n            X.window.showInformationMessage(fontClassFilename)\n        }\n    } catch (ex) {\n        X.window.showErrorMessage(\n            `${ex}`,\n            { modal: true }\n        )\n    }\n}\n\nfunction getCurrentURI(): X.Uri | undefined {\n    const editor = X.window.activeTextEditor\n    if (editor) {\n        const path: string = Path.dirname(editor.document.fileName)\n        return X.Uri.file(path)\n    }\n\n    const folders = X.workspace.workspaceFolders\n    if (!folders) return undefined\n    return folders[0].uri\n}\n\nasync function loadContentFromURL(url: string): Promise<string> {\n    try {\n        const styleResponse = await fetch(url)\n        const styleContent = await styleResponse.text()\n        return styleContent\n    } catch (ex) {\n        throw `Unable to load from URL \\\"${url}\\\"!\\n\\n${ex}`\n    }\n}\n\ninterface IFont {\n    data: ArrayBuffer | null\n    filename: string\n}\n\ninterface IAllFonts {\n    css: string,\n    fonts: IFont[]\n}\n\nasync function loadAllFonts(cssContent: string): Promise<IAllFonts> {\n    const slices = Slicer.slice(cssContent)\n\n    let disposableMessage = X.window.setStatusBarMessage(`Loading font files...`)\n    for (let i = 0; i < slices.urls.length; i++) {\n        const url = slices.urls[i]\n        try {\n            disposableMessage.dispose()\n            disposableMessage = X.window.setStatusBarMessage(`Loading font ${i + 1} / ${slices.urls.length}`)\n            const response = await fetch(url)\n            if (!response.ok) {\n                throw `Error ${response.status}: ${response.statusText}`\n            }\n            const arrayBuffer = await response.arrayBuffer()\n            slices.data.push(arrayBuffer)\n        } catch (ex) {\n            slices.data.push(null)\n            X.window.showErrorMessage(\n                `Unable to load font ${i + 1} / ${slices.urls.length}:\\n${url}\\n\\n${ex}`\n            )\n        }\n    }\n    disposableMessage.dispose()\n\n    return {\n        css: slices.pieces.map((piece, index) => {\n            if (typeof piece === 'number') {\n                return `./${piece}.${getExtension(slices.urls[piece])}`\n            }\n            return piece\n        }).join(\"\"),\n        fonts: slices.data.map((data, index) => ({\n            data,\n            filename: `${index}.${getExtension(slices.urls[index])}`\n        }))\n    }\n}\n\nfunction getExtension(filename: string): string {\n    const NOT_FOUND = -1\n    const dotIndex = filename.lastIndexOf(\".\")\n    if (dotIndex === NOT_FOUND) return \"\"\n    return filename.substr(dotIndex + 1)\n}\n\n","import Stream from 'stream';\nimport http from 'http';\nimport Url from 'url';\nimport https from 'https';\nimport zlib from 'zlib';\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof Stream) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof Stream) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof Stream)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\t\tif (!res) {\n\t\t\tres = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\t\t\tif (res) {\n\t\t\t\tres.pop(); // drop last quote\n\t\t\t}\n\t\t}\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof Stream && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof Stream) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n\nconst streamDestructionSupported = 'destroy' in Stream.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parse_url(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parse_url(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parse_url(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\nconst resolve_url = Url.resolve;\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\trequest.body.destroy(error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\t\t\tfinalize();\n\t\t});\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tconst locationURL = location === null ? null : resolve_url(request.url, location);\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout,\n\t\t\t\t\t\t\tsize: request.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\nexport default fetch;\nexport { Headers, Request, Response, FetchError };\n","export default {\n    removeComments,\n    slice\n}\n\nconst NOT_FOUND = -1\n\ninterface ISlices {\n    urls: string[]\n    data: Array<ArrayBuffer | null>\n    pieces: Array<string | number>\n}\n\nfunction slice(cssContent: string): ISlices {\n    const urls: string[] = []\n    const pieces: Array<string | number> = []\n    const content = removeComments(cssContent)\n    let cursor = 0\n\n    while (true) {\n        const indexOpen = content.indexOf(\"url(\", cursor)\n        if (indexOpen === NOT_FOUND) {\n            pieces.push(content.substr(cursor))\n            break\n        }\n        pieces.push(content.substring(cursor, indexOpen + \"url(\".length))\n        const indexClose = content.indexOf(\")\", indexOpen + \"url(\".length)\n        if (indexClose === NOT_FOUND) break\n\n        pieces.push(urls.length)\n        const url = content.substring(indexOpen + \"url(\".length, indexClose)\n        urls.push(url)\n        cursor = indexClose\n    }\n\n    return { urls, pieces, data: [] }\n}\n\nfunction removeComments(content: string): string {\n    const pieces: string[] = []\n    let cursor = 0\n\n    while (true) {\n        const indexOpen = content.indexOf(\"/*\", cursor)\n        if (indexOpen === NOT_FOUND) {\n            pieces.push(content.substr(cursor))\n            break\n        }\n        pieces.push(content.substring(cursor, indexOpen))\n        const indexClose = content.indexOf(\"*/\", cursor + \"/*\".length)\n        if (indexClose === NOT_FOUND) break\n        cursor = indexClose + \"*/\".length\n    }\n\n    return pieces.join(\"\")\n}","export { default } from \"./module\"","import * as X from 'vscode'\nimport * as FS from \"fs\"\nimport * as Path from \"path\"\nimport Util from '../util'\nimport Inputs from '../inputs'\n\nexport default {\n    exec\n}\n\nasync function exec() {\n    const folder = await Inputs.selectFolder(\"Root folder for your new module\")\n    if (!folder) return\n    const folderName = Path.basename(folder)\n    let moduleName = await X.window.showInputBox({\n        prompt: \"Module's name\",\n        validateInput: Util.isKebabCase\n    })\n    if (!moduleName) return\n    const destinationFolder = Path.resolve(folder, moduleName)\n    if (Util.exists(destinationFolder)) {\n        X.window.showErrorMessage(\n            `This folder already exists!\\n${destinationFolder}`,\n            { modal: true }\n        )\n        return\n    }\n    await X.workspace.fs.createDirectory(X.Uri.file(destinationFolder))\n\n    if (folderName !== 'src') {\n        const moduleSuffix = await X.window.showInputBox({\n            prompt: \"Module's name suffix (press ESC if you don't want any)\",\n            value: folderName,\n            validateInput: Util.isKebabCase\n        })\n        if (moduleSuffix) {\n            moduleName += `-${moduleSuffix.trim()}`\n        }\n    }\n\n    const save = writeFile.bind(null, destinationFolder)\n    save(\"index.ts\", `export { default } from './${moduleName}'\\n`)\n    save(`${moduleName}.ts`, getModuleContent())\n    save(`${moduleName}.test.ts`, getTestContent(moduleName))\n\n    const fileToOpen = Path.resolve(folder, `${moduleName}.ts`)\n    await Util.openFileInEditor(fileToOpen)\n}\n\n\nfunction writeFile(folder: string, filename: string, content: string) {\n    const path = Path.resolve(folder, filename)\n    try {\n        FS.writeFileSync(path, content)\n    } catch (ex) {\n        console.error(\"Unable to write file: \", path)\n        console.error(ex)\n        X.window.showErrorMessage(`${ex}`)\n    }\n}\n\nfunction getModuleContent(): string {\n    return `export default { exec }\n\nfunction exec() {}\n`\n}\n\nfunction getTestContent(moduleName: string): string {\n    const pascalName = Util.kebabCaseToPascalCase(moduleName)\n    return `import ${pascalName} from './${moduleName}'\n\ndescribe(\"Module ${moduleName}\", () => {\n    // @TODO Write tests for module ${moduleName}\n})\n`\n}","// tslint:disable-next-line: no-implicit-dependencies\nimport * as VSC from 'vscode'\nimport * as YAML from 'yaml'\nimport { YAMLError, YAMLSemanticError } from 'yaml/util'\nimport Util from './util'\n\nexport default { compileYAML }\n\nconst DEFAULT_INDENTATION = \"    \"\nconst NOT_FOUND = -1\n\ninterface IYamlException {\n    name: string\n    source: string\n    message: string\n    makePretty(): string\n}\n\nfunction isYamlException(ex: any): ex is IYamlException {\n    if (!ex) return false\n    if (typeof ex !== 'object') return false\n    if (typeof (ex as { [key: string]: any }).makePretty !== 'function') return false\n    return true\n}\n\nasync function compileYAML() {\n    const activeEditor = VSC.window.activeTextEditor\n    if (!activeEditor) {\n        VSC.window.showErrorMessage(\"No active text editor!\")\n        return\n    }\n    const filename = activeEditor.document.fileName\n    if (!filename.endsWith(\".yaml\") && !filename.endsWith(\".yml\")) {\n        VSC.window.showErrorMessage(\"This is not a YAML file!\")\n        return\n    }\n\n    const content = activeEditor.document.getText().replace(\"\\t\", \"    \")\n    let value: any = null\n    try {\n        value = YAML.parse(\n            content, {\n            indent: 4,\n            prettyErrors: true\n        }\n        )\n    }\n    catch (ex) {\n        console.error(\"================================================================================\")\n        console.error(ex) // @TODO Remove this line written on 2020-09-18 at 12:05\n        let errorMessage = `Invalid YAML file!\\n${ex}`\n        if (ex instanceof YAMLSemanticError) {\n            errorMessage = `YAML Semantic Error at line ${ex.linePos?.start.line\n                }!\\n${ex.message\n                }\\n`\n        }\n        else if (ex instanceof YAMLError) {\n            errorMessage = `YAML Error!\\n${ex.message}\\n`\n        }\n        if (errorMessage.indexOf(\"cannot start with a tab character\") !== NOT_FOUND) {\n            errorMessage += \"\\nTry to execute the following command from the palette:\\n\"\n            errorMessage += '\"Convert indentation to spaces\"'\n        }\n        VSC.window.showErrorMessage(\n            errorMessage,\n            { modal: true }\n        )\n        return\n    }\n    const destination = Util.changeExtension(filename, \"json\")\n    Util.writeTextFile(\n        destination,\n        JSON.stringify(value, null, DEFAULT_INDENTATION)\n    )\n    await Util.openFileInEditor(destination)\n}\n","module.exports = require('./dist').YAML\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar parseCst = require('./parse-cst.js');\nrequire('./resolveSeq-4a68b39b.js');\nvar Document$1 = require('./Document-2cf6b08c.js');\nvar Schema = require('./Schema-42e9705c.js');\nvar warnings = require('./warnings-39684f17.js');\n\nfunction createNode(value, wrapScalars = true, tag) {\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  const options = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);\n  const schema = new Schema.Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nclass Document extends Document$1.Document {\n  constructor(options) {\n    super(Object.assign({}, Document$1.defaultOptions, options));\n  }\n\n}\n\nfunction parseAllDocuments(src, options) {\n  const stream = [];\n  let prev;\n\n  for (const cstDoc of parseCst.parse(src)) {\n    const doc = new Document(options);\n    doc.parse(cstDoc, prev);\n    stream.push(doc);\n    prev = doc;\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  const cst = parseCst.parse(src);\n  const doc = new Document(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    const errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  const doc = parseDocument(src, options);\n  doc.warnings.forEach(warning => warnings.warn(warning));\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify(value, options) {\n  const doc = new Document(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nconst YAML = {\n  createNode,\n  defaultOptions: Document$1.defaultOptions,\n  Document,\n  parse,\n  parseAllDocuments,\n  parseCST: parseCst.parse,\n  parseDocument,\n  scalarOptions: Document$1.scalarOptions,\n  stringify\n};\n\nexports.YAML = YAML;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nclass BlankLine extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  get includesTrailingLines() {\n    // This is never called from anywhere, but if it were,\n    // this is the value it should return.\n    return true;\n  }\n  /**\n   * Parses a blank line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first \\n character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    this.range = new PlainValue.Range(start, start + 1);\n    return start + 1;\n  }\n\n}\n\nclass CollectionItem extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.node = null;\n  }\n\n  get includesTrailingLines() {\n    return !!this.node && this.node.includesTrailingLines;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      atLineStart,\n      lineStart\n    } = context;\n    if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM) this.error = new PlainValue.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n    const indent = atLineStart ? start - lineStart : context.indent;\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    let ch = src[offset];\n    const inlineComment = ch === '#';\n    const comments = [];\n    let blankLine = null;\n\n    while (ch === '\\n' || ch === '#') {\n      if (ch === '#') {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        comments.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        atLineStart = true;\n        lineStart = offset + 1;\n        const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n        if (src[wsEnd] === '\\n' && comments.length === 0) {\n          blankLine = new BlankLine();\n          lineStart = blankLine.parse({\n            src\n          }, lineStart);\n        }\n\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n      }\n\n      ch = src[offset];\n    }\n\n    if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {\n      this.node = parseNode({\n        atLineStart,\n        inCollection: false,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n    } else if (ch && lineStart > start + 1) {\n      offset = lineStart - 1;\n    }\n\n    if (this.node) {\n      if (blankLine) {\n        // Only blank lines preceding non-empty nodes are captured. Note that\n        // this means that collection item range start indices do not always\n        // increase monotonically. -- eemeli/yaml#126\n        const items = context.parent.items || context.parent.contents;\n        if (items) items.push(blankLine);\n      }\n\n      if (comments.length) Array.prototype.push.apply(this.props, comments);\n      offset = this.node.range.end;\n    } else {\n      if (inlineComment) {\n        const c = comments[0];\n        this.props.push(c);\n        offset = c.end;\n      } else {\n        offset = PlainValue.Node.endOfLine(src, start + 1);\n      }\n    }\n\n    const end = this.node ? this.node.valueRange.end : offset;\n    this.valueRange = new PlainValue.Range(start, end);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      node,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Comment extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const offset = this.parseComment(start);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nfunction grabCollectionEndComments(node) {\n  let cnode = node;\n\n  while (cnode instanceof CollectionItem) cnode = cnode.node;\n\n  if (!(cnode instanceof Collection)) return null;\n  const len = cnode.items.length;\n  let ci = -1;\n\n  for (let i = len - 1; i >= 0; --i) {\n    const n = cnode.items[i];\n\n    if (n.type === PlainValue.Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      const {\n        indent,\n        lineStart\n      } = n.context;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === PlainValue.Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  const ca = cnode.items.splice(ci, len - ci);\n  const prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\nclass Collection extends PlainValue.Node {\n  static nextContentHasIndent(src, offset, indent) {\n    const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;\n    offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n    const ch = src[offset];\n    if (!ch) return false;\n    if (offset >= lineStart + indent) return true;\n    if (ch !== '#' && ch !== '\\n') return false;\n    return Collection.nextContentHasIndent(src, offset, indent);\n  }\n\n  constructor(firstItem) {\n    super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);\n\n    for (let i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        const itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    this.items = [firstItem];\n    const ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(this.items, ec);\n  }\n\n  get includesTrailingLines() {\n    return this.items.length > 0;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context; // It's easier to recalculate lineStart here rather than tracking down the\n    // last context from which to read it -- eemeli/yaml#2\n\n    let lineStart = PlainValue.Node.startOfLine(src, start);\n    const firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n    // -- eemeli/yaml#17\n\n    firstItem.context.parent = this;\n    this.valueRange = PlainValue.Range.copy(firstItem.valueRange);\n    const indent = firstItem.range.start - firstItem.context.lineStart;\n    let offset = start;\n    offset = PlainValue.Node.normalizeOffset(src, offset);\n    let ch = src[offset];\n    let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;\n    let prevIncludesTrailingLines = false;\n\n    while (ch) {\n      while (ch === '\\n' || ch === '#') {\n        if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n          const blankLine = new BlankLine();\n          offset = blankLine.parse({\n            src\n          }, offset);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n\n          this.items.push(blankLine);\n          offset -= 1; // blankLine.parse() consumes terminal newline\n        } else if (ch === '#') {\n          if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n            return offset;\n          }\n\n          const comment = new Comment();\n          offset = comment.parse({\n            indent,\n            lineStart,\n            src\n          }, offset);\n          this.items.push(comment);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n        }\n\n        lineStart = offset + 1;\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n        if (PlainValue.Node.atBlank(src, offset)) {\n          const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);\n          const next = src[wsEnd];\n\n          if (!next || next === '\\n' || next === '#') {\n            offset = wsEnd;\n          }\n        }\n\n        ch = src[offset];\n        atLineStart = true;\n      }\n\n      if (!ch) {\n        break;\n      }\n\n      if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n        if (offset < lineStart + indent) {\n          if (lineStart > start) offset = lineStart;\n          break;\n        } else if (!this.error) {\n          const msg = 'All collection items must start at the same column';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      if (firstItem.type === PlainValue.Type.SEQ_ITEM) {\n        if (ch !== '-') {\n          if (lineStart > start) offset = lineStart;\n          break;\n        }\n      } else if (ch === '-' && !this.error) {\n        // map key may start with -, as long as it's followed by a non-whitespace char\n        const next = src[offset + 1];\n\n        if (!next || next === '\\n' || next === '\\t' || next === ' ') {\n          const msg = 'A collection cannot be both a mapping and a sequence';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      const node = parseNode({\n        atLineStart,\n        inCollection: true,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n      if (!node) return offset; // at next document start\n\n      this.items.push(node);\n      this.valueRange.end = node.valueRange.end;\n      offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n      ch = src[offset];\n      atLineStart = false;\n      prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n      // has advanced to check the current line's indentation level\n      // -- eemeli/yaml#10 & eemeli/yaml#38\n\n      if (ch) {\n        let ls = offset - 1;\n        let prev = src[ls];\n\n        while (prev === ' ' || prev === '\\t') prev = src[--ls];\n\n        if (prev === '\\n') {\n          lineStart = ls + 1;\n          atLineStart = true;\n        }\n      }\n\n      const ec = grabCollectionEndComments(node);\n      if (ec) Array.prototype.push.apply(this.items, ec);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n    for (let i = 1; i < items.length; ++i) {\n      const item = items[i];\n      const {\n        atLineStart,\n        indent\n      } = item.context;\n      if (atLineStart) for (let i = 0; i < indent; ++i) str += ' ';\n      str += String(item);\n    }\n\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Directive extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.DIRECTIVE);\n    this.name = null;\n  }\n\n  get parameters() {\n    const raw = this.rawValue;\n    return raw ? raw.trim().split(/[ \\t]+/) : [];\n  }\n\n  parseName(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') ch = src[offset += 1];\n\n    this.name = src.slice(start, offset);\n    return offset;\n  }\n\n  parseParameters(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '#') ch = src[offset += 1];\n\n    this.valueRange = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n  parse(context, start) {\n    this.context = context;\n    let offset = this.parseName(start + 1);\n    offset = this.parseParameters(offset);\n    offset = this.parseComment(offset);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nclass Document extends PlainValue.Node {\n  static startCommentOrEndBlankLine(src, start) {\n    const offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    const ch = src[offset];\n    return ch === '#' || ch === '\\n' ? offset : start;\n  }\n\n  constructor() {\n    super(PlainValue.Type.DOCUMENT);\n    this.directives = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.documentEndMarker = null;\n  }\n\n  parseDirectives(start) {\n    const {\n      src\n    } = this.context;\n    this.directives = [];\n    let atLineStart = true;\n    let hasDirectives = false;\n    let offset = start;\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.directives.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.directives.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        case '%':\n          {\n            const directive = new Directive();\n            offset = directive.parse({\n              parent: this,\n              src\n            }, offset);\n            this.directives.push(directive);\n            hasDirectives = true;\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          if (hasDirectives) {\n            this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n          } else if (this.directives.length > 0) {\n            this.contents = this.directives;\n            this.directives = [];\n          }\n\n          return offset;\n      }\n    }\n\n    if (src[offset]) {\n      this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);\n      return offset + 3;\n    }\n\n    if (hasDirectives) {\n      this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n    } else if (this.directives.length > 0) {\n      this.contents = this.directives;\n      this.directives = [];\n    }\n\n    return offset;\n  }\n\n  parseContents(start) {\n    const {\n      parseNode,\n      src\n    } = this.context;\n    if (!this.contents) this.contents = [];\n    let lineStart = start;\n\n    while (src[lineStart - 1] === '-') lineStart -= 1;\n\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    let atLineStart = lineStart === start;\n    this.valueRange = new PlainValue.Range(offset);\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.contents.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          lineStart = offset;\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.contents.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          {\n            const iEnd = PlainValue.Node.endOfIndent(src, offset);\n            const context = {\n              atLineStart,\n              indent: -1,\n              inFlow: false,\n              inCollection: false,\n              lineStart,\n              parent: this\n            };\n            const node = parseNode(context, iEnd);\n            if (!node) return this.valueRange.end = iEnd; // at next document start\n\n            this.contents.push(node);\n            offset = node.range.end;\n            atLineStart = false;\n            const ec = grabCollectionEndComments(node);\n            if (ec) Array.prototype.push.apply(this.contents, ec);\n          }\n      }\n\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n    }\n\n    this.valueRange.end = offset;\n\n    if (src[offset]) {\n      this.documentEndMarker = new PlainValue.Range(offset, offset + 3);\n      offset += 3;\n\n      if (src[offset]) {\n        offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n\n        if (src[offset] === '#') {\n          const comment = new Comment();\n          offset = comment.parse({\n            src\n          }, offset);\n          this.contents.push(comment);\n        }\n\n        switch (src[offset]) {\n          case '\\n':\n            offset += 1;\n            break;\n\n          case undefined:\n            break;\n\n          default:\n            this.error = new PlainValue.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n        }\n      }\n    }\n\n    return offset;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    context.root = this;\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n    offset = this.parseDirectives(offset);\n    offset = this.parseContents(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.directives.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n    this.contents.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n    return offset;\n  }\n\n  toString() {\n    const {\n      contents,\n      directives,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = directives.join('');\n\n    if (contents.length > 0) {\n      if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT) str += '---\\n';\n      str += contents.join('');\n    }\n\n    if (str[str.length - 1] !== '\\n') str += '\\n';\n    return str;\n  }\n\n}\n\nclass Alias extends PlainValue.Node {\n  /**\n   * Parses an *alias from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = PlainValue.Node.endOfIdentifier(src, start + 1);\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nconst Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\nclass BlockValue extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.blockIndent = null;\n    this.chomping = Chomp.CLIP;\n    this.header = null;\n  }\n\n  get includesTrailingLines() {\n    return this.chomping === Chomp.KEEP;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (this.valueRange.isEmpty()) return '';\n    let lastNewLine = null;\n    let ch = src[end - 1];\n\n    while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n      end -= 1;\n\n      if (end <= start) {\n        if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n      }\n\n      if (ch === '\\n') lastNewLine = end;\n      ch = src[end - 1];\n    }\n\n    let keepStart = end + 1;\n\n    if (lastNewLine) {\n      if (this.chomping === Chomp.KEEP) {\n        keepStart = lastNewLine;\n        end = this.valueRange.end;\n      } else {\n        end = lastNewLine;\n      }\n    }\n\n    const bi = indent + this.blockIndent;\n    const folded = this.type === PlainValue.Type.BLOCK_FOLDED;\n    let atStart = true;\n    let str = '';\n    let sep = '';\n    let prevMoreIndented = false;\n\n    for (let i = start; i < end; ++i) {\n      for (let j = 0; j < bi; ++j) {\n        if (src[i] !== ' ') break;\n        i += 1;\n      }\n\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (sep === '\\n') str += '\\n';else sep = '\\n';\n      } else {\n        const lineEnd = PlainValue.Node.endOfLine(src, i);\n        const line = src.slice(i, lineEnd);\n        i = lineEnd;\n\n        if (folded && (ch === ' ' || ch === '\\t') && i < keepStart) {\n          if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n          str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n          sep = lineEnd < end && src[lineEnd] || '';\n          prevMoreIndented = true;\n        } else {\n          str += sep + line;\n          sep = folded && i < keepStart ? ' ' : '\\n';\n          prevMoreIndented = false;\n        }\n\n        if (atStart && line !== '') atStart = false;\n      }\n    }\n\n    return this.chomping === Chomp.STRIP ? str : str + '\\n';\n  }\n\n  parseBlockHeader(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start + 1;\n    let bi = '';\n\n    while (true) {\n      const ch = src[offset];\n\n      switch (ch) {\n        case '-':\n          this.chomping = Chomp.STRIP;\n          break;\n\n        case '+':\n          this.chomping = Chomp.KEEP;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          bi += ch;\n          break;\n\n        default:\n          this.blockIndent = Number(bi) || null;\n          this.header = new PlainValue.Range(start, offset);\n          return offset;\n      }\n\n      offset += 1;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      src\n    } = this.context;\n    const explicit = !!this.blockIndent;\n    let offset = start;\n    let valueEnd = start;\n    let minBlockIndent = 1;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      offset += 1;\n      if (PlainValue.Node.atDocumentBoundary(src, offset)) break;\n      const end = PlainValue.Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n      if (end === null) break;\n      const ch = src[end];\n      const lineIndent = end - (offset + indent);\n\n      if (!this.blockIndent) {\n        // no explicit block indent, none yet detected\n        if (src[end] !== '\\n') {\n          // first line with non-whitespace content\n          if (lineIndent < minBlockIndent) {\n            const msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n            this.error = new PlainValue.YAMLSemanticError(this, msg);\n          }\n\n          this.blockIndent = lineIndent;\n        } else if (lineIndent > minBlockIndent) {\n          // empty line with more whitespace\n          minBlockIndent = lineIndent;\n        }\n      } else if (ch && ch !== '\\n' && lineIndent < this.blockIndent) {\n        if (src[end] === '#') break;\n\n        if (!this.error) {\n          const src = explicit ? 'explicit indentation indicator' : 'first line';\n          const msg = `Block scalars must not be less indented than their ${src}`;\n          this.error = new PlainValue.YAMLSemanticError(this, msg);\n        }\n      }\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        offset = valueEnd = PlainValue.Node.endOfLine(src, end);\n      }\n    }\n\n    if (this.chomping !== Chomp.KEEP) {\n      offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n    }\n\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    return offset;\n  }\n  /**\n   * Parses a block value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * BS\n   * block\n   * lines\n   *\n   * BS #comment\n   * block\n   * lines\n   * ```\n   * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n   * are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this block\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = this.parseBlockHeader(start);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    offset = this.parseBlockValue(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.header ? this.header.setOrigRange(cr, offset) : offset;\n  }\n\n}\n\nclass FlowCollection extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.items = null;\n  }\n\n  prevNodeIsJsonLike(idx = this.items.length) {\n    const node = this.items[idx - 1];\n    return !!node && (node.jsonLike || node.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      indent,\n      lineStart\n    } = context;\n    let char = src[start]; // { or [\n\n    this.items = [{\n      char,\n      offset: start\n    }];\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    char = src[offset];\n\n    while (char && char !== ']' && char !== '}') {\n      switch (char) {\n        case '\\n':\n          {\n            lineStart = offset + 1;\n            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n            if (src[wsEnd] === '\\n') {\n              const blankLine = new BlankLine();\n              lineStart = blankLine.parse({\n                src\n              }, lineStart);\n              this.items.push(blankLine);\n            }\n\n            offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n            if (offset <= lineStart + indent) {\n              char = src[offset];\n\n              if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                const msg = 'Insufficient indentation in flow collection';\n                this.error = new PlainValue.YAMLSemanticError(this, msg);\n              }\n            }\n          }\n          break;\n\n        case ',':\n          {\n            this.items.push({\n              char,\n              offset\n            });\n            offset += 1;\n          }\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.items.push(comment);\n          }\n          break;\n\n        case '?':\n        case ':':\n          {\n            const next = src[offset + 1];\n\n            if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n            char === ':' && this.prevNodeIsJsonLike()) {\n              this.items.push({\n                char,\n                offset\n              });\n              offset += 1;\n              break;\n            }\n          }\n        // fallthrough\n\n        default:\n          {\n            const node = parseNode({\n              atLineStart: false,\n              inCollection: false,\n              inFlow: true,\n              indent: -1,\n              lineStart,\n              parent: this\n            }, offset);\n\n            if (!node) {\n              // at next document start\n              this.valueRange = new PlainValue.Range(start, offset);\n              return offset;\n            }\n\n            this.items.push(node);\n            offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n          }\n      }\n\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n      char = src[offset];\n    }\n\n    this.valueRange = new PlainValue.Range(start, offset + 1);\n\n    if (char) {\n      this.items.push({\n        char,\n        offset\n      });\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);\n      offset = this.parseComment(offset);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      if (node instanceof PlainValue.Node) {\n        offset = node.setOrigRanges(cr, offset);\n      } else if (cr.length === 0) {\n        node.origOffset = node.offset;\n      } else {\n        let i = offset;\n\n        while (i < cr.length) {\n          if (cr[i] > node.offset) break;else ++i;\n        }\n\n        node.origOffset = node.offset + i;\n        offset = i;\n      }\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const nodes = items.filter(item => item instanceof PlainValue.Node);\n    let str = '';\n    let prevEnd = range.start;\n    nodes.forEach(node => {\n      const prefix = src.slice(prevEnd, node.range.start);\n      prevEnd = node.range.end;\n      str += prefix + String(node);\n\n      if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n        // Comment range does not include the terminal newline, but its\n        // stringified value does. Without this fix, newlines at comment ends\n        // get duplicated.\n        prevEnd += 1;\n      }\n    });\n    str += src.slice(prevEnd, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass QuoteDouble extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\"') {\n      offset += ch === '\\\\' ? 2 : 1;\n      ch = src[offset];\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== '\"') errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n    // escaped backslashes; also, this should be faster.\n\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n      } else if (ch === '\\\\') {\n        i += 1;\n\n        switch (src[i]) {\n          case '0':\n            str += '\\0';\n            break;\n          // null character\n\n          case 'a':\n            str += '\\x07';\n            break;\n          // bell character\n\n          case 'b':\n            str += '\\b';\n            break;\n          // backspace\n\n          case 'e':\n            str += '\\x1b';\n            break;\n          // escape character\n\n          case 'f':\n            str += '\\f';\n            break;\n          // form feed\n\n          case 'n':\n            str += '\\n';\n            break;\n          // line feed\n\n          case 'r':\n            str += '\\r';\n            break;\n          // carriage return\n\n          case 't':\n            str += '\\t';\n            break;\n          // horizontal tab\n\n          case 'v':\n            str += '\\v';\n            break;\n          // vertical tab\n\n          case 'N':\n            str += '\\u0085';\n            break;\n          // Unicode next line\n\n          case '_':\n            str += '\\u00a0';\n            break;\n          // Unicode non-breaking space\n\n          case 'L':\n            str += '\\u2028';\n            break;\n          // Unicode line separator\n\n          case 'P':\n            str += '\\u2029';\n            break;\n          // Unicode paragraph separator\n\n          case ' ':\n            str += ' ';\n            break;\n\n          case '\"':\n            str += '\"';\n            break;\n\n          case '/':\n            str += '/';\n            break;\n\n          case '\\\\':\n            str += '\\\\';\n            break;\n\n          case '\\t':\n            str += '\\t';\n            break;\n\n          case 'x':\n            str += this.parseCharCode(i + 1, 2, errors);\n            i += 2;\n            break;\n\n          case 'u':\n            str += this.parseCharCode(i + 1, 4, errors);\n            i += 4;\n            break;\n\n          case 'U':\n            str += this.parseCharCode(i + 1, 8, errors);\n            i += 8;\n            break;\n\n          case '\\n':\n            // skip escaped newlines, but still trim the following line\n            while (src[i + 1] === ' ' || src[i + 1] === '\\t') i += 1;\n\n            break;\n\n          default:\n            errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));\n            str += '\\\\' + src[i];\n        }\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n\n  parseCharCode(offset, length, errors) {\n    const {\n      src\n    } = this.context;\n    const cc = src.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n\n    if (isNaN(code)) {\n      errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));\n      return src.substr(offset - 2, length + 2);\n    }\n\n    return String.fromCodePoint(code);\n  }\n  /**\n   * Parses a \"double quoted\" value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteDouble.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nclass QuoteSingle extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch) {\n      if (ch === \"'\") {\n        if (src[offset + 1] !== \"'\") break;\n        ch = src[offset += 2];\n      } else {\n        ch = src[offset += 1];\n      }\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, \"Missing closing 'quote\"));\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n      } else if (ch === \"'\") {\n        str += ch;\n        i += 1;\n        if (src[i] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n  /**\n   * Parses a 'single quoted' value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteSingle.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case PlainValue.Type.ALIAS:\n      return new Alias(type, props);\n\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case PlainValue.Type.MAP_KEY:\n    case PlainValue.Type.MAP_VALUE:\n    case PlainValue.Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case PlainValue.Type.COMMENT:\n    case PlainValue.Type.PLAIN:\n      return new PlainValue.PlainValue(type, props);\n\n    case PlainValue.Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case PlainValue.Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nclass ParseContext {\n  static parseType(src, offset, inFlow) {\n    switch (src[offset]) {\n      case '*':\n        return PlainValue.Type.ALIAS;\n\n      case '>':\n        return PlainValue.Type.BLOCK_FOLDED;\n\n      case '|':\n        return PlainValue.Type.BLOCK_LITERAL;\n\n      case '{':\n        return PlainValue.Type.FLOW_MAP;\n\n      case '[':\n        return PlainValue.Type.FLOW_SEQ;\n\n      case '?':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;\n\n      case ':':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;\n\n      case '-':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;\n\n      case '\"':\n        return PlainValue.Type.QUOTE_DOUBLE;\n\n      case \"'\":\n        return PlainValue.Type.QUOTE_SINGLE;\n\n      default:\n        return PlainValue.Type.PLAIN;\n    }\n  }\n\n  constructor(orig = {}, {\n    atLineStart,\n    inCollection,\n    inFlow,\n    indent,\n    lineStart,\n    parent\n  } = {}) {\n    PlainValue._defineProperty(this, \"parseNode\", (overlay, start) => {\n      if (PlainValue.Node.atDocumentBoundary(this.src, start)) return null;\n      const context = new ParseContext(this, overlay);\n      const {\n        props,\n        type,\n        valueStart\n      } = context.parseProps(start);\n      const node = createNewNode(type, props);\n      let offset = node.parse(context, valueStart);\n      node.range = new PlainValue.Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(`Node#parse consumed no characters`);\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {\n          node.error = new PlainValue.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        const collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new PlainValue.Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  nodeStartsCollection(node) {\n    const {\n      inCollection,\n      inFlow,\n      src\n    } = this;\n    if (inCollection || inFlow) return false;\n    if (node instanceof CollectionItem) return true; // check for implicit key\n\n    let offset = node.range.end;\n    if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    return src[offset] === ':';\n  } // Anchor and tag are before type, which determines the node implementation\n  // class; hence this intermediate step.\n\n\n  parseProps(offset) {\n    const {\n      inFlow,\n      parent,\n      src\n    } = this;\n    const props = [];\n    let lineHasProps = false;\n    offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);\n    let ch = src[offset];\n\n    while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === '\\n') {\n      if (ch === '\\n') {\n        const lineStart = offset + 1;\n        const inEnd = PlainValue.Node.endOfIndent(src, lineStart);\n        const indentDiff = inEnd - (lineStart + this.indent);\n        const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;\n        if (!PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n        this.atLineStart = true;\n        this.lineStart = lineStart;\n        lineHasProps = false;\n        offset = inEnd;\n      } else if (ch === PlainValue.Char.COMMENT) {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        props.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        let end = PlainValue.Node.endOfIdentifier(src, offset + 1);\n\n        if (ch === PlainValue.Char.TAG && src[end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, end + 13))) {\n          // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n          // than an empty but 'foo.bar' private-tagged node in a flow collection\n          // followed without whitespace by a plain string starting with a year\n          // or date divided by something.\n          end = PlainValue.Node.endOfIdentifier(src, end + 5);\n        }\n\n        props.push(new PlainValue.Range(offset, end));\n        lineHasProps = true;\n        offset = PlainValue.Node.endOfWhiteSpace(src, end);\n      }\n\n      ch = src[offset];\n    } // '- &a : b' has an anchor on an empty node\n\n\n    if (lineHasProps && ch === ':' && PlainValue.Node.atBlank(src, offset + 1, true)) offset -= 1;\n    const type = ParseContext.parseType(src, offset, inFlow);\n    return {\n      props,\n      type,\n      valueStart: offset\n    };\n  }\n  /**\n   * Parses a node from the source\n   * @param {ParseContext} overlay\n   * @param {number} start - Index of first non-whitespace character for the node\n   * @returns {?Node} - null if at a document boundary\n   */\n\n\n}\n\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n  const cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, (match, offset) => {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  const documents = [];\n  let offset = 0;\n\n  do {\n    const doc = new Document();\n    const context = new ParseContext({\n      src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = () => {\n    if (cr.length === 0) return false;\n\n    for (let i = 1; i < cr.length; ++i) cr[i] -= i;\n\n    let crOffset = 0;\n\n    for (let i = 0; i < documents.length; ++i) {\n      crOffset = documents[i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = () => documents.join('...\\n');\n\n  return documents;\n}\n\nexports.parse = parse;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\nvar Schema = require('./Schema-42e9705c.js');\n\nconst defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nconst scalarOptions = {\n  get binary() {\n    return resolveSeq.binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(resolveSeq.binaryOptions, opt);\n  },\n\n  get bool() {\n    return resolveSeq.boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(resolveSeq.boolOptions, opt);\n  },\n\n  get int() {\n    return resolveSeq.intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(resolveSeq.intOptions, opt);\n  },\n\n  get null() {\n    return resolveSeq.nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(resolveSeq.nullOptions, opt);\n  },\n\n  get str() {\n    return resolveSeq.strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(resolveSeq.strOptions, opt);\n  }\n\n};\nconst documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: PlainValue.defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  '1.1': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  },\n  '1.2': {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    const priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`;\n  }\n\n  let p = doc.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);\n\n  if (!p) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);\n  }\n\n  if (!p) return tag[0] === '!' ? tag : `!<${tag}>`;\n  const suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, ch => ({\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n  })[ch]);\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;\n\n  if (item.tag) {\n    const match = tags.filter(t => t.tag === item.tag);\n    if (match.length > 0) return match.find(t => t.format === item.format) || match[0];\n  }\n\n  let tagObj, obj;\n\n  if (item instanceof resolveSeq.Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    const match = tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);\n    tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);\n  } else {\n    obj = item;\n    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n  }\n\n  if (!tagObj) {\n    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;\n    throw new Error(`Tag not resolved for ${name} value`);\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, {\n  anchors,\n  doc\n}) {\n  const props = [];\n  const anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(`&${anchor}`);\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify(item, ctx, onComment, onChompKeep) {\n  const {\n    anchors,\n    schema\n  } = ctx.doc;\n  let tagObj;\n\n  if (!(item instanceof resolveSeq.Node)) {\n    const createCtx = {\n      aliasNodes: [],\n      onTagObj: o => tagObj = o,\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    for (const alias of createCtx.aliasNodes) {\n      alias.source = alias.source.node;\n      let name = anchors.getName(alias.source);\n\n      if (!name) {\n        name = anchors.newName();\n        anchors.map[name] = alias.source;\n      }\n    }\n  }\n\n  if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  const props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof resolveSeq.Scalar || str[0] === '{' || str[0] === '[' ? `${props} ${str}` : `${props}\\n${ctx.indent}${str}`;\n}\n\nclass Anchors {\n  static validAnchorNode(node) {\n    return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;\n  }\n\n  constructor(prefix) {\n    PlainValue._defineProperty(this, \"map\", {});\n\n    this.prefix = prefix;\n  }\n\n  createAlias(node, name) {\n    this.setAnchor(node, name);\n    return new resolveSeq.Alias(node);\n  }\n\n  createMergePair(...sources) {\n    const merge = new resolveSeq.Merge();\n    merge.value.items = sources.map(s => {\n      if (s instanceof resolveSeq.Alias) {\n        if (s.source instanceof resolveSeq.YAMLMap) return s;\n      } else if (s instanceof resolveSeq.YAMLMap) {\n        return this.createAlias(s);\n      }\n\n      throw new Error('Merge sources must be Map nodes or their Aliases');\n    });\n    return merge;\n  }\n\n  getName(node) {\n    const {\n      map\n    } = this;\n    return Object.keys(map).find(a => map[a] === node);\n  }\n\n  getNames() {\n    return Object.keys(this.map);\n  }\n\n  getNode(name) {\n    return this.map[name];\n  }\n\n  newName(prefix) {\n    if (!prefix) prefix = this.prefix;\n    const names = Object.keys(this.map);\n\n    for (let i = 1; true; ++i) {\n      const name = `${prefix}${i}`;\n      if (!names.includes(name)) return name;\n    }\n  } // During parsing, map & aliases contain CST nodes\n\n\n  resolveNodes() {\n    const {\n      map,\n      _cstAliases\n    } = this;\n    Object.keys(map).forEach(a => {\n      map[a] = map[a].resolved;\n    });\n\n    _cstAliases.forEach(a => {\n      a.source = a.source.resolved;\n    });\n\n    delete this._cstAliases;\n  }\n\n  setAnchor(node, name) {\n    if (node != null && !Anchors.validAnchorNode(node)) {\n      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n    }\n\n    if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n      throw new Error('Anchor names must not contain whitespace or control characters');\n    }\n\n    const {\n      map\n    } = this;\n    const prev = node && Object.keys(map).find(a => map[a] === node);\n\n    if (prev) {\n      if (!name) {\n        return prev;\n      } else if (prev !== name) {\n        delete map[prev];\n        map[name] = node;\n      }\n    } else {\n      if (!name) {\n        if (!node) return null;\n        name = this.newName();\n      }\n\n      map[name] = node;\n    }\n\n    return name;\n  }\n\n}\n\nconst visit = (node, tags) => {\n  if (node && typeof node === 'object') {\n    const {\n      tag\n    } = node;\n\n    if (node instanceof resolveSeq.Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(n => visit(n, tags));\n    } else if (node instanceof resolveSeq.Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof resolveSeq.Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nconst listTagNames = node => Object.keys(visit(node, {}));\n\nfunction parseContents(doc, contents) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let body = undefined;\n  let spaceBefore = false;\n\n  for (const node of contents) {\n    if (node.valueRange) {\n      if (body !== undefined) {\n        const msg = 'Document contains trailing content not separated by a ... or --- line';\n        doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n        break;\n      }\n\n      const res = resolveSeq.resolveNode(doc, node);\n\n      if (spaceBefore) {\n        res.spaceBefore = true;\n        spaceBefore = false;\n      }\n\n      body = res;\n    } else if (node.comment !== null) {\n      const cc = body === undefined ? comments.before : comments.after;\n      cc.push(node.comment);\n    } else if (node.type === PlainValue.Type.BLANK_LINE) {\n      spaceBefore = true;\n\n      if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n        // space-separated comments at start are parsed as document comments\n        doc.commentBefore = comments.before.join('\\n');\n        comments.before = [];\n      }\n    }\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? `${cb}\\n${cbNode.commentBefore}` : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective({\n  tagPrefixes\n}, directive) {\n  const [handle, prefix] = directive.parameters;\n\n  if (!handle || !prefix) {\n    const msg = 'Insufficient parameters given for %TAG directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(p => p.handle === handle)) {\n    const msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  return {\n    handle,\n    prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  let [version] = directive.parameters;\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    const msg = 'Insufficient parameters given for %YAML directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    const v0 = doc.version || doc.options.version;\n    const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  const directiveComments = [];\n  let hasDirectives = false;\n\n  for (const directive of directives) {\n    const {\n      comment,\n      name\n    } = directive;\n\n    switch (name) {\n      case 'TAG':\n        try {\n          doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      case 'YAML':\n      case 'YAML:1.0':\n        if (doc.version) {\n          const msg = 'The %YAML directive must only be given at most once per document.';\n          doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));\n        }\n\n        try {\n          doc.version = resolveYamlDirective(doc, directive);\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      default:\n        if (name) {\n          const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;\n          doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n        }\n\n    }\n\n    if (comment) directiveComments.push(comment);\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    const copyTagPrefix = ({\n      handle,\n      prefix\n    }) => ({\n      handle,\n      prefix\n    });\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof resolveSeq.Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nclass Document {\n  constructor(options) {\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  add(value) {\n    assertCollection(this.contents);\n    return this.contents.add(value);\n  }\n\n  addIn(path, value) {\n    assertCollection(this.contents);\n    this.contents.addIn(path, value);\n  }\n\n  delete(key) {\n    assertCollection(this.contents);\n    return this.contents.delete(key);\n  }\n\n  deleteIn(path) {\n    if (resolveSeq.isEmptyPath(path)) {\n      if (this.contents == null) return false;\n      this.contents = null;\n      return true;\n    }\n\n    assertCollection(this.contents);\n    return this.contents.deleteIn(path);\n  }\n\n  getDefaults() {\n    return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n  }\n\n  get(key, keepScalar) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : undefined;\n  }\n\n  getIn(path, keepScalar) {\n    if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : undefined;\n  }\n\n  has(key) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;\n  }\n\n  hasIn(path) {\n    if (resolveSeq.isEmptyPath(path)) return this.contents !== undefined;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;\n  }\n\n  set(key, value) {\n    assertCollection(this.contents);\n    this.contents.set(key, value);\n  }\n\n  setIn(path, value) {\n    if (resolveSeq.isEmptyPath(path)) this.contents = value;else {\n      assertCollection(this.contents);\n      this.contents.setIn(path, value);\n    }\n  }\n\n  setSchema(id, customTags) {\n    if (!id && !customTags && this.schema) return;\n    if (typeof id === 'number') id = id.toFixed(1);\n\n    if (id === '1.0' || id === '1.1' || id === '1.2') {\n      if (this.version) this.version = id;else this.options.version = id;\n      delete this.options.schema;\n    } else if (id && typeof id === 'string') {\n      this.options.schema = id;\n    }\n\n    if (Array.isArray(customTags)) this.options.customTags = customTags;\n    const opt = Object.assign({}, this.getDefaults(), this.options);\n    this.schema = new Schema.Schema(opt);\n  }\n\n  parse(node, prevDoc) {\n    if (this.options.keepCstNodes) this.cstNode = node;\n    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n    const {\n      directives = [],\n      contents = [],\n      directivesEndMarker,\n      error,\n      valueRange\n    } = node;\n\n    if (error) {\n      if (!error.source) error.source = this;\n      this.errors.push(error);\n    }\n\n    parseDirectives(this, directives, prevDoc);\n    if (directivesEndMarker) this.directivesEndMarker = true;\n    this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n    this.setSchema();\n    this.anchors._cstAliases = [];\n    parseContents(this, contents);\n    this.anchors.resolveNodes();\n\n    if (this.options.prettyErrors) {\n      for (const error of this.errors) if (error instanceof PlainValue.YAMLError) error.makePretty();\n\n      for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();\n    }\n\n    return this;\n  }\n\n  listNonDefaultTags() {\n    return listTagNames(this.contents).filter(t => t.indexOf(Schema.Schema.defaultPrefix) !== 0);\n  }\n\n  setTagPrefix(handle, prefix) {\n    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n    if (prefix) {\n      const prev = this.tagPrefixes.find(p => p.handle === handle);\n      if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n        handle,\n        prefix\n      });\n    } else {\n      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);\n    }\n  }\n\n  toJSON(arg, onAnchor) {\n    const {\n      keepBlobsInJSON,\n      mapAsMap,\n      maxAliasCount\n    } = this.options;\n    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof resolveSeq.Scalar));\n    const ctx = {\n      doc: this,\n      indentStep: '  ',\n      keep,\n      mapAsMap: keep && !!mapAsMap,\n      maxAliasCount,\n      stringify // Requiring directly in Pair would create circular dependencies\n\n    };\n    const anchorNames = Object.keys(this.anchors.map);\n    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], {\n      alias: [],\n      aliasCount: 0,\n      count: 1\n    }]));\n    const res = resolveSeq.toJSON(this.contents, arg, ctx);\n    if (typeof onAnchor === 'function' && ctx.anchors) for (const {\n      count,\n      res\n    } of ctx.anchors.values()) onAnchor(res, count);\n    return res;\n  }\n\n  toString() {\n    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n    const indentSize = this.options.indent;\n\n    if (!Number.isInteger(indentSize) || indentSize <= 0) {\n      const s = JSON.stringify(indentSize);\n      throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n    }\n\n    this.setSchema();\n    const lines = [];\n    let hasDirectives = false;\n\n    if (this.version) {\n      let vd = '%YAML 1.2';\n\n      if (this.schema.name === 'yaml-1.1') {\n        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n      }\n\n      lines.push(vd);\n      hasDirectives = true;\n    }\n\n    const tagNames = this.listNonDefaultTags();\n    this.tagPrefixes.forEach(({\n      handle,\n      prefix\n    }) => {\n      if (tagNames.some(t => t.indexOf(prefix) === 0)) {\n        lines.push(`%TAG ${handle} ${prefix}`);\n        hasDirectives = true;\n      }\n    });\n    if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n    if (this.commentBefore) {\n      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n      lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n    }\n\n    const ctx = {\n      anchors: {},\n      doc: this,\n      indent: '',\n      indentStep: ' '.repeat(indentSize),\n      stringify // Requiring directly in nodes would create circular dependencies\n\n    };\n    let chompKeep = false;\n    let contentComment = null;\n\n    if (this.contents) {\n      if (this.contents instanceof resolveSeq.Node) {\n        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n        ctx.forceBlockIndent = !!this.comment;\n        contentComment = this.contents.comment;\n      }\n\n      const onChompKeep = contentComment ? null : () => chompKeep = true;\n      const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);\n      lines.push(resolveSeq.addComment(body, '', contentComment));\n    } else if (this.contents !== undefined) {\n      lines.push(stringify(this.contents, ctx));\n    }\n\n    if (this.comment) {\n      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n      lines.push(this.comment.replace(/^/gm, '#'));\n    }\n\n    return lines.join('\\n') + '\\n';\n  }\n\n}\n\nPlainValue._defineProperty(Document, \"defaults\", documentOptions);\n\nexports.Document = Document;\nexports.defaultOptions = defaultOptions;\nexports.scalarOptions = scalarOptions;\n","const util = require('./dist/util')\n\nexports.findPair = util.findPair\nexports.toJSON = util.toJSON\nexports.parseMap = util.parseMap\nexports.parseSeq = util.parseSeq\n\nexports.stringifyNumber = util.stringifyNumber\nexports.stringifyString = util.stringifyString\nexports.Type = util.Type\n\nexports.YAMLError = util.YAMLError\nexports.YAMLReferenceError = util.YAMLReferenceError\nexports.YAMLSemanticError = util.YAMLSemanticError\nexports.YAMLSyntaxError = util.YAMLSyntaxError\nexports.YAMLWarning = util.YAMLWarning\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\n\n\n\nexports.Type = PlainValue.Type;\nexports.YAMLError = PlainValue.YAMLError;\nexports.YAMLReferenceError = PlainValue.YAMLReferenceError;\nexports.YAMLSemanticError = PlainValue.YAMLSemanticError;\nexports.YAMLSyntaxError = PlainValue.YAMLSyntaxError;\nexports.YAMLWarning = PlainValue.YAMLWarning;\nexports.findPair = resolveSeq.findPair;\nexports.parseMap = resolveSeq.resolveMap;\nexports.parseSeq = resolveSeq.resolveSeq;\nexports.stringifyNumber = resolveSeq.stringifyNumber;\nexports.stringifyString = resolveSeq.stringifyString;\nexports.toJSON = resolveSeq.toJSON;\n"],"sourceRoot":""}