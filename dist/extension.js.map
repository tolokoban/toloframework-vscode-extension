{"version":3,"sources":["../webpack/bootstrap","../external \"stream\"","../external \"zlib\"",".././node_modules/yaml/dist/PlainValue-ec8e588e.js",".././node_modules/yaml/dist/resolveSeq-4a68b39b.js","../external \"vscode\"","../external \"url\"",".././src/util.ts","../external \"http\"","../external \"fs\"",".././node_modules/yaml/dist/Schema-42e9705c.js",".././node_modules/yaml/dist/warnings-39684f17.js","../external \"https\"",".././src/extension.ts",".././src/fonts/index.ts",".././src/fonts/fonts.ts","../external \"path\"",".././node_modules/node-fetch/lib/index.mjs",".././src/fonts/slicer.ts",".././src/translation.ts",".././node_modules/yaml/index.js",".././node_modules/yaml/dist/index.js",".././node_modules/yaml/dist/parse-cst.js",".././node_modules/yaml/dist/Document-2cf6b08c.js",".././node_modules/yaml/util.js",".././node_modules/yaml/dist/util.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","Char","ANCHOR","COMMENT","TAG","DIRECTIVES_END","DOCUMENT_END","Type","ALIAS","BLANK_LINE","BLOCK_FOLDED","BLOCK_LITERAL","DIRECTIVE","DOCUMENT","FLOW_MAP","FLOW_SEQ","MAP","MAP_KEY","MAP_VALUE","PLAIN","QUOTE_DOUBLE","QUOTE_SINGLE","SEQ","SEQ_ITEM","findLineStarts","src","ls","offset","indexOf","push","getSrcInfo","cst","lineStarts","Array","isArray","context","getLinePos","length","start","line","col","getPrettyContext","end","maxWidth","slice","getLine","substr","halfWidth","Math","round","errLen","errEnd","min","repeat","Range","orig","this","cr","origStart","origEnd","nextOffset","Node","str","next","endOfWhiteSpace","sep","ch0","prev","ch1","ch2","ch3","ch","isVerbatim","notOk","indent","lineStart","inEnd","endOfIndent","wsEnd","endAsBlank","indentDiff","indicatorAsIndent","inCount","error","fold","type","props","writable","range","valueRange","idx","skipKey","prop","anchor","getPropValue","comments","comment","join","header","atBlank","root","tag","verbatim","_","handle","suffix","match","endOfLine","commentRange","setOrigRange","forEach","addStringTerminator","YAMLError","Error","source","message","super","nodeType","linePos","rangeAsLinePos","ctx","YAMLSemanticError","PlainValue","inFlow","foldNewline","wsStart","errors","valueEnd","atDocumentBoundary","endOfBlockIndent","isEmpty","parseComment","hasComment","parseBlockValue","YAMLReferenceError","YAMLSyntaxError","YAMLWarning","_defineProperty","obj","configurable","defaultTagPrefix","defaultTags","STR","addComment","replace","toJSON","arg","map","v","String","anchors","onCreate","res","keep","Number","Scalar","collectionFromPath","schema","path","k","isInteger","createNode","isEmptyPath","iterator","done","Collection","add","rest","node","addIn","undefined","set","delete","deleteIn","keepScalar","getIn","items","every","commentBefore","has","hasIn","setIn","blockItem","flowChars","isMap","itemIndent","onComment","onChompKeep","indentStep","stringify","allNullValues","hasAllNullValues","assign","chompKeep","hasItemWithNewLine","nodes","reduce","item","spaceBefore","includes","strings","sum","maxFlowStringSingleLineLength","shift","asItemIndex","YAMLSeq","splice","it","seq","toString","JSON","Pair","PAIR","cb","Map","Set","stringKey","jsKey","doc","inStringifyKey","stringifyKey","pair","mapAsMap","addToJSMap","indentSize","indentSeq","simpleKeys","options","keyComment","explicitKey","implicitKey","vcb","valueComment","indentAtStart","getName","valueStr","ws","MERGE_PAIR","getAliasCount","Alias","count","aliasCount","kc","vc","max","keys","find","a","newName","msg","maxAliasCount","cstNode","ReferenceError","findPair","YAMLMap","overwrite","sortEntries","sortMapEntries","findIndex","Merge","srcMap","binaryOptions","defaultType","lineWidth","strOptions","doubleQuoted","jsonEncoding","minMultiLineLength","minContentWidth","resolveScalar","tags","scalarFallback","format","test","resolve","apply","consumeMoreIndentedLines","text","foldFlowLines","onFold","onOverflow","endStep","folds","escapedFolds","split","overflow","getFoldOptions","containsDocumentMarker","doubleQuotedString","json","code","singleQuotedString","blockString","forceBlockIndent","literal","limit","strLen","lineLengthOverLimit","body","checkFlowCollectionEnd","char","lastItem","err","checkFlowCommentSpace","getLongKeyError","sk","resolveComments","collection","afterKey","before","resolveString","strValue","resolveTagName","nonSpecific","prefix","tagPrefixes","dtp","getDefaults","version","warnings","vocab","decodeURIComponent","resolveTagHandle","resolveByTagName","tagName","matchWithTest","resolveTag","fallback","getFallbackTagName","refError","stack","resolveNodeProps","after","hasAnchor","hasTag","isCollectionItem","parent","concat","commentHasRequiredWhitespace","resolveNode","getNode","rawValue","_cstAliases","resolveNodeValue","keepCstNodes","keepNodeTypes","ca","resolved","resolvePairComment","valueHasPairComment","found","startsWith","cc","boolOptions","trueStr","falseStr","intOptions","asBigInt","nullOptions","nullStr","resolveMap","resolveFlowMapItems","keyStart","atLineStart","valueNode","pos","origPos","j","nextItem","valueRangeContainsNewline","resolveBlockMapItems","hasCollectionKey","iKey","merge","sources","some","jKey","warn","resolveSeq","prevItem","pop","keyEnd","resolveFlowSeqItems","hasProps","resolveBlockSeqItems","stringifyNumber","minFractionDigits","isFinite","isNaN","stringifyString","_stringify","_type","actualString","addCommentBefore","plainString","IViewColumn","exists","FS","existsSync","openTextDocument","filename","Promise","reject","VSC","workspace","then","removeExtension","idxDot","lastIndexOf","changeExtension","newExtension","getBasename","idxSlash","substring","getDirectory","openFileInEditor","viewColumn","ViewColumn","Active","window","showTextDocument","valueOf","writeTextFile","content","writeFileSync","createPair","sort","default","nodeClass","wrapScalars","string","identify","failsafe","intIdentify","intResolve","part","radix","BigInt","parseInt","intStringify","nullObj","boolObj","octObj","oct","intObj","hexObj","hex","nanObj","nan","NaN","NEGATIVE_INFINITY","POSITIVE_INFINITY","expObj","parseFloat","toExponential","floatObj","frac1","frac2","frac","core","intIdentify$1","stringifyJSON","SyntaxError","boolStringify","intIdentify$2","intResolve$1","sign","intStringify$1","yaml11","bin","abs","f","binary","omap","pairs","intTime","floatTime","timestamp","schemas","bool","float","floatExp","floatNaN","int","intHex","intOct","null","defaultPrefix","onTagObj","prevObjects","tagObj","filter","class","findTagObject","alias","aliasNodes","sortMapEntriesByKey","b","Schema","customTags","deprecatedCustomTags","warnOptionDeprecation","knownTags","schemaId","getSchemaTags","baseCtx","Uint8Array","Buffer","from","atob","buffer","charCodeAt","btoa","fromCharCode","ceil","lines","parsePairs","createPairs","iterable","TypeError","YAMLOMap","seenKeys","YAMLSet","keepPair","parseSexagesimal","parts","stringifySexagesimal","unshift","Date","RegExp","year","month","day","hour","minute","second","millisec","tz","date","UTC","toISOString","shouldWarn","deprecation","env","process","YAML_SILENCE_DEPRECATION_WARNINGS","YAML_SILENCE_WARNINGS","warning","emit","emitWarning","console","warned","warnFileDeprecation","alternative","actions","action","extension","id","toUpperCase","disposable","commands","registerCommand","switchTo","subscriptions","compileYAML","load","createWebviewPanel","Beside","enableScripts","enableCommandUris","webview","html","EXTENSION_FALLBACKS","tsx","ts","js","yaml","activeEditor","activeTextEditor","showErrorMessage","extensions","fallbacks","ext","document","fileName","openFileIfExists","originFileName","getInitialContent","fontURL","X","showInputBox","prompt","disposableMessage","setStatusBarMessage","asyncContentLoading","url","styleResponse","styleContent","log","ex","loadContentFromURL","fontName","validateInput","isKebabCase","cssContent","dispose","asyncLoadAll","slices","urls","response","ok","status","statusText","arrayBuffer","data","css","pieces","piece","index","getExtension","fonts","loadAllFonts","defaultUri","editor","Path","dirname","Uri","file","folders","workspaceFolders","uri","getCurrentURI","uris","showOpenDialog","canSelectFiles","canSelectFolders","canSelectMany","openLabel","title","modal","fs","createDirectory","files","fontFile","cssFilename","fontClassFilename","modFilename","showInformationMessage","RX_KEBAB_CASE","input","dotIndex","Readable","BUFFER","TYPE","Blob","blobParts","arguments","buffers","size","element","ArrayBuffer","isView","byteOffset","byteLength","toLowerCase","buf","ab","readable","_read","relativeStart","relativeEnd","span","slicedBuffer","blob","FetchError","systemError","errno","captureStackTrace","constructor","convert","defineProperties","e","INTERNALS","PassThrough","Body","_this","_ref","_ref$size","_ref$timeout","timeout","isURLSearchParams","isBlob","isBuffer","disturbed","on","consumeBody","_this4","alloc","stream","accum","accumBytes","abort","resTimeout","setTimeout","chunk","clearTimeout","append","getAll","clone","instance","p1","p2","bodyUsed","getBoundary","pipe","extractContentType","getTotalBytes","getLengthSync","_lengthRetrievers","hasKnownLength","ct","headers","_this2","parse","_this3","charset","exec","convertBody","mixIn","proto","getOwnPropertyNames","desc","getOwnPropertyDescriptor","global","invalidTokenRegex","invalidHeaderCharRegex","validateName","validateValue","Headers","init","rawHeaders","raw","headerNames","headerName","method","callback","thisArg","getHeaders","_pairs$i","createHeadersIterator","kind","entries","values","INTERNAL","target","HeadersIteratorPrototype","setPrototypeOf","getPrototypeOf","_INTERNAL","exportNodeCompatibleHeaders","__proto__","hostHeaderKey","INTERNALS$1","STATUS_CODES","Response","opts","contentType","counter","redirected","INTERNALS$2","parse_url","format_url","streamDestructionSupported","isRequest","Request","parsedURL","href","inputBody","signal","isAbortSignal","redirect","follow","compress","agent","AbortError","PassThrough$1","resolve_url","fetch","request","protocol","hostname","contentLengthValue","totalBytes","getNodeRequestOptions","send","destroy","aborted","abortAndFinalize","finalize","req","reqTimeout","removeEventListener","addEventListener","once","socket","val","createHeadersLenient","isRedirect","statusCode","location","locationURL","requestOpts","response_options","statusMessage","codings","zlibOptions","flush","Z_SYNC_FLUSH","finishFlush","createGunzip","createBrotliDecompress","createInflate","createInflateRaw","dest","write","writeToStream","removeComments","cursor","indexOpen","indexClose","endsWith","getText","YAML","prettyErrors","errorMessage","destination","parseCst","Document$1","Document","defaultOptions","parseDocument","errMsg","defaults","parseAllDocuments","cstDoc","parseCST","scalarOptions","contents","BlankLine","CollectionItem","includesTrailingLines","parseNode","inlineComment","blankLine","nextNodeIsIndented","inCollection","setOrigRanges","Comment","grabCollectionEndComments","cnode","len","ci","prevEnd","nextContentHasIndent","firstItem","itemRange","ec","startOfLine","copy","normalizeOffset","prevIncludesTrailingLines","Directive","trim","parseName","parseParameters","directives","directivesEndMarker","documentEndMarker","hasDirectives","startCommentOrEndBlankLine","directive","iEnd","parseDirectives","parseContents","endOfIdentifier","Chomp","BlockValue","blockIndent","chomping","lastNewLine","keepStart","bi","folded","atStart","prevMoreIndented","lineEnd","explicit","minBlockIndent","lineIndent","parseBlockHeader","FlowCollection","jsonLike","prevNodeIsJsonLike","origOffset","QuoteDouble","parseCharCode","fromCodePoint","endOfQuote","QuoteSingle","ParseContext","overlay","valueStart","parseProps","createNewNode","parseEnd","nodeStartsCollection","lineHasProps","noIndicatorAsIndent","parseType","documents","crOffset","opt","documentOptions","stringifyTag","priv","createCtx","getTagObject","stringifyProps","Anchors","setAnchor","createAlias","names","validAnchorNode","visit","resolveTagDirective","parameters","resolveYamlDirective","assertCollection","anchorPrefix","toFixed","prevDoc","directiveComments","copyTagPrefix","setSchema","cbNode","resolveNodes","makePretty","onAnchor","keepBlobsInJSON","anchorNames","vd","tagNames","listNonDefaultTags","contentComment","util","parseMap","parseSeq"],"mappings":"2BACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QA0Df,OArDAF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,I,gBClFrDhC,EAAOD,QAAUkC,QAAQ,W,cCAzBjC,EAAOD,QAAUkC,QAAQ,S,6BCEzB,MAAMC,EAAO,CACXC,OAAQ,IACRC,QAAS,IACTC,IAAK,IACLC,eAAgB,IAChBC,aAAc,KAEVC,EAAO,CACXC,MAAO,QACPC,WAAY,aACZC,aAAc,eACdC,cAAe,gBACfR,QAAS,UACTS,UAAW,YACXC,SAAU,WACVC,SAAU,WACVC,SAAU,WACVC,IAAK,MACLC,QAAS,UACTC,UAAW,YACXC,MAAO,QACPC,aAAc,eACdC,aAAc,eACdC,IAAK,MACLC,SAAU,YASZ,SAASC,EAAeC,GACtB,MAAMC,EAAK,CAAC,GACZ,IAAIC,EAASF,EAAIG,QAAQ,MAEzB,MAAmB,IAAZD,GACLA,GAAU,EACVD,EAAGG,KAAKF,GACRA,EAASF,EAAIG,QAAQ,KAAMD,GAG7B,OAAOD,EAGT,SAASI,EAAWC,GAClB,IAAIC,EAAYP,EAehB,MAbmB,iBAARM,GACTC,EAAaR,EAAeO,GAC5BN,EAAMM,IAEFE,MAAMC,QAAQH,KAAMA,EAAMA,EAAI,IAE9BA,GAAOA,EAAII,UACRJ,EAAIC,aAAYD,EAAIC,WAAaR,EAAeO,EAAII,QAAQV,MACjEO,EAAaD,EAAIC,WACjBP,EAAMM,EAAII,QAAQV,MAIf,CACLO,aACAP,OAyBJ,SAASW,EAAWT,EAAQI,GAC1B,GAAsB,iBAAXJ,GAAuBA,EAAS,EAAG,OAAO,KACrD,MAAM,WACJK,EAAU,IACVP,GACEK,EAAWC,GACf,IAAKC,IAAeP,GAAOE,EAASF,EAAIY,OAAQ,OAAO,KAEvD,IAAK,IAAIrE,EAAI,EAAGA,EAAIgE,EAAWK,SAAUrE,EAAG,CAC1C,MAAMsE,EAAQN,EAAWhE,GAEzB,GAAI2D,EAASW,EACX,MAAO,CACLC,KAAMvE,EACNwE,IAAKb,EAASK,EAAWhE,EAAI,GAAK,GAItC,GAAI2D,IAAWW,EAAO,MAAO,CAC3BC,KAAMvE,EAAI,EACVwE,IAAK,GAIT,MAAMD,EAAOP,EAAWK,OACxB,MAAO,CACLE,OACAC,IAAKb,EAASK,EAAWO,EAAO,GAAK,GA+CzC,SAASE,GAAiB,MACxBH,EAAK,IACLI,GACCX,EAAKY,EAAW,IACjB,IAAIlB,EAlCN,SAAiBc,EAAMR,GACrB,MAAM,WACJC,EAAU,IACVP,GACEK,EAAWC,GACf,IAAKC,KAAgBO,GAAQ,IAAMA,EAAOP,EAAWK,OAAQ,OAAO,KACpE,MAAMC,EAAQN,EAAWO,EAAO,GAChC,IAAIG,EAAMV,EAAWO,GAErB,KAAOG,GAAOA,EAAMJ,GAA0B,OAAjBb,EAAIiB,EAAM,MAAeA,EAEtD,OAAOjB,EAAImB,MAAMN,EAAOI,GAuBdG,CAAQP,EAAMC,KAAMR,GAC9B,IAAKN,EAAK,OAAO,KACjB,IAAI,IACFe,GACEF,EAEJ,GAAIb,EAAIY,OAASM,EACf,GAAIH,GAAOG,EAAW,GACpBlB,EAAMA,EAAIqB,OAAO,EAAGH,EAAW,GAAK,QAC/B,CACL,MAAMI,EAAYC,KAAKC,MAAMN,EAAW,GACpClB,EAAIY,OAASG,EAAMO,IAAWtB,EAAMA,EAAIqB,OAAO,EAAGN,EAAMO,EAAY,GAAK,KAC7EP,GAAOf,EAAIY,OAASM,EACpBlB,EAAM,IAAMA,EAAIqB,OAAO,EAAIH,GAI/B,IAAIO,EAAS,EACTC,EAAS,GAETT,IACEA,EAAIH,OAASD,EAAMC,MAAQC,GAAOE,EAAIF,IAAMF,EAAME,MAAQG,EAAW,EACvEO,EAASR,EAAIF,IAAMF,EAAME,KAEzBU,EAASF,KAAKI,IAAI3B,EAAIY,OAAS,EAAGM,GAAYH,EAC9CW,EAAS,MAMb,MAAO,GAAG1B,MAFKe,EAAM,EAAI,IAAIa,OAAOb,EAAM,GAAK,KACnC,IAAIa,OAAOH,KACUC,IAGnC,MAAMG,EACJ,YAAYC,GACV,OAAO,IAAID,EAAMC,EAAKjB,MAAOiB,EAAKb,KAGpC,YAAYJ,EAAOI,GACjBc,KAAKlB,MAAQA,EACbkB,KAAKd,IAAMA,GAAOJ,EAGpB,UACE,MAA6B,iBAAfkB,KAAKlB,QAAuBkB,KAAKd,KAAOc,KAAKd,KAAOc,KAAKlB,MAYzE,aAAamB,EAAI9B,GACf,MAAM,MACJW,EAAK,IACLI,GACEc,KAEJ,GAAkB,IAAdC,EAAGpB,QAAgBK,GAAOe,EAAG,GAG/B,OAFAD,KAAKE,UAAYpB,EACjBkB,KAAKG,QAAUjB,EACRf,EAGT,IAAI3D,EAAI2D,EAER,KAAO3D,EAAIyF,EAAGpB,UACRoB,EAAGzF,GAAKsE,MAAoBtE,EAGlCwF,KAAKE,UAAYpB,EAAQtE,EACzB,MAAM4F,EAAa5F,EAEnB,KAAOA,EAAIyF,EAAGpB,UAERoB,EAAGzF,IAAM0E,MAAkB1E,EAIjC,OADAwF,KAAKG,QAAUjB,EAAM1E,EACd4F,GAOX,MAAMC,EACJ,2BAA2BpC,EAAKE,EAAQmC,GACtC,GAA4B,OAAxBA,EAAIA,EAAIzB,OAAS,GAAa,OAAOyB,EACzC,MAAMC,EAAOF,EAAKG,gBAAgBvC,EAAKE,GACvC,OAAOoC,GAAQtC,EAAIY,QAAwB,OAAdZ,EAAIsC,GAAiBD,EAAM,KAAOA,EAIjE,0BAA0BrC,EAAKE,EAAQsC,GACrC,MAAMC,EAAMzC,EAAIE,GAChB,IAAKuC,EAAK,OAAO,EACjB,MAAMC,EAAO1C,EAAIE,EAAS,GAC1B,GAAIwC,GAAiB,OAATA,EAAe,OAAO,EAElC,GAAIF,GACF,GAAIC,IAAQD,EAAK,OAAO,OAExB,GAAIC,IAAQjE,EAAKI,gBAAkB6D,IAAQjE,EAAKK,aAAc,OAAO,EAGvE,MAAM8D,EAAM3C,EAAIE,EAAS,GACnB0C,EAAM5C,EAAIE,EAAS,GACzB,GAAIyC,IAAQF,GAAOG,IAAQH,EAAK,OAAO,EACvC,MAAMI,EAAM7C,EAAIE,EAAS,GACzB,OAAQ2C,GAAe,OAARA,GAAwB,OAARA,GAAwB,MAARA,EAGjD,uBAAuB7C,EAAKE,GAC1B,IAAI4C,EAAK9C,EAAIE,GACb,MAAM6C,EAAoB,MAAPD,EACbE,EAAQD,EAAa,CAAC,KAAM,KAAM,IAAK,KAAO,CAAC,KAAM,KAAM,IAAK,IAAK,IAAK,IAAK,IAAK,KAE1F,KAAOD,IAA6B,IAAvBE,EAAM7C,QAAQ2C,IAAYA,EAAK9C,EAAIE,GAAU,GAG1D,OADI6C,GAAqB,MAAPD,IAAY5C,GAAU,GACjCA,EAGT,mBAAmBF,EAAKE,GACtB,IAAI4C,EAAK9C,EAAIE,GAEb,KAAc,MAAP4C,GAAYA,EAAK9C,EAAIE,GAAU,GAEtC,OAAOA,EAGT,iBAAiBF,EAAKE,GACpB,IAAI4C,EAAK9C,EAAIE,GAEb,KAAO4C,GAAa,OAAPA,GAAaA,EAAK9C,EAAIE,GAAU,GAE7C,OAAOA,EAGT,uBAAuBF,EAAKE,GAC1B,IAAI4C,EAAK9C,EAAIE,GAEb,KAAc,OAAP4C,GAAsB,MAAPA,GAAYA,EAAK9C,EAAIE,GAAU,GAErD,OAAOA,EAGT,mBAAmBF,EAAKE,GACtB,IAAI4C,EAAK9C,EAAIE,EAAS,GACtB,GAAW,OAAP4C,EAAa,OAAO5C,EAExB,KAAO4C,GAAa,OAAPA,GAAaA,EAAK9C,EAAIE,GAAU,GAE7C,OAAOA,EAAS,EAalB,wBAAwBF,EAAKiD,EAAQC,GACnC,MAAMC,EAAQf,EAAKgB,YAAYpD,EAAKkD,GAEpC,GAAIC,EAAQD,EAAYD,EACtB,OAAOE,EACF,CACL,MAAME,EAAQjB,EAAKG,gBAAgBvC,EAAKmD,GAClCL,EAAK9C,EAAIqD,GACf,IAAKP,GAAa,OAAPA,EAAa,OAAOO,EAGjC,OAAO,KAGT,eAAerD,EAAKE,EAAQoD,GAC1B,MAAMR,EAAK9C,EAAIE,GACf,MAAc,OAAP4C,GAAsB,OAAPA,GAAsB,MAAPA,GAAcQ,IAAeR,EAGpE,0BAA0BA,EAAIS,EAAYC,GACxC,SAAKV,GAAMS,EAAa,KACpBA,EAAa,GACVC,GAA4B,MAAPV,GAI9B,uBAAuB9C,EAAKE,GAC1B,MAAM4C,EAAK9C,EAAIE,GACf,OAAQ4C,EAAqB,OAAPA,GAAmC,OAApB9C,EAAIE,EAAS,GAAcA,EAAS,EAAIkC,EAAKG,gBAAgBvC,EAAKE,GAA1FA,EAKf,mBAAmBF,EAAKE,EAAQ+C,GAC9B,IAAIQ,EAAU,EACVC,GAAQ,EACRC,EAAO,GACPb,EAAK9C,EAAIE,EAAS,GAEtB,KAAc,MAAP4C,GAAqB,OAAPA,GAAsB,OAAPA,GAAa,CAC/C,OAAQA,GACN,IAAK,KACHW,EAAU,EACVvD,GAAU,EACVyD,GAAQ,KACR,MAEF,IAAK,KACCF,GAAWR,IAAQS,GAAQ,GAC/BxD,EAASkC,EAAKG,gBAAgBvC,EAAKE,EAAS,GAAK,EACjD,MAEF,IAAK,IACHuD,GAAW,EACXvD,GAAU,EAId4C,EAAK9C,EAAIE,EAAS,GAKpB,OAFKyD,IAAMA,EAAO,KACdb,GAAMW,GAAWR,IAAQS,GAAQ,GAC9B,CACLC,OACAzD,SACAwD,SAIJ,YAAYE,EAAMC,EAAOnD,GACvBzD,OAAOC,eAAe6E,KAAM,UAAW,CACrCvE,MAAOkD,GAAW,KAClBoD,UAAU,IAEZ/B,KAAK2B,MAAQ,KACb3B,KAAKgC,MAAQ,KACbhC,KAAKiC,WAAa,KAClBjC,KAAK8B,MAAQA,GAAS,GACtB9B,KAAK6B,KAAOA,EACZ7B,KAAKvE,MAAQ,KAGf,aAAayG,EAAKnG,EAAKoG,GACrB,IAAKnC,KAAKrB,QAAS,OAAO,KAC1B,MAAM,IACJV,GACE+B,KAAKrB,QACHyD,EAAOpC,KAAK8B,MAAMI,GACxB,OAAOE,GAAQnE,EAAImE,EAAKtD,SAAW/C,EAAMkC,EAAImB,MAAMgD,EAAKtD,OAASqD,EAAU,EAAI,GAAIC,EAAKlD,KAAO,KAGjG,aACE,IAAK,IAAI1E,EAAI,EAAGA,EAAIwF,KAAK8B,MAAMjD,SAAUrE,EAAG,CAC1C,MAAM6H,EAASrC,KAAKsC,aAAa9H,EAAGiC,EAAKC,QAAQ,GACjD,GAAc,MAAV2F,EAAgB,OAAOA,EAG7B,OAAO,KAGT,cACE,MAAME,EAAW,GAEjB,IAAK,IAAI/H,EAAI,EAAGA,EAAIwF,KAAK8B,MAAMjD,SAAUrE,EAAG,CAC1C,MAAMgI,EAAUxC,KAAKsC,aAAa9H,EAAGiC,EAAKE,SAAS,GACpC,MAAX6F,GAAiBD,EAASlE,KAAKmE,GAGrC,OAAOD,EAAS1D,OAAS,EAAI0D,EAASE,KAAK,MAAQ,KAGrD,6BAA6B3D,GAC3B,MAAM,IACJb,GACE+B,KAAKrB,QACT,GAAIqB,KAAK0C,QAAU5D,IAAUkB,KAAK0C,OAAOxD,IAAK,OAAO,EACrD,IAAKc,KAAKiC,WAAY,OAAO,EAC7B,MAAM,IACJ/C,GACEc,KAAKiC,WACT,OAAOnD,IAAUI,GAAOmB,EAAKsC,QAAQ1E,EAAKiB,EAAM,GAGlD,iBACE,GAAIc,KAAKrB,QAAS,CAChB,MAAM,IACJV,GACE+B,KAAKrB,QAET,IAAK,IAAInE,EAAI,EAAGA,EAAIwF,KAAK8B,MAAMjD,SAAUrE,EACvC,GAAIyD,EAAI+B,KAAK8B,MAAMtH,GAAGsE,SAAWrC,EAAKE,QAAS,OAAO,EAI1D,OAAO,EAGT,eACE,GAAIqD,KAAKrB,QAAS,CAChB,MAAM,IACJV,GACE+B,KAAKrB,QAET,IAAK,IAAInE,EAAI,EAAGA,EAAIwF,KAAK8B,MAAMjD,SAAUrE,EACvC,GAAIyD,EAAI+B,KAAK8B,MAAMtH,GAAGsE,SAAWrC,EAAKE,QAAS,OAAO,EAI1D,OAAO,EAGT,4BACE,OAAO,EAGT,eAEE,OAA6C,IADvB,CAACI,EAAKO,SAAUP,EAAKQ,SAAUR,EAAKa,aAAcb,EAAKc,cACxDO,QAAQ4B,KAAK6B,MAGpC,qBACE,IAAK7B,KAAKgC,QAAUhC,KAAKrB,QAAS,OAClC,MAAMG,EAAQF,EAAWoB,KAAKgC,MAAMlD,MAAOkB,KAAKrB,QAAQiE,MACxD,IAAK9D,EAAO,OAEZ,MAAO,CACLA,QACAI,IAHUN,EAAWoB,KAAKgC,MAAM9C,IAAKc,KAAKrB,QAAQiE,OAOtD,eACE,IAAK5C,KAAKiC,aAAejC,KAAKrB,QAAS,OAAO,KAC9C,MAAM,MACJG,EAAK,IACLI,GACEc,KAAKiC,WACT,OAAOjC,KAAKrB,QAAQV,IAAImB,MAAMN,EAAOI,GAGvC,UACE,IAAK,IAAI1E,EAAI,EAAGA,EAAIwF,KAAK8B,MAAMjD,SAAUrE,EAAG,CAC1C,MAAMqI,EAAM7C,KAAKsC,aAAa9H,EAAGiC,EAAKG,KAAK,GAE3C,GAAW,MAAPiG,EAAa,CACf,GAAe,MAAXA,EAAI,GACN,MAAO,CACLC,SAAUD,EAAIzD,MAAM,GAAI,IAErB,CAEL,MAAO2D,EAAGC,EAAQC,GAAUJ,EAAIK,MAAM,kBACtC,MAAO,CACLF,SACAC,YAMR,OAAO,KAGT,gCACE,IAAKjD,KAAKiC,aAAejC,KAAKrB,QAAS,OAAO,EAC9C,MAAM,MACJG,EAAK,IACLI,GACEc,KAAKiC,YACH,IACJhE,GACE+B,KAAKrB,QAET,IAAK,IAAInE,EAAIsE,EAAOtE,EAAI0E,IAAO1E,EAC7B,GAAe,OAAXyD,EAAIzD,GAAa,OAAO,EAG9B,OAAO,EAGT,aAAasE,GACX,MAAM,IACJb,GACE+B,KAAKrB,QAET,GAAIV,EAAIa,KAAWrC,EAAKE,QAAS,CAC/B,MAAMuC,EAAMmB,EAAK8C,UAAUlF,EAAKa,EAAQ,GAClCsE,EAAe,IAAItD,EAAMhB,EAAOI,GAEtC,OADAc,KAAK8B,MAAMzD,KAAK+E,GACTlE,EAGT,OAAOJ,EAYT,cAAcmB,EAAI9B,GAIhB,OAHI6B,KAAKgC,QAAO7D,EAAS6B,KAAKgC,MAAMqB,aAAapD,EAAI9B,IACjD6B,KAAKiC,YAAYjC,KAAKiC,WAAWoB,aAAapD,EAAI9B,GACtD6B,KAAK8B,MAAMwB,QAAQlB,GAAQA,EAAKiB,aAAapD,EAAI9B,IAC1CA,EAGT,WACE,MACEQ,SAAS,IACPV,GACD,MACD+D,EAAK,MACLvG,GACEuE,KACJ,GAAa,MAATvE,EAAe,OAAOA,EAC1B,MAAM6E,EAAMrC,EAAImB,MAAM4C,EAAMlD,MAAOkD,EAAM9C,KACzC,OAAOmB,EAAKkD,oBAAoBtF,EAAK+D,EAAM9C,IAAKoB,IAKpD,MAAMkD,UAAkBC,MACtB,YAAY1I,EAAM2I,EAAQC,GACxB,KAAKA,GAAaD,aAAkBrD,GAAO,MAAM,IAAIoD,MAAM,6BAA6B1I,GACxF6I,QACA5D,KAAKjF,KAAOA,EACZiF,KAAK2D,QAAUA,EACf3D,KAAK0D,OAASA,EAGhB,aACE,IAAK1D,KAAK0D,OAAQ,OAClB1D,KAAK6D,SAAW7D,KAAK0D,OAAO7B,KAC5B,MAAMtD,EAAMyB,KAAK0D,OAAO/E,SAAWqB,KAAK0D,OAAO/E,QAAQiE,KAEvD,GAA2B,iBAAhB5C,KAAK7B,OAAqB,CACnC6B,KAAKgC,MAAQ,IAAIlC,EAAME,KAAK7B,OAAQ6B,KAAK7B,OAAS,GAClD,MAAMW,EAAQP,GAAOK,EAAWoB,KAAK7B,OAAQI,GAE7C,GAAIO,EAAO,CACT,MAAMI,EAAM,CACVH,KAAMD,EAAMC,KACZC,IAAKF,EAAME,IAAM,GAEnBgB,KAAK8D,QAAU,CACbhF,QACAI,cAIGc,KAAK7B,YAEZ6B,KAAKgC,MAAQhC,KAAK0D,OAAO1B,MACzBhC,KAAK8D,QAAU9D,KAAK0D,OAAOK,eAG7B,GAAI/D,KAAK8D,QAAS,CAChB,MAAM,KACJ/E,EAAI,IACJC,GACEgB,KAAK8D,QAAQhF,MACjBkB,KAAK2D,SAAW,YAAY5E,aAAgBC,IAC5C,MAAMgF,EAAMzF,GAAOU,EAAiBe,KAAK8D,QAASvF,GAC9CyF,IAAKhE,KAAK2D,SAAW,QAAQK,cAG5BhE,KAAK0D,QAUhB,MAAMO,UAA0BT,EAC9B,YAAYE,EAAQC,GAClBC,MAAM,oBAAqBF,EAAQC,IAgCvC,MAAMO,UAAmB7D,EACvB,iBAAiBpC,EAAKa,EAAOqF,GAC3B,IAAIpD,EAAK9C,EAAIa,GACTX,EAASW,EAEb,KAAOiC,GAAa,OAAPA,KACPoD,GAAkB,MAAPpD,GAAqB,MAAPA,GAAqB,MAAPA,GAAqB,MAAPA,GAAqB,MAAPA,IAD/C,CAExB,MAAMR,EAAOtC,EAAIE,EAAS,GAC1B,GAAW,MAAP4C,KAAgBR,GAAiB,OAATA,GAA0B,OAATA,GAA0B,MAATA,GAAgB4D,GAAmB,MAAT5D,GAAe,MACvG,IAAY,MAAPQ,GAAqB,OAAPA,IAAyB,MAATR,EAAc,MACjDpC,GAAU,EACV4C,EAAKR,EAGP,OAAOpC,EAGT,eACE,IAAK6B,KAAKiC,aAAejC,KAAKrB,QAAS,OAAO,KAC9C,IAAI,MACFG,EAAK,IACLI,GACEc,KAAKiC,WACT,MAAM,IACJhE,GACE+B,KAAKrB,QACT,IAAIoC,EAAK9C,EAAIiB,EAAM,GAEnB,KAAOJ,EAAQI,IAAe,OAAP6B,GAAsB,OAAPA,GAAsB,MAAPA,IAAaA,EAAK9C,IAAMiB,EAAM,GAEnF,IAAIoB,EAAM,GAEV,IAAK,IAAI9F,EAAIsE,EAAOtE,EAAI0E,IAAO1E,EAAG,CAChC,MAAMuG,EAAK9C,EAAIzD,GAEf,GAAW,OAAPuG,EAAa,CACf,MAAM,KACJa,EAAI,OACJzD,GACEkC,EAAK+D,YAAYnG,EAAKzD,GAAI,GAC9B8F,GAAOsB,EACPpH,EAAI2D,OACC,GAAW,MAAP4C,GAAqB,OAAPA,EAAa,CAEpC,MAAMsD,EAAU7J,EAChB,IAAI+F,EAAOtC,EAAIzD,EAAI,GAEnB,KAAOA,EAAI0E,IAAiB,MAATqB,GAAyB,OAATA,IACjC/F,GAAK,EACL+F,EAAOtC,EAAIzD,EAAI,GAGJ,OAAT+F,IAAeD,GAAO9F,EAAI6J,EAAUpG,EAAImB,MAAMiF,EAAS7J,EAAI,GAAKuG,QAEpET,GAAOS,EAIX,MAAML,EAAMzC,EAAIa,GAEhB,OAAQ4B,GACN,IAAK,KAID,MAAO,CACL4D,OAFa,CAAC,IAAIL,EAAkBjE,KAD1B,kDAIVM,OAIN,IAAK,IACL,IAAK,IAID,MAAO,CACLgE,OAFa,CAAC,IAAIL,EAAkBjE,KAD1B,oDAAoDU,IAI9DJ,OAIN,QACE,OAAOA,GAIb,gBAAgBxB,GACd,MAAM,OACJoC,EAAM,OACNiD,EAAM,IACNlG,GACE+B,KAAKrB,QACT,IAAIR,EAASW,EACTyF,EAAWzF,EAEf,IAAK,IAAIiC,EAAK9C,EAAIE,GAAgB,OAAP4C,IACrBV,EAAKmE,mBAAmBvG,EAAKE,EAAS,GADJ4C,EAAK9C,EAAIE,GAAS,CAExD,MAAMe,EAAMmB,EAAKoE,iBAAiBxG,EAAKiD,EAAQ/C,EAAS,GACxD,GAAY,OAARe,GAA6B,MAAbjB,EAAIiB,GAAc,MAErB,OAAbjB,EAAIiB,GACNf,EAASe,GAETqF,EAAWL,EAAWf,UAAUlF,EAAKiB,EAAKiF,GAC1ChG,EAASoG,GAMb,OAFIvE,KAAKiC,WAAWyC,YAAW1E,KAAKiC,WAAWnD,MAAQA,GACvDkB,KAAKiC,WAAW/C,IAAMqF,EACfA,EA6BT,MAAM5F,EAASG,GACbkB,KAAKrB,QAAUA,EACf,MAAM,OACJwF,EAAM,IACNlG,GACEU,EACJ,IAAIR,EAASW,EACb,MAAMiC,EAAK9C,EAAIE,GAcf,OAZI4C,GAAa,MAAPA,GAAqB,OAAPA,IACtB5C,EAAS+F,EAAWf,UAAUlF,EAAKa,EAAOqF,IAG5CnE,KAAKiC,WAAa,IAAInC,EAAMhB,EAAOX,GACnCA,EAASkC,EAAKG,gBAAgBvC,EAAKE,GACnCA,EAAS6B,KAAK2E,aAAaxG,GAEtB6B,KAAK4E,aAAc5E,KAAKiC,WAAWyC,YACtCvG,EAAS6B,KAAK6E,gBAAgB1G,IAGzBA,GAKX7D,EAAQmC,KAAOA,EACfnC,EAAQ+F,KAAOA,EACf/F,EAAQ4J,WAAaA,EACrB5J,EAAQwF,MAAQA,EAChBxF,EAAQyC,KAAOA,EACfzC,EAAQkJ,UAAYA,EACpBlJ,EAAQwK,mBApNR,cAAiCtB,EAC/B,YAAYE,EAAQC,GAClBC,MAAM,qBAAsBF,EAAQC,KAmNxCrJ,EAAQ2J,kBAAoBA,EAC5B3J,EAAQyK,gBA1MR,cAA8BvB,EAC5B,YAAYE,EAAQC,GAClBC,MAAM,kBAAmBF,EAAQC,KAyMrCrJ,EAAQ0K,YArMR,cAA0BxB,EACxB,YAAYE,EAAQC,GAClBC,MAAM,cAAeF,EAAQC,KAoMjCrJ,EAAQ2K,gBA/LR,SAAyBC,EAAKnJ,EAAKN,GAYjC,OAXIM,KAAOmJ,EACThK,OAAOC,eAAe+J,EAAKnJ,EAAK,CAC9BN,MAAOA,EACPL,YAAY,EACZ+J,cAAc,EACdpD,UAAU,IAGZmD,EAAInJ,GAAON,EAGNyJ,GAoLT5K,EAAQ8K,iBA90BiB,qBA+0BzB9K,EAAQ+K,YA90BY,CAClB7H,IAAK,wBACLM,IAAK,wBACLwH,IAAK,0B,6BC9BP,IAAIpB,EAAa,EAAQ,GAOzB,SAASqB,EAAWjF,EAAKY,EAAQsB,GAC/B,OAAQA,GAA2C,IAA3BA,EAAQpE,QAAQ,MAAe,GAAGkC,MAAQkC,IAAelC,EAAH,KAAakC,EAAQgD,QAAQ,OAAUtE,GAAU,IAAb,KAAhGZ,EAGpB,MAAMD,GAEN,SAASoF,EAAOhK,EAAOiK,EAAK1B,GAC1B,GAAIvF,MAAMC,QAAQjD,GAAQ,OAAOA,EAAMkK,IAAI,CAACC,EAAGpL,IAAMiL,EAAOG,EAAGC,OAAOrL,GAAIwJ,IAE1E,GAAIvI,GAAiC,mBAAjBA,EAAMgK,OAAuB,CAC/C,MAAMpD,EAAS2B,GAAOA,EAAI8B,SAAW9B,EAAI8B,QAAQzK,IAAII,GACjD4G,IAAQ2B,EAAI+B,SAAWC,IACzB3D,EAAO2D,IAAMA,SACNhC,EAAI+B,WAEb,MAAMC,EAAMvK,EAAMgK,OAAOC,EAAK1B,GAE9B,OADI3B,GAAU2B,EAAI+B,UAAU/B,EAAI+B,SAASC,GAClCA,EAGT,OAAMhC,GAAQA,EAAIiC,MAA0B,iBAAVxK,EAC3BA,EADsDyK,OAAOzK,GAItE,MAAM0K,UAAe9F,EACnB,YAAY5E,GACVmI,QACA5D,KAAKvE,MAAQA,EAGf,OAAOiK,EAAK1B,GACV,OAAOA,GAAOA,EAAIiC,KAAOjG,KAAKvE,MAAQgK,EAAOzF,KAAKvE,MAAOiK,EAAK1B,GAGhE,WACE,OAAO6B,OAAO7F,KAAKvE,QAKvB,SAAS2K,EAAmBC,EAAQC,EAAM7K,GACxC,IAAImK,EAAInK,EAER,IAAK,IAAIjB,EAAI8L,EAAKzH,OAAS,EAAGrE,GAAK,IAAKA,EAAG,CACzC,MAAM+L,EAAID,EAAK9L,GACTS,EAAIiL,OAAOM,UAAUD,IAAMA,GAAK,EAAI,GAAK,GAC/CtL,EAAEsL,GAAKX,EACPA,EAAI3K,EAGN,OAAOoL,EAAOI,WAAWb,GAAG,GAI9B,MAAMc,EAAcJ,GAAgB,MAARA,GAAgC,iBAATA,GAAqBA,EAAK/K,OAAOoL,YAAYpG,OAAOqG,KACvG,MAAMC,UAAmBxG,EACvB,YAAYgG,GACVzC,QAEAM,EAAWe,gBAAgBjF,KAAM,QAAS,IAE1CA,KAAKqG,OAASA,EAGhB,MAAMC,EAAM7K,GACV,GAAIiL,EAAYJ,GAAOtG,KAAK8G,IAAIrL,OAAY,CAC1C,MAAOM,KAAQgL,GAAQT,EACjBU,EAAOhH,KAAK3E,IAAIU,GAAK,GAC3B,GAAIiL,aAAgBH,EAAYG,EAAKC,MAAMF,EAAMtL,OAAY,SAAayL,IAATF,IAAsBhH,KAAKqG,OAAyE,MAAM,IAAI5C,MAAM,+BAA+B1H,sBAAwBgL,KAAxI/G,KAAKmH,IAAIpL,EAAKqK,EAAmBpG,KAAKqG,OAAQU,EAAMtL,MAI5J,UAAUM,KAAQgL,IAChB,GAAoB,IAAhBA,EAAKlI,OAAc,OAAOmB,KAAKoH,OAAOrL,GAC1C,MAAMiL,EAAOhH,KAAK3E,IAAIU,GAAK,GAC3B,GAAIiL,aAAgBH,EAAY,OAAOG,EAAKK,SAASN,GAAW,MAAM,IAAItD,MAAM,+BAA+B1H,sBAAwBgL,KAGzI,OAAOhL,KAAQgL,GAAOO,GACpB,MAAMN,EAAOhH,KAAK3E,IAAIU,GAAK,GAC3B,OAAoB,IAAhBgL,EAAKlI,QAAsByI,GAAcN,aAAgBb,EAASa,EAAKvL,MAAQuL,EAAiBA,aAAgBH,EAAaG,EAAKO,MAAMR,EAAMO,QAAcJ,EAGlK,mBACE,OAAOlH,KAAKwH,MAAMC,MAAMT,IACtB,IAAKA,GAAsB,SAAdA,EAAKnF,KAAiB,OAAO,EAC1C,MAAM5F,EAAI+K,EAAKvL,MACf,OAAY,MAALQ,GAAaA,aAAakK,GAAqB,MAAXlK,EAAER,QAAkBQ,EAAEyL,gBAAkBzL,EAAEuG,UAAYvG,EAAE4G,MAIvG,OAAO9G,KAAQgL,IACb,GAAoB,IAAhBA,EAAKlI,OAAc,OAAOmB,KAAK2H,IAAI5L,GACvC,MAAMiL,EAAOhH,KAAK3E,IAAIU,GAAK,GAC3B,OAAOiL,aAAgBH,GAAaG,EAAKY,MAAMb,GAGjD,OAAOhL,KAAQgL,GAAOtL,GACpB,GAAoB,IAAhBsL,EAAKlI,OACPmB,KAAKmH,IAAIpL,EAAKN,OACT,CACL,MAAMuL,EAAOhH,KAAK3E,IAAIU,GAAK,GAC3B,GAAIiL,aAAgBH,EAAYG,EAAKa,MAAMd,EAAMtL,OAAY,SAAayL,IAATF,IAAsBhH,KAAKqG,OAAyE,MAAM,IAAI5C,MAAM,+BAA+B1H,sBAAwBgL,KAAxI/G,KAAKmH,IAAIpL,EAAKqK,EAAmBpG,KAAKqG,OAAQU,EAAMtL,MAO5J,SACE,OAAO,KAGT,SAASuI,GAAK,UACZ8D,EAAS,UACTC,EAAS,MACTC,EAAK,WACLC,GACCC,EAAWC,GACZ,MAAM,OACJjH,EAAM,WACNkH,EAAU,UACVC,GACErE,EACEG,EAASnE,KAAK6B,OAASqC,EAAWnH,KAAKO,UAAY0C,KAAK6B,OAASqC,EAAWnH,KAAKQ,UAAYyG,EAAIG,OACnGA,IAAQ8D,GAAcG,GAC1B,MAAME,EAAgBN,GAAShI,KAAKuI,mBACpCvE,EAAM9I,OAAOsN,OAAO,GAAIxE,EAAK,CAC3BsE,gBACApH,OAAQ+G,EACR9D,SACAtC,KAAM,OAER,IAAI4G,GAAY,EACZC,GAAqB,EACzB,MAAMC,EAAQ3I,KAAKwH,MAAMoB,OAAO,CAACD,EAAOE,EAAMrO,KAC5C,IAAIgI,EAEAqG,KACGJ,GAAaI,EAAKC,aAAaH,EAAMtK,KAAK,CAC7CwD,KAAM,UACNvB,IAAK,KAEHuI,EAAKnB,eAAemB,EAAKnB,cAAcxE,MAAM,UAAUI,QAAQvE,IACjE4J,EAAMtK,KAAK,CACTwD,KAAM,UACNvB,IAAK,IAAIvB,MAGT8J,EAAKrG,UAASA,EAAUqG,EAAKrG,SAC7B2B,KAAYsE,GAAaI,EAAKC,aAAeD,EAAKnB,eAAiBmB,EAAKrG,SAAWqG,EAAK9M,MAAQ8M,EAAK9M,IAAI2L,eAAiBmB,EAAK9M,IAAIyG,UAAYqG,EAAKpN,QAAUoN,EAAKpN,MAAMiM,eAAiBmB,EAAKpN,MAAM+G,YAAWkG,GAAqB,IAG3OD,GAAY,EACZ,IAAInI,EAAM+H,EAAUQ,EAAM7E,EAAK,IAAMxB,EAAU,KAAM,IAAMiG,GAAY,GASvE,OARItE,IAAWuE,GAAsBpI,EAAIyI,SAAS,QAAOL,GAAqB,GAC1EvE,GAAU3J,EAAIwF,KAAKwH,MAAM3I,OAAS,IAAGyB,GAAO,KAChDA,EAAMiF,EAAWjF,EAAK2H,EAAYzF,GAC9BiG,IAAcjG,GAAW2B,KAASsE,GAAY,GAClDE,EAAMtK,KAAK,CACTwD,KAAM,OACNvB,QAEKqI,GACN,IACH,IAAIrI,EAEJ,GAAqB,IAAjBqI,EAAM9J,OACRyB,EAAMyH,EAAUjJ,MAAQiJ,EAAU7I,SAC7B,GAAIiF,EAAQ,CACjB,MAAM,MACJrF,EAAK,IACLI,GACE6I,EACEiB,EAAUL,EAAMhD,IAAI1J,GAAKA,EAAEqE,KAEjC,GAAIoI,GAAsBM,EAAQJ,OAAO,CAACK,EAAK3I,IAAQ2I,EAAM3I,EAAIzB,OAAS,EAAG,GAAKgI,EAAWqC,8BAA+B,CAC1H5I,EAAMxB,EAEN,IAAK,MAAMvC,KAAKyM,EACd1I,GAAO/D,EAAI,KAAK6L,IAAalH,IAAS3E,IAAM,KAG9C+D,GAAO,KAAKY,IAAShC,SAErBoB,EAAM,GAAGxB,KAASkK,EAAQvG,KAAK,QAAQvD,QAEpC,CACL,MAAM8J,EAAUL,EAAMhD,IAAImC,GAC1BxH,EAAM0I,EAAQG,QAEd,IAAK,MAAM5M,KAAKyM,EAAS1I,GAAO/D,EAAI,KAAK2E,IAAS3E,IAAM,KAQ1D,OALIyD,KAAKwC,SACPlC,GAAO,KAAON,KAAKwC,QAAQgD,QAAQ,MAAUtE,EAAH,KACtCgH,GAAWA,KACNO,GAAaN,GAAaA,IAE9B7H,GAOX,SAAS8I,EAAYrN,GACnB,IAAImG,EAAMnG,aAAeoK,EAASpK,EAAIN,MAAQM,EAE9C,OADImG,GAAsB,iBAARA,IAAkBA,EAAMgE,OAAOhE,IAC1CgE,OAAOM,UAAUtE,IAAQA,GAAO,EAAIA,EAAM,KALnDgC,EAAWe,gBAAgB4B,EAAY,gCAAiC,IAQxE,MAAMwC,UAAgBxC,EACpB,IAAIpL,GACFuE,KAAKwH,MAAMnJ,KAAK5C,GAGlB,OAAOM,GACL,MAAMmG,EAAMkH,EAAYrN,GACxB,GAAmB,iBAARmG,EAAkB,OAAO,EAEpC,OADYlC,KAAKwH,MAAM8B,OAAOpH,EAAK,GACxBrD,OAAS,EAGtB,IAAI9C,EAAKuL,GACP,MAAMpF,EAAMkH,EAAYrN,GACxB,GAAmB,iBAARmG,EAAkB,OAC7B,MAAMqH,EAAKvJ,KAAKwH,MAAMtF,GACtB,OAAQoF,GAAciC,aAAcpD,EAASoD,EAAG9N,MAAQ8N,EAG1D,IAAIxN,GACF,MAAMmG,EAAMkH,EAAYrN,GACxB,MAAsB,iBAARmG,GAAoBA,EAAMlC,KAAKwH,MAAM3I,OAGrD,IAAI9C,EAAKN,GACP,MAAMyG,EAAMkH,EAAYrN,GACxB,GAAmB,iBAARmG,EAAkB,MAAM,IAAIuB,MAAM,+BAA+B1H,MAC5EiE,KAAKwH,MAAMtF,GAAOzG,EAGpB,OAAOsH,EAAGiB,GACR,MAAMwF,EAAM,GACRxF,GAAOA,EAAI+B,UAAU/B,EAAI+B,SAASyD,GACtC,IAAIhP,EAAI,EAER,IAAK,MAAMqO,KAAQ7I,KAAKwH,MAAOgC,EAAInL,KAAKoH,EAAOoD,EAAMhD,OAAOrL,KAAMwJ,IAElE,OAAOwF,EAGT,SAASxF,EAAKkE,EAAWC,GACvB,OAAKnE,EACEJ,MAAM6F,SAASzF,EAAK,CACzB8D,UAAW7L,GAAgB,YAAXA,EAAE4F,KAAqB5F,EAAEqE,IAAM,KAAKrE,EAAEqE,IACtDyH,UAAW,CACTjJ,MAAO,IACPI,IAAK,KAEP8I,OAAO,EACPC,YAAajE,EAAI9C,QAAU,IAAM,MAChCgH,EAAWC,GATGuB,KAAKrB,UAAUrI,OA6BpC,MAAM2J,UAAatJ,EACjB,YAAYtE,EAAKN,EAAQ,MACvBmI,QACA5D,KAAKjE,IAAMA,EACXiE,KAAKvE,MAAQA,EACbuE,KAAK6B,KAAO8H,EAAK5M,KAAK6M,KAGxB,oBACE,OAAO5J,KAAKjE,eAAesE,EAAOL,KAAKjE,IAAI2L,mBAAgBR,EAG7D,kBAAkB2C,GAEhB,GADgB,MAAZ7J,KAAKjE,MAAaiE,KAAKjE,IAAM,IAAIoK,EAAO,SACxCnG,KAAKjE,eAAesE,GAAuC,CAE7D,MAAM,IAAIoD,MADE,iGADgBzD,KAAKjE,IAAI2L,cAAgBmC,EAMzD,WAAW7F,EAAK2B,GACd,MAAM5J,EAAM0J,EAAOzF,KAAKjE,IAAK,GAAIiI,GAEjC,GAAI2B,aAAemE,IAAK,CACtB,MAAMrO,EAAQgK,EAAOzF,KAAKvE,MAAOM,EAAKiI,GACtC2B,EAAIwB,IAAIpL,EAAKN,QACR,GAAIkK,aAAeoE,IACxBpE,EAAImB,IAAI/K,OACH,CACL,MAAMiO,EA5CS,EAACjO,EAAKkO,EAAOjG,IAClB,OAAViG,EAAuB,GACN,iBAAVA,EAA2BpE,OAAOoE,GACzClO,aAAesE,GAAQ2D,GAAOA,EAAIkG,IAAYnO,EAAI0N,SAAS,CAC7D3D,QAAS,GACToE,IAAKlG,EAAIkG,IACThJ,OAAQ,GACRkH,WAAYpE,EAAIoE,WAChBjE,QAAQ,EACRgG,gBAAgB,EAChB9B,UAAWrE,EAAIqE,YAEVqB,KAAKrB,UAAU4B,GAgCAG,CAAapK,KAAKjE,IAAKA,EAAKiI,GAC9C2B,EAAIqE,GAAavE,EAAOzF,KAAKvE,MAAOuO,EAAWhG,GAGjD,OAAO2B,EAGT,OAAO5C,EAAGiB,GACR,MAAMqG,EAAOrG,GAAOA,EAAIsG,SAAW,IAAIR,IAAQ,GAC/C,OAAO9J,KAAKuK,WAAWvG,EAAKqG,GAG9B,SAASrG,EAAKkE,EAAWC,GACvB,IAAKnE,IAAQA,EAAIkG,IAAK,OAAOR,KAAKrB,UAAUrI,MAC5C,MACEkB,OAAQsJ,EAAU,UAClBC,EAAS,WACTC,GACE1G,EAAIkG,IAAIS,QACZ,IAAI,IACF5O,EAAG,MACHN,GACEuE,KACA4K,EAAa7O,aAAesE,GAAQtE,EAAIyG,QAE5C,GAAIkI,EAAY,CACd,GAAIE,EACF,MAAM,IAAInH,MAAM,oDAGlB,GAAI1H,aAAe8K,EAAY,CAE7B,MAAM,IAAIpD,MADE,+DAKhB,MAAMoH,GAAeH,KAAgB3O,GAAO6O,GAAc7O,aAAe8K,GAAc9K,EAAI8F,OAASqC,EAAWnH,KAAKG,cAAgBnB,EAAI8F,OAASqC,EAAWnH,KAAKI,gBAC3J,IACJ+M,EAAG,OACHhJ,EAAM,WACNkH,EAAU,UACVC,GACErE,EACJA,EAAM9I,OAAOsN,OAAO,GAAIxE,EAAK,CAC3B8G,aAAcD,EACd3J,OAAQA,EAASkH,IAEnB,IAAIK,GAAY,EACZnI,EAAM+H,EAAUtM,EAAKiI,EAAK,IAAM4G,EAAa,KAAM,IAAMnC,GAAY,GAGzE,GAFAnI,EAAMiF,EAAWjF,EAAK0D,EAAI9C,OAAQ0J,GAE9B5G,EAAIsE,gBAAkBoC,EAMxB,OALI1K,KAAKwC,SACPlC,EAAMiF,EAAWjF,EAAK0D,EAAI9C,OAAQlB,KAAKwC,SACnC0F,GAAWA,KACNO,IAAcmC,GAAczC,GAAaA,IAE7CnE,EAAIG,OAAS7D,EAAM,KAAKA,EAGjCA,EAAMuK,EAAc,KAAKvK,MAAQY,KAAeZ,EAAH,IAEzCN,KAAKwC,UAEPlC,EAAMiF,EAAWjF,EAAK0D,EAAI9C,OAAQlB,KAAKwC,SACnC0F,GAAWA,KAGjB,IAAI6C,EAAM,GACNC,EAAe,KAEnB,GAAIvP,aAAiB4E,EAAM,CAGzB,GAFI5E,EAAMqN,cAAaiC,EAAM,MAEzBtP,EAAMiM,cAAe,CAEvBqD,GAAO,KADItP,EAAMiM,cAAclC,QAAQ,MAAUxB,EAAI9C,OAAP,KAIhD8J,EAAevP,EAAM+G,aACZ/G,GAA0B,iBAAVA,IACzBA,EAAQyO,EAAI7D,OAAOI,WAAWhL,GAAO,IAGvCuI,EAAI8G,aAAc,GACbD,IAAgB7K,KAAKwC,SAAW/G,aAAiB0K,IAAQnC,EAAIiH,cAAgB3K,EAAIzB,OAAS,GAC/F4J,GAAY,GAEPgC,GAAaD,GAAc,IAAMxG,EAAIG,SAAW0G,GAAepP,aAAiB4N,GAAW5N,EAAMoG,OAASqC,EAAWnH,KAAKQ,WAAa9B,EAAMoH,MAAQqH,EAAIpE,QAAQoF,QAAQzP,KAE5KuI,EAAI9C,OAAS8C,EAAI9C,OAAO5B,OAAO,IAGjC,MAAM6L,EAAW9C,EAAU5M,EAAOuI,EAAK,IAAMgH,EAAe,KAAM,IAAMvC,GAAY,GACpF,IAAI2C,EAAK,IAET,GAAIL,GAAO/K,KAAKwC,QACd4I,EAAK,GAAGL,MAAQ/G,EAAI9C,cACf,IAAK2J,GAAepP,aAAiBoL,EAAY,EACzB,MAAhBsE,EAAS,IAA8B,MAAhBA,EAAS,MAChCA,EAASpC,SAAS,QAAOqC,EAAK,KAAKpH,EAAI9C,QAItD,OADIuH,IAAcuC,GAAgB7C,GAAaA,IACxC5C,EAAWjF,EAAM8K,EAAKD,EAAUnH,EAAI9C,OAAQ8J,IAKvD9G,EAAWe,gBAAgB0E,EAAM,OAAQ,CACvCC,KAAM,OACNyB,WAAY,eAGd,MAAMC,EAAgB,CAACtE,EAAMlB,KAC3B,GAAIkB,aAAgBuE,EAAO,CACzB,MAAMlJ,EAASyD,EAAQzK,IAAI2L,EAAKtD,QAChC,OAAOrB,EAAOmJ,MAAQnJ,EAAOoJ,WACxB,GAAIzE,aAAgBH,EAAY,CACrC,IAAI2E,EAAQ,EAEZ,IAAK,MAAM3C,KAAQ7B,EAAKQ,MAAO,CAC7B,MAAM3M,EAAIyQ,EAAczC,EAAM/C,GAC1BjL,EAAI2Q,IAAOA,EAAQ3Q,GAGzB,OAAO2Q,EACF,GAAIxE,aAAgB2C,EAAM,CAC/B,MAAM+B,EAAKJ,EAActE,EAAKjL,IAAK+J,GAC7B6F,EAAKL,EAActE,EAAKvL,MAAOqK,GACrC,OAAOtG,KAAKoM,IAAIF,EAAIC,GAGtB,OAAO,GAGT,MAAMJ,UAAclL,EAClB,kBAAiB,MACf2B,EAAK,OACL0B,IACC,QACDoC,EAAO,IACPoE,EAAG,YACHY,EAAW,eACXX,IAEA,IAAI9H,EAASnH,OAAO2Q,KAAK/F,GAASgG,KAAKC,GAAKjG,EAAQiG,KAAOrI,GAE3D,IADKrB,GAAU8H,IAAgB9H,EAAS6H,EAAIpE,QAAQoF,QAAQxH,IAAWwG,EAAIpE,QAAQkG,WAC/E3J,EAAQ,MAAO,IAAIA,IAASyI,EAAc,IAAM,KACpD,MAAMmB,EAAM/B,EAAIpE,QAAQoF,QAAQxH,GAAU,uCAAyC,uCACnF,MAAM,IAAID,MAAM,GAAGwI,MAAQjK,MAG7B,YAAY0B,GACVE,QACA5D,KAAK0D,OAASA,EACd1D,KAAK6B,KAAOqC,EAAWnH,KAAKC,MAG9B,QAAQtB,GACN,MAAM,IAAI+H,MAAM,gCAGlB,OAAOiC,EAAK1B,GACV,IAAKA,EAAK,OAAOyB,EAAOzF,KAAK0D,OAAQgC,EAAK1B,GAC1C,MAAM,QACJ8B,EAAO,cACPoG,GACElI,EACE3B,EAASyD,EAAQzK,IAAI2E,KAAK0D,QAGhC,IAAKrB,QAAyB6E,IAAf7E,EAAO2D,IAAmB,CACvC,MAAMiG,EAAM,yDACZ,MAAIjM,KAAKmM,QAAe,IAAIjI,EAAWY,mBAAmB9E,KAAKmM,QAASF,GAAgB,IAAIG,eAAeH,GAG7G,GAAIC,GAAiB,IACnB7J,EAAOmJ,OAAS,EACU,IAAtBnJ,EAAOoJ,aAAkBpJ,EAAOoJ,WAAaH,EAActL,KAAK0D,OAAQoC,IAExEzD,EAAOmJ,MAAQnJ,EAAOoJ,WAAaS,GAAe,CACpD,MAAMD,EAAM,+DACZ,MAAIjM,KAAKmM,QAAe,IAAIjI,EAAWY,mBAAmB9E,KAAKmM,QAASF,GAAgB,IAAIG,eAAeH,GAI/G,OAAO5J,EAAO2D,IAKhB,SAAShC,GACP,OAAOuH,EAAMlD,UAAUrI,KAAMgE,IAOjC,SAASqI,EAAS7E,EAAOzL,GACvB,MAAMwK,EAAIxK,aAAeoK,EAASpK,EAAIN,MAAQM,EAE9C,IAAK,MAAMwN,KAAM/B,EACf,GAAI+B,aAAcI,EAAM,CACtB,GAAIJ,EAAGxN,MAAQA,GAAOwN,EAAGxN,MAAQwK,EAAG,OAAOgD,EAC3C,GAAIA,EAAGxN,KAAOwN,EAAGxN,IAAIN,QAAU8K,EAAG,OAAOgD,GAR/CrF,EAAWe,gBAAgBsG,EAAO,WAAW,GAc7C,MAAMe,UAAgBzF,EACpB,IAAIwD,EAAMkC,GACHlC,EAAuCA,aAAgBV,IAAOU,EAAO,IAAIV,EAAKU,EAAKtO,KAAOsO,EAAMA,EAAK5O,QAA/F4O,EAAO,IAAIV,EAAKU,GAC3B,MAAM1J,EAAO0L,EAASrM,KAAKwH,MAAO6C,EAAKtO,KACjCyQ,EAAcxM,KAAKqG,QAAUrG,KAAKqG,OAAOoG,eAE/C,GAAI9L,EAAM,CACR,IAAI4L,EAAwC,MAAM,IAAI9I,MAAM,OAAO4G,EAAKtO,mBAAzD4E,EAAKlF,MAAQ4O,EAAK5O,WAC5B,GAAI+Q,EAAa,CACtB,MAAMhS,EAAIwF,KAAKwH,MAAMkF,UAAU7D,GAAQ2D,EAAYnC,EAAMxB,GAAQ,IACtD,IAAPrO,EAAUwF,KAAKwH,MAAMnJ,KAAKgM,GAAWrK,KAAKwH,MAAM8B,OAAO9O,EAAG,EAAG6P,QAEjErK,KAAKwH,MAAMnJ,KAAKgM,GAIpB,OAAOtO,GACL,MAAMwN,EAAK8C,EAASrM,KAAKwH,MAAOzL,GAChC,IAAKwN,EAAI,OAAO,EAEhB,OADYvJ,KAAKwH,MAAM8B,OAAOtJ,KAAKwH,MAAMpJ,QAAQmL,GAAK,GAC3C1K,OAAS,EAGtB,IAAI9C,EAAKuL,GACP,MAAMiC,EAAK8C,EAASrM,KAAKwH,MAAOzL,GAC1BiL,EAAOuC,GAAMA,EAAG9N,MACtB,OAAQ6L,GAAcN,aAAgBb,EAASa,EAAKvL,MAAQuL,EAG9D,IAAIjL,GACF,QAASsQ,EAASrM,KAAKwH,MAAOzL,GAGhC,IAAIA,EAAKN,GACPuE,KAAK8G,IAAI,IAAI6C,EAAK5N,EAAKN,IAAQ,GAUjC,OAAOsH,EAAGiB,EAAKjH,GACb,MAAM4I,EAAM5I,EAAO,IAAIA,EAASiH,GAAOA,EAAIsG,SAAW,IAAIR,IAAQ,GAC9D9F,GAAOA,EAAI+B,UAAU/B,EAAI+B,SAASJ,GAEtC,IAAK,MAAMkD,KAAQ7I,KAAKwH,MAAOqB,EAAK0B,WAAWvG,EAAK2B,GAEpD,OAAOA,EAGT,SAAS3B,EAAKkE,EAAWC,GACvB,IAAKnE,EAAK,OAAO0F,KAAKrB,UAAUrI,MAEhC,IAAK,MAAM6I,KAAQ7I,KAAKwH,MACtB,KAAMqB,aAAgBc,GAAO,MAAM,IAAIlG,MAAM,sCAAsCiG,KAAKrB,UAAUQ,cAGpG,OAAOjF,MAAM6F,SAASzF,EAAK,CACzB8D,UAAW7L,GAAKA,EAAEqE,IAClByH,UAAW,CACTjJ,MAAO,IACPI,IAAK,KAEP8I,OAAO,EACPC,WAAYjE,EAAI9C,QAAU,IACzBgH,EAAWC,IAMlB,MAAMwE,UAAchD,EAClB,YAAYU,GACV,GAAIA,aAAgBV,EAAM,CACxB,IAAIH,EAAMa,EAAK5O,MAET+N,aAAeH,IACnBG,EAAM,IAAIH,EACVG,EAAIhC,MAAMnJ,KAAKgM,EAAK5O,OACpB+N,EAAIxH,MAAQqI,EAAK5O,MAAMuG,OAGzB4B,MAAMyG,EAAKtO,IAAKyN,GAChBxJ,KAAKgC,MAAQqI,EAAKrI,WAElB4B,MAAM,IAAIuC,EAfE,MAeiB,IAAIkD,GAGnCrJ,KAAK6B,KAAO8H,EAAK5M,KAAKsO,WAUxB,WAAWrH,EAAK2B,GACd,IAAK,MAAM,OACTjC,KACG1D,KAAKvE,MAAM+L,MAAO,CACrB,KAAM9D,aAAkB4I,GAAU,MAAM,IAAI7I,MAAM,8BAClD,MAAMmJ,EAASlJ,EAAO+B,OAAO,KAAMzB,EAAK8F,KAExC,IAAK,MAAO/N,EAAKN,KAAUmR,EACrBjH,aAAemE,IACZnE,EAAIgC,IAAI5L,IAAM4J,EAAIwB,IAAIpL,EAAKN,GACvBkK,aAAeoE,IACxBpE,EAAImB,IAAI/K,GAEHb,OAAOkB,UAAUC,eAAe1B,KAAKgL,EAAK5J,KAAM4J,EAAI5J,GAAON,GAKtE,OAAOkK,EAGT,SAAS3B,EAAKkE,GACZ,MAAMsB,EAAMxJ,KAAKvE,MACjB,GAAI+N,EAAIhC,MAAM3I,OAAS,EAAG,OAAO+E,MAAM6F,SAASzF,EAAKkE,GACrDlI,KAAKvE,MAAQ+N,EAAIhC,MAAM,GACvB,MAAMlH,EAAMsD,MAAM6F,SAASzF,EAAKkE,GAEhC,OADAlI,KAAKvE,MAAQ+N,EACNlJ,GAKX,MAAMuM,EAAgB,CACpBC,YAAa5I,EAAWnH,KAAKI,cAC7B4P,UAAW,IAYPC,EAAa,CACjBF,YAAa5I,EAAWnH,KAAKY,MAC7BsP,aAAc,CACZC,cAAc,EACdC,mBAAoB,IAEtBvL,KAAM,CACJmL,UAAW,GACXK,gBAAiB,KAIrB,SAASC,EAAc/M,EAAKgN,EAAMC,GAChC,IAAK,MAAM,OACTC,EAAM,KACNC,EAAI,QACJC,KACGJ,EACH,GAAIG,EAAM,CACR,MAAMvK,EAAQ5C,EAAI4C,MAAMuK,GAExB,GAAIvK,EAAO,CACT,IAAI8C,EAAM0H,EAAQC,MAAM,KAAMzK,GAG9B,OAFM8C,aAAeG,IAASH,EAAM,IAAIG,EAAOH,IAC3CwH,IAAQxH,EAAIwH,OAASA,GAClBxH,GAMb,OADIuH,IAAgBjN,EAAMiN,EAAejN,IAClC,IAAI6F,EAAO7F,GAGpB,MAKMsN,EAA2B,CAACC,EAAMrT,KACtC,IAAIuG,EAAK8M,EAAKrT,EAAI,GAElB,KAAc,MAAPuG,GAAqB,OAAPA,GAAa,CAChC,GACEA,EAAK8M,EAAKrT,GAAK,SACRuG,GAAa,OAAPA,GAEfA,EAAK8M,EAAKrT,EAAI,GAGhB,OAAOA,GAwBT,SAASsT,EAAcD,EAAM3M,EAAQvF,GAAM,cACzCsP,EAAa,UACb8B,EAAY,GAAE,gBACdK,EAAkB,GAAE,OACpBW,EAAM,WACNC,IAEA,IAAKjB,GAAaA,EAAY,EAAG,OAAOc,EACxC,MAAMI,EAAUzO,KAAKoM,IAAI,EAAIwB,EAAiB,EAAIL,EAAY7L,EAAOrC,QACrE,GAAIgP,EAAKhP,QAAUoP,EAAS,OAAOJ,EACnC,MAAMK,EAAQ,GACRC,EAAe,GACrB,IAWSpN,EAXL7B,EAAM6N,GAAsC,iBAAlB9B,EAA6BA,EAAgB/J,EAAOrC,QAC9EuP,OAAQlH,EACRvG,OAAOuG,EACPmH,GAAW,EACX7T,GAAK,EAOT,IA9DiB,UAyDbmB,IACFnB,EAAIoT,EAAyBC,EAAMrT,IACxB,IAAPA,IAAU0E,EAAM1E,EAAIyT,IAGblN,EAAK8M,EAAKrT,GAAK,IAAK,CAC/B,GA9DgB,WA8DZmB,GAA+B,OAAPoF,EAC1B,OAAQ8M,EAAKrT,EAAI,IACf,IAAK,IACHA,GAAK,EACL,MAEF,IAAK,IACHA,GAAK,EACL,MAEF,IAAK,IACHA,GAAK,EACL,MAEF,QACEA,GAAK,EAIX,GAAW,OAAPuG,EAlFW,UAmFTpF,IAAqBnB,EAAIoT,EAAyBC,EAAMrT,IAC5D0E,EAAM1E,EAAIyT,EACVG,OAAQlH,MACH,CACL,GAAW,MAAPnG,GAAcJ,GAAiB,MAATA,GAAyB,OAATA,GAA0B,OAATA,EAAe,CAExE,MAAMJ,EAAOsN,EAAKrT,EAAI,GAClB+F,GAAiB,MAATA,GAAyB,OAATA,GAA0B,OAATA,IAAe6N,EAAQ5T,GAGtE,GAAIA,GAAK0E,EACP,GAAIkP,EACFF,EAAM7P,KAAK+P,GACXlP,EAAMkP,EAAQH,EACdG,OAAQlH,OACH,GAjGK,WAiGDvL,EAAsB,CAE/B,KAAgB,MAATgF,GAAyB,OAATA,GACrBA,EAAOI,EACPA,EAAK8M,EAAKrT,GAAK,GACf6T,GAAW,EAIbH,EAAM7P,KAAK7D,EAAI,GACf2T,EAAa3T,EAAI,IAAK,EACtB0E,EAAM1E,EAAI,EAAIyT,EACdG,OAAQlH,OAERmH,GAAW,EAKjB1N,EAAOI,EAIT,GADIsN,GAAYL,GAAYA,IACP,IAAjBE,EAAMrP,OAAc,OAAOgP,EAC3BE,GAAQA,IACZ,IAAI/H,EAAM6H,EAAKzO,MAAM,EAAG8O,EAAM,IAE9B,IAAK,IAAI1T,EAAI,EAAGA,EAAI0T,EAAMrP,SAAUrE,EAAG,CACrC,MAAMoH,EAAOsM,EAAM1T,GACb0E,EAAMgP,EAAM1T,EAAI,IAAMqT,EAAKhP,OA9HjB,WA+HZlD,GAAwBwS,EAAavM,KAAOoE,GAAU6H,EAAKjM,GAAR,MACvDoE,GAAO,KAAK9E,IAAS2M,EAAKzO,MAAMwC,EAAO,EAAG1C,KAG5C,OAAO8G,EAGT,MAAMsI,EAAiB,EACrBrD,mBACIA,EAAgB/P,OAAOsN,OAAO,CAClCyC,iBACC+B,EAAWpL,MAAQoL,EAAWpL,KAI3B2M,EAAyBjO,GAAO,mBAAmBmN,KAAKnN,GAiB9D,SAASkO,EAAmB/S,EAAOuI,GACjC,MAAM,YACJ8G,GACE9G,GACE,aACJkJ,EAAY,mBACZC,GACEH,EAAWC,aACTwB,EAAO/E,KAAKrB,UAAU5M,GAC5B,GAAIyR,EAAc,OAAOuB,EACzB,MAAMvN,EAAS8C,EAAI9C,SAAWqN,EAAuB9S,GAAS,KAAO,IACrE,IAAI6E,EAAM,GACNxB,EAAQ,EAEZ,IAAK,IAAItE,EAAI,EAAGuG,EAAK0N,EAAKjU,GAAIuG,EAAIA,EAAK0N,IAAOjU,GAS5C,GARW,MAAPuG,GAA8B,OAAhB0N,EAAKjU,EAAI,IAA+B,MAAhBiU,EAAKjU,EAAI,KAEjD8F,GAAOmO,EAAKrP,MAAMN,EAAOtE,GAAK,MAC9BA,GAAK,EACLsE,EAAQtE,EACRuG,EAAK,MAGI,OAAPA,EAAa,OAAQ0N,EAAKjU,EAAI,IAChC,IAAK,IACH,CACE8F,GAAOmO,EAAKrP,MAAMN,EAAOtE,GACzB,MAAMkU,EAAOD,EAAKnP,OAAO9E,EAAI,EAAG,GAEhC,OAAQkU,GACN,IAAK,OACHpO,GAAO,MACP,MAEF,IAAK,OACHA,GAAO,MACP,MAEF,IAAK,OACHA,GAAO,MACP,MAEF,IAAK,OACHA,GAAO,MACP,MAEF,IAAK,OACHA,GAAO,MACP,MAEF,IAAK,OACHA,GAAO,MACP,MAEF,IAAK,OACHA,GAAO,MACP,MAEF,IAAK,OACHA,GAAO,MACP,MAEF,QAC4B,OAAtBoO,EAAKpP,OAAO,EAAG,GAAagB,GAAO,MAAQoO,EAAKpP,OAAO,GAAQgB,GAAOmO,EAAKnP,OAAO9E,EAAG,GAG7FA,GAAK,EACLsE,EAAQtE,EAAI,EAEd,MAEF,IAAK,IACH,GAAIsQ,GAA+B,MAAhB2D,EAAKjU,EAAI,IAAciU,EAAK5P,OAASsO,EACtD3S,GAAK,MACA,CAIL,IAFA8F,GAAOmO,EAAKrP,MAAMN,EAAOtE,GAAK,OAEP,OAAhBiU,EAAKjU,EAAI,IAA+B,MAAhBiU,EAAKjU,EAAI,IAA8B,MAAhBiU,EAAKjU,EAAI,IAC7D8F,GAAO,KACP9F,GAAK,EAGP8F,GAAOY,EAEa,MAAhBuN,EAAKjU,EAAI,KAAY8F,GAAO,MAChC9F,GAAK,EACLsE,EAAQtE,EAAI,EAGd,MAEF,QACEA,GAAK,EAKX,OADA8F,EAAMxB,EAAQwB,EAAMmO,EAAKrP,MAAMN,GAAS2P,EACjC3D,EAAcxK,EAAMwN,EAAcxN,EAAKY,EAjQ5B,SAiQiDoN,EAAetK,IAGpF,SAAS2K,EAAmBlT,EAAOuI,GACjC,GAAIA,EAAI8G,aACN,GAAI,KAAK2C,KAAKhS,GAAQ,OAAO+S,EAAmB/S,EAAOuI,QAGvD,GAAI,kBAAkByJ,KAAKhS,GAAQ,OAAO+S,EAAmB/S,EAAOuI,GAGtE,MAAM9C,EAAS8C,EAAI9C,SAAWqN,EAAuB9S,GAAS,KAAO,IAC/DuK,EAAM,IAAMvK,EAAM+J,QAAQ,KAAM,MAAMA,QAAQ,OAAQ,OAAOtE,GAAY,IAC/E,OAAO8C,EAAI8G,YAAc9E,EAAM8H,EAAc9H,EAAK9E,EAhRlC,OAgRqDoN,EAAetK,IAGtF,SAAS4K,GAAY,QACnBpM,EAAO,KACPX,EAAI,MACJpG,GACCuI,EAAKkE,EAAWC,GAGjB,GAAI,YAAYsF,KAAKhS,IAAU,QAAQgS,KAAKhS,GAC1C,OAAO+S,EAAmB/S,EAAOuI,GAGnC,MAAM9C,EAAS8C,EAAI9C,SAAW8C,EAAI6K,kBAAoBN,EAAuB9S,GAAS,KAAO,IACvF+O,EAAatJ,EAAS,IAAM,IAE5B4N,EAAUjN,IAASqC,EAAWnH,KAAKG,eAAuB2E,IAASqC,EAAWnH,KAAKI,gBA/I3F,SAA6BmD,EAAKyO,GAChC,MAAMC,EAAS1O,EAAIzB,OACnB,GAAImQ,GAAUD,EAAO,OAAO,EAE5B,IAAK,IAAIvU,EAAI,EAAGsE,EAAQ,EAAGtE,EAAIwU,IAAUxU,EACvC,GAAe,OAAX8F,EAAI9F,GAAa,CACnB,GAAIA,EAAIsE,EAAQiQ,EAAO,OAAO,EAE9B,GADAjQ,EAAQtE,EAAI,EACRwU,EAASlQ,GAASiQ,EAAO,OAAO,EAIxC,OAAO,EAmI0GE,CAAoBxT,EAAOuR,EAAWpL,KAAKmL,UAAY7L,EAAOrC,SAC/K,IAAI6D,EAASoM,EAAU,IAAM,IAC7B,IAAKrT,EAAO,OAAOiH,EAAS,KAC5B,IAAI2B,EAAU,GACV/C,EAAQ,GAkCZ,GAjCA7F,EAAQA,EAAM+J,QAAQ,YAAa4F,IACjC,MAAMnP,EAAImP,EAAGhN,QAAQ,MAWrB,OATW,IAAPnC,EACFyG,GAAU,IACDjH,IAAU2P,GAAMnP,IAAMmP,EAAGvM,OAAS,IAC3C6D,GAAU,IAENyF,GAAaA,KAGnB7G,EAAQ8J,EAAG5F,QAAQ,MAAO,IACnB,KACNA,QAAQ,UAAW4F,KACK,IAArBA,EAAGhN,QAAQ,OAAasE,GAAU8H,GACtC,MAAM5P,EAAIwQ,EAAGlI,MAAM,OAEnB,OAAItI,GACFyJ,EAAU+G,EAAGhM,MAAM,GAAIxE,EAAE,GAAGiE,QACrBjE,EAAE,KAETyJ,EAAU+G,EACH,MAGP9J,IAAOA,EAAQA,EAAMkE,QAAQ,eAAgB,KAAKtE,IAClDmD,IAASA,EAAUA,EAAQmB,QAAQ,OAAQ,KAAKtE,IAEhDsB,IACFE,GAAU,KAAOF,EAAQgD,QAAQ,aAAc,KAC3C0C,GAAWA,MAGZzM,EAAO,MAAO,GAAGiH,IAAS8H,MAAetJ,IAASI,IAEvD,GAAIwN,EAEF,OADArT,EAAQA,EAAM+J,QAAQ,OAAQ,KAAKtE,GAC5B,GAAGwB,MAAWxB,IAASmD,IAAU5I,IAAQ6F,IAGlD7F,EAAQA,EAAM+J,QAAQ,OAAQ,QAAQA,QAAQ,iDAAkD,QAE/FA,QAAQ,OAAQ,KAAKtE,GACtB,MAAMgO,EAAOpB,EAAc,GAAGzJ,IAAU5I,IAAQ6F,IAASJ,EAhVxC,QAgV4D8L,EAAWpL,MACxF,MAAO,GAAGc,MAAWxB,IAASgO,IAkJhC,SAASC,EAAuB7K,EAAQ/F,GACtC,IAAI6Q,EAAMrU,EAkBNsU,EAhBJ,OAAQ9Q,EAAIsD,MACV,KAAKqC,EAAWnH,KAAKO,SACnB8R,EAAO,IACPrU,EAAO,WACP,MAEF,KAAKmJ,EAAWnH,KAAKQ,SACnB6R,EAAO,IACPrU,EAAO,gBACP,MAEF,QAEE,YADAuJ,EAAOjG,KAAK,IAAI6F,EAAWD,kBAAkB1F,EAAK,4BAMtD,IAAK,IAAI/D,EAAI+D,EAAIiJ,MAAM3I,OAAS,EAAGrE,GAAK,IAAKA,EAAG,CAC9C,MAAMqO,EAAOtK,EAAIiJ,MAAMhN,GAEvB,IAAKqO,GAAQA,EAAKhH,OAASqC,EAAWnH,KAAKJ,QAAS,CAClD0S,EAAWxG,EACX,OAIJ,GAAIwG,GAAYA,EAASD,OAASA,EAAM,CACtC,MAAMnD,EAAM,YAAYlR,iBAAoBqU,IAC5C,IAAIE,EAE2B,iBAApBD,EAASlR,QAClBmR,EAAM,IAAIpL,EAAWD,kBAAkB1F,EAAK0N,GAC5CqD,EAAInR,OAASkR,EAASlR,OAAS,IAE/BmR,EAAM,IAAIpL,EAAWD,kBAAkBoL,EAAUpD,GAC7CoD,EAASrN,OAASqN,EAASrN,MAAM9C,MAAKoQ,EAAInR,OAASkR,EAASrN,MAAM9C,IAAMmQ,EAASrN,MAAMlD,QAG7FwF,EAAOjG,KAAKiR,IAGhB,SAASC,EAAsBjL,EAAQ9B,GACrC,MAAM7B,EAAO6B,EAAQ7D,QAAQV,IAAIuE,EAAQR,MAAMlD,MAAQ,GAEvD,GAAa,OAAT6B,GAA0B,OAATA,GAA0B,MAATA,EAAc,CAClD,MAAMsL,EAAM,yEACZ3H,EAAOjG,KAAK,IAAI6F,EAAWD,kBAAkBzB,EAASyJ,KAG1D,SAASuD,EAAgB9L,EAAQ3H,GAC/B,MAAM0T,EAAK5J,OAAO9J,GACZwK,EAAIkJ,EAAGnQ,OAAO,EAAG,GAAK,MAAQmQ,EAAGnQ,QAAQ,GAC/C,OAAO,IAAI4E,EAAWD,kBAAkBP,EAAQ,QAAQ6C,sBAE1D,SAASmJ,EAAgBC,EAAYpN,GACnC,IAAK,MAAM,SACTqN,EAAQ,OACRC,EAAM,QACNrN,KACGD,EAAU,CACb,IAAIsG,EAAO8G,EAAWnI,MAAMqI,GAEvBhH,GAKC+G,GAAY/G,EAAKpN,QAAOoN,EAAOA,EAAKpN,YAExByL,IAAZ1E,GACEoN,GAAa/G,EAAKnB,gBAAemB,EAAKC,aAAc,GAEpDD,EAAKnB,cAAemB,EAAKnB,eAAiB,KAAOlF,EAAaqG,EAAKnB,cAAgBlF,QATzE0E,IAAZ1E,IACEmN,EAAWnN,QAASmN,EAAWnN,SAAW,KAAOA,EAAamN,EAAWnN,QAAUA,IAe/F,SAASsN,EAAc5F,EAAKlD,GAC1B,MAAMhB,EAAMgB,EAAK+I,SACjB,OAAK/J,EACc,iBAARA,EAAyBA,GACpCA,EAAI1B,OAAOhB,QAAQ3B,IACZA,EAAM+B,SAAQ/B,EAAM+B,OAASsD,GAClCkD,EAAI5F,OAAOjG,KAAKsD,KAEXqE,EAAI1F,KANM,GAwCnB,SAAS0P,EAAe9F,EAAKlD,GAC3B,MAAM,IACJnE,EAAG,KACHhB,GACEmF,EACJ,IAAIiJ,GAAc,EAElB,GAAIpN,EAAK,CACP,MAAM,OACJG,EAAM,OACNC,EAAM,SACNH,GACED,EAEJ,GAAIC,EAAU,CACZ,GAAiB,MAAbA,GAAiC,OAAbA,EAAmB,OAAOA,EAClD,MAAMmJ,EAAM,qCAAqCnJ,gBACjDoH,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWD,kBAAkB+C,EAAMiF,SAClD,GAAe,MAAXjJ,GAAmBC,EAG5B,IACE,OArDR,SAA0BiH,EAAKlD,GAC7B,MAAM,OACJhE,EAAM,OACNC,GACE+D,EAAKnE,IACT,IAAIqN,EAAShG,EAAIiG,YAAYrE,KAAKxP,GAAKA,EAAE0G,SAAWA,GAEpD,IAAKkN,EAAQ,CACX,MAAME,EAAMlG,EAAImG,cAAcF,YAE9B,GADIC,IAAKF,EAASE,EAAItE,KAAKxP,GAAKA,EAAE0G,SAAWA,KACxCkN,EAAQ,MAAM,IAAIhM,EAAWD,kBAAkB+C,EAAM,OAAOhE,qDAGnE,IAAKC,EAAQ,MAAM,IAAIiB,EAAWD,kBAAkB+C,EAAM,OAAOhE,wBAEjE,GAAe,MAAXA,GAA2D,SAAxCkH,EAAIoG,SAAWpG,EAAIS,QAAQ2F,SAAoB,CACpE,GAAkB,MAAdrN,EAAO,GAET,OADAiH,EAAIqG,SAASlS,KAAK,IAAI6F,EAAWc,YAAYgC,EAAM,8CAC5C/D,EAGT,GAAI,OAAOwK,KAAKxK,GAAS,CAEvB,MAAMuN,EAAQvN,EAAOC,MAAM,wBAC3B,OAAOsN,EAAQ,OAAOA,EAAM,oBAAoBA,EAAM,KAAO,OAAOvN,GAIxE,OAAOiN,EAAOA,OAASO,mBAAmBxN,GAyB7ByN,CAAiBxG,EAAKlD,GAC7B,MAAOrF,GACPuI,EAAI5F,OAAOjG,KAAKsD,QALlBsO,GAAc,EAUlB,OAAQpO,GACN,KAAKqC,EAAWnH,KAAKG,aACrB,KAAKgH,EAAWnH,KAAKI,cACrB,KAAK+G,EAAWnH,KAAKa,aACrB,KAAKsG,EAAWnH,KAAKc,aACnB,OAAOqG,EAAWmB,YAAYC,IAEhC,KAAKpB,EAAWnH,KAAKO,SACrB,KAAK4G,EAAWnH,KAAKS,IACnB,OAAO0G,EAAWmB,YAAY7H,IAEhC,KAAK0G,EAAWnH,KAAKQ,SACrB,KAAK2G,EAAWnH,KAAKe,IACnB,OAAOoG,EAAWmB,YAAYvH,IAEhC,KAAKoG,EAAWnH,KAAKY,MACnB,OAAOsS,EAAc/L,EAAWmB,YAAYC,IAAM,KAEpD,QACE,OAAO,MAIb,SAASqL,EAAiBzG,EAAKlD,EAAM4J,GACnC,MAAM,KACJtD,GACEpD,EAAI7D,OACFwK,EAAgB,GAEtB,IAAK,MAAMhO,KAAOyK,EAChB,GAAIzK,EAAIA,MAAQ+N,EAAS,CACvB,IAAI/N,EAAI4K,KAAmC,CACzC,MAAMzH,EAAMnD,EAAI6K,QAAQxD,EAAKlD,GAC7B,OAAOhB,aAAea,EAAab,EAAM,IAAIG,EAAOH,GAFxC6K,EAAcxS,KAAKwE,GAOrC,MAAMvC,EAAMwP,EAAc5F,EAAKlD,GAC/B,MAAmB,iBAAR1G,GAAoBuQ,EAAchS,OAAS,EAAUwO,EAAc/M,EAAKuQ,EAAevD,EAAKC,gBAChG,KAoBT,SAASuD,EAAW5G,EAAKlD,EAAM4J,GAC7B,IACE,MAAM5K,EAAM2K,EAAiBzG,EAAKlD,EAAM4J,GAExC,GAAI5K,EAEF,OADI4K,GAAW5J,EAAKnE,MAAKmD,EAAInD,IAAM+N,GAC5B5K,EAET,MAAOrE,GAIP,OAFKA,EAAM+B,SAAQ/B,EAAM+B,OAASsD,GAClCkD,EAAI5F,OAAOjG,KAAKsD,GACT,KAGT,IACE,MAAMoP,EAjCV,UAA4B,KAC1BlP,IAEA,OAAQA,GACN,KAAKqC,EAAWnH,KAAKO,SACrB,KAAK4G,EAAWnH,KAAKS,IACnB,OAAO0G,EAAWmB,YAAY7H,IAEhC,KAAK0G,EAAWnH,KAAKQ,SACrB,KAAK2G,EAAWnH,KAAKe,IACnB,OAAOoG,EAAWmB,YAAYvH,IAEhC,QACE,OAAOoG,EAAWmB,YAAYC,KAoBf0L,CAAmBhK,GACpC,IAAK+J,EAAU,MAAM,IAAItN,MAAM,WAAWmN,oBAC1C,MAAM3E,EAAM,WAAW2E,qCAA2CG,IAClE7G,EAAIqG,SAASlS,KAAK,IAAI6F,EAAWc,YAAYgC,EAAMiF,IACnD,MAAMjG,EAAM2K,EAAiBzG,EAAKlD,EAAM+J,GAExC,OADA/K,EAAInD,IAAM+N,EACH5K,EACP,MAAOrE,GACP,MAAMsP,EAAW,IAAI/M,EAAWY,mBAAmBkC,EAAMrF,EAAMgC,SAG/D,OAFAsN,EAASC,MAAQvP,EAAMuP,MACvBhH,EAAI5F,OAAOjG,KAAK4S,GACT,MAYX,SAASE,EAAiB7M,EAAQ0C,GAChC,MAAMzE,EAAW,CACfsN,OAAQ,GACRuB,MAAO,IAET,IAAIC,GAAY,EACZC,GAAS,EACb,MAAMxP,EAfiBkF,KACvB,IAAKA,EAAM,OAAO,EAClB,MAAM,KACJnF,GACEmF,EACJ,OAAOnF,IAASqC,EAAWnH,KAAKU,SAAWoE,IAASqC,EAAWnH,KAAKW,WAAamE,IAASqC,EAAWnH,KAAKgB,UAU5FwT,CAAiBvK,EAAKrI,QAAQ6S,QAAUxK,EAAKrI,QAAQ6S,OAAO1P,MAAM2P,OAAOzK,EAAKlF,OAASkF,EAAKlF,MAE1G,IAAK,MAAM,MACThD,EAAK,IACLI,KACG4C,EACH,OAAQkF,EAAKrI,QAAQV,IAAIa,IACvB,KAAKoF,EAAWzH,KAAKE,QACnB,CACE,IAAKqK,EAAK0K,6BAA6B5S,GAAQ,CAC7C,MAAMmN,EAAM,yEACZ3H,EAAOjG,KAAK,IAAI6F,EAAWD,kBAAkB+C,EAAMiF,IAGrD,MAAM,OACJvJ,EAAM,WACNT,GACE+E,GACO/E,IAAenD,EAAQmD,EAAWnD,OAAS4D,GAAU5D,EAAQ4D,EAAO5D,OAASyD,EAAS6O,MAAQ7O,EAASsN,QAC/GxR,KAAK2I,EAAKrI,QAAQV,IAAImB,MAAMN,EAAQ,EAAGI,IAC1C,MAIJ,KAAKgF,EAAWzH,KAAKC,OACnB,GAAI2U,EAAW,CACb,MAAMpF,EAAM,qCACZ3H,EAAOjG,KAAK,IAAI6F,EAAWD,kBAAkB+C,EAAMiF,IAGrDoF,GAAY,EACZ,MAEF,KAAKnN,EAAWzH,KAAKG,IACnB,GAAI0U,EAAQ,CACV,MAAMrF,EAAM,kCACZ3H,EAAOjG,KAAK,IAAI6F,EAAWD,kBAAkB+C,EAAMiF,IAGrDqF,GAAS,EAKf,MAAO,CACL/O,WACA8O,YACAC,UAiDJ,SAASK,EAAYzH,EAAKlD,GACxB,IAAKA,EAAM,OAAO,KACdA,EAAKrF,OAAOuI,EAAI5F,OAAOjG,KAAK2I,EAAKrF,OACrC,MAAM,SACJY,EAAQ,UACR8O,EAAS,OACTC,GACEH,EAAiBjH,EAAI5F,OAAQ0C,GAEjC,GAAIqK,EAAW,CACb,MAAM,QACJvL,GACEoE,EACEnP,EAAOiM,EAAK3E,OACZ1B,EAAOmF,EAAQ8L,QAAQ7W,GAGzB4F,IAAMmF,EAAQH,IAAIG,EAAQkG,QAAQjR,IAAS4F,GAI/CmF,EAAQH,IAAI5K,GAAQiM,EAGtB,GAAIA,EAAKnF,OAASqC,EAAWnH,KAAKC,QAAUqU,GAAaC,GAAS,CAChE,MAAMrF,EAAM,gDACZ/B,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWD,kBAAkB+C,EAAMiF,IAGzD,MAAMjG,EA1ER,SAA0BkE,EAAKlD,GAC7B,MAAM,QACJlB,EAAO,OACPxB,EAAM,OACN+B,GACE6D,EAEJ,GAAIlD,EAAKnF,OAASqC,EAAWnH,KAAKC,MAAO,CACvC,MAAMjC,EAAOiM,EAAK6K,SACZ5T,EAAM6H,EAAQ8L,QAAQ7W,GAE5B,IAAKkD,EAAK,CACR,MAAMgO,EAAM,6BAA6BlR,EAEzC,OADAuJ,EAAOjG,KAAK,IAAI6F,EAAWY,mBAAmBkC,EAAMiF,IAC7C,KAIT,MAAMjG,EAAM,IAAIuF,EAAMtN,GAItB,OAFA6H,EAAQgM,YAAYzT,KAAK2H,GAElBA,EAGT,MAAM4K,EAAUZ,EAAe9F,EAAKlD,GACpC,GAAI4J,EAAS,OAAOE,EAAW5G,EAAKlD,EAAM4J,GAE1C,GAAI5J,EAAKnF,OAASqC,EAAWnH,KAAKY,MAAO,CACvC,MAAMsO,EAAM,qBAAqBjF,EAAKnF,iBAEtC,OADAyC,EAAOjG,KAAK,IAAI6F,EAAWa,gBAAgBiC,EAAMiF,IAC1C,KAGT,IAEE,OAAOoB,EADKyC,EAAc5F,EAAKlD,GACLX,EAAOiH,KAAMjH,EAAOiH,KAAKC,gBACnD,MAAO5L,GAGP,OAFKA,EAAM+B,SAAQ/B,EAAM+B,OAASsD,GAClC1C,EAAOjG,KAAKsD,GACL,MAkCGoQ,CAAiB7H,EAAKlD,GAElC,GAAIhB,EAAK,CACPA,EAAIhE,MAAQ,CAACgF,EAAKhF,MAAMlD,MAAOkI,EAAKhF,MAAM9C,KACtCgL,EAAIS,QAAQqH,eAAchM,EAAImG,QAAUnF,GACxCkD,EAAIS,QAAQsH,gBAAejM,EAAInE,KAAOmF,EAAKnF,MAC/C,MAAMgI,EAAKtH,EAASsN,OAAOpN,KAAK,MAE5BoH,IACF7D,EAAI0B,cAAgB1B,EAAI0B,cAAgB,GAAG1B,EAAI0B,kBAAkBmC,IAAOA,GAG1E,MAAMqI,EAAK3P,EAAS6O,MAAM3O,KAAK,MAC3ByP,IAAIlM,EAAIxD,QAAUwD,EAAIxD,QAAU,GAAGwD,EAAIxD,YAAY0P,IAAOA,GAGhE,OAAOlL,EAAKmL,SAAWnM,EAuFzB,SAASoM,EAAmBvJ,EAAMwB,GAChC,IArB0B,GAC1B1L,SACEwC,YACA6F,OACA/I,OAEF6D,YAEA,GAAqB,IAAjBA,EAAMjD,OAAc,OAAO,EAC/B,MAAM,MACJC,GACEgD,EAAM,GACV,GAAIkF,GAAQlI,EAAQkI,EAAK/E,WAAWnD,MAAO,OAAO,EAClD,GAAIb,EAAIa,KAAWoF,EAAWzH,KAAKE,QAAS,OAAO,EAEnD,IAAK,IAAInC,EAAI2G,EAAW3G,EAAIsE,IAAStE,EAAG,GAAe,OAAXyD,EAAIzD,GAAa,OAAO,EAEpE,OAAO,GAIF6X,CAAoBxJ,GAAO,OAChC,MAAMrG,EAAUqG,EAAKvG,aAAa,EAAG4B,EAAWzH,KAAKE,SAAS,GAC9D,IAAI2V,GAAQ,EACZ,MAAMzI,EAAKQ,EAAK5O,MAAMiM,cAEtB,GAAImC,GAAMA,EAAG0I,WAAW/P,GACtB6H,EAAK5O,MAAMiM,cAAgBmC,EAAGvK,OAAOkD,EAAQ3D,OAAS,GACtDyT,GAAQ,MACH,CACL,MAAME,EAAKnI,EAAK5O,MAAM+G,SAEjBqG,EAAK7B,MAAQwL,GAAMA,EAAGD,WAAW/P,KACpC6H,EAAK5O,MAAM+G,QAAUgQ,EAAGlT,OAAOkD,EAAQ3D,OAAS,GAChDyT,GAAQ,GAIRA,IAAOjI,EAAK7H,QAAUA,GAqY5BlI,EAAQiR,MAAQA,EAChBjR,EAAQuM,WAAaA,EACrBvM,EAAQqS,MAAQA,EAChBrS,EAAQ+F,KAAOA,EACf/F,EAAQqP,KAAOA,EACfrP,EAAQ6L,OAASA,EACjB7L,EAAQgS,QAAUA,EAClBhS,EAAQ+O,QAAUA,EAClB/O,EAAQiL,WAAaA,EACrBjL,EAAQuS,cAAgBA,EACxBvS,EAAQmY,YAz5CY,CAClBC,QAAS,OACTC,SAAU,SAw5CZrY,EAAQ+R,SAAWA,EACnB/R,EAAQsY,WAv5CW,CACjBC,UAAU,GAu5CZvY,EAAQoM,YAAcA,EACtBpM,EAAQwY,YAt5CY,CAClBC,QAAS,QAs5CXzY,EAAQ0Y,WA1fR,SAAoB9I,EAAK3L,GACvB,GAAIA,EAAIsD,OAASqC,EAAWnH,KAAKS,KAAOe,EAAIsD,OAASqC,EAAWnH,KAAKO,SAAU,CAC7E,MAAM2O,EAAM,KAAK1N,EAAIsD,4CAErB,OADAqI,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWa,gBAAgBxG,EAAK0N,IAC7C,KAGT,MAAM,SACJ1J,EAAQ,MACRiF,GACEjJ,EAAIsD,OAASqC,EAAWnH,KAAKO,SA2NnC,SAA6B4M,EAAK3L,GAChC,MAAMgE,EAAW,GACXiF,EAAQ,GACd,IAAIzL,OAAMmL,EACN2D,GAAc,EACdtK,EAAO,IAEX,IAAK,IAAI/F,EAAI,EAAGA,EAAI+D,EAAIiJ,MAAM3I,SAAUrE,EAAG,CACzC,MAAMqO,EAAOtK,EAAIiJ,MAAMhN,GAEvB,GAAyB,iBAAdqO,EAAKuG,KAAmB,CACjC,MAAM,KACJA,EAAI,OACJjR,GACE0K,EAEJ,GAAa,MAATuG,QAAwBlI,IAARnL,IAAsB8O,EAAa,CACrDA,GAAc,EACdtK,EAAO,IACP,SAGF,GAAa,MAAT6O,GAGF,QAFYlI,IAARnL,IAAmBA,EAAM,MAEhB,MAATwE,EAAc,CAChBA,EAAO,IACP,eAQF,GALIsK,SACU3D,IAARnL,GAA8B,MAATqT,IAAcrT,EAAM,MAC7C8O,GAAc,QAGJ3D,IAARnL,IACFyL,EAAMnJ,KAAK,IAAIsL,EAAK5N,IACpBA,OAAMmL,EAEO,MAATkI,GAAc,CAChB7O,EAAO,IACP,SAKN,GAAa,MAAT6O,GACF,GAAI5U,IAAM+D,EAAIiJ,MAAM3I,OAAS,EAAG,cAC3B,GAAIuQ,IAAS7O,EAAM,CACxBA,EAAO,IACP,SAGF,MAAM0L,EAAM,mCAAmCmD,EACzCE,EAAM,IAAIpL,EAAWa,gBAAgBxG,EAAK0N,GAChDqD,EAAInR,OAASA,EACb+L,EAAI5F,OAAOjG,KAAKiR,QACPzG,EAAKhH,OAASqC,EAAWnH,KAAKE,WACvCsF,EAASlE,KAAK,CACZuR,WAAY7T,EACZ8T,OAAQrI,EAAM3I,SAEPgK,EAAKhH,OAASqC,EAAWnH,KAAKJ,SACvC4S,EAAsBrF,EAAI5F,OAAQuE,GAClCtG,EAASlE,KAAK,CACZuR,WAAY7T,EACZ8T,OAAQrI,EAAM3I,OACd2D,QAASqG,EAAKrG,gBAEC0E,IAARnL,GACI,MAATwE,GAAc2J,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWD,kBAAkB4E,EAAM,oCACzE9M,EAAM4V,EAAYzH,EAAKrB,KAEV,MAATtI,GAAc2J,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWD,kBAAkB4E,EAAM,0CACzErB,EAAMnJ,KAAK,IAAIsL,EAAK5N,EAAK4V,EAAYzH,EAAKrB,KAC1C9M,OAAMmL,EACN2D,GAAc,GAIlBsE,EAAuBjF,EAAI5F,OAAQ/F,QACvB2I,IAARnL,GAAmByL,EAAMnJ,KAAK,IAAIsL,EAAK5N,IAC3C,MAAO,CACLwG,WACAiF,SA/S0CyL,CAAoB/I,EAAK3L,GA+FvE,SAA8B2L,EAAK3L,GACjC,MAAMgE,EAAW,GACXiF,EAAQ,GACd,IAAIzL,OAAMmL,EACNgM,EAAW,KAEf,IAAK,IAAI1Y,EAAI,EAAGA,EAAI+D,EAAIiJ,MAAM3I,SAAUrE,EAAG,CACzC,MAAMqO,EAAOtK,EAAIiJ,MAAMhN,GAEvB,OAAQqO,EAAKhH,MACX,KAAKqC,EAAWnH,KAAKE,WACnBsF,EAASlE,KAAK,CACZuR,WAAY7T,EACZ8T,OAAQrI,EAAM3I,SAEhB,MAEF,KAAKqF,EAAWnH,KAAKJ,QACnB4F,EAASlE,KAAK,CACZuR,WAAY7T,EACZ8T,OAAQrI,EAAM3I,OACd2D,QAASqG,EAAKrG,UAEhB,MAEF,KAAK0B,EAAWnH,KAAKU,aACPyJ,IAARnL,GAAmByL,EAAMnJ,KAAK,IAAIsL,EAAK5N,IACvC8M,EAAKlH,OAAOuI,EAAI5F,OAAOjG,KAAKwK,EAAKlH,OACrC5F,EAAM4V,EAAYzH,EAAKrB,EAAK7B,MAC5BkM,EAAW,KACX,MAEF,KAAKhP,EAAWnH,KAAKW,UACnB,CAIE,QAHYwJ,IAARnL,IAAmBA,EAAM,MACzB8M,EAAKlH,OAAOuI,EAAI5F,OAAOjG,KAAKwK,EAAKlH,QAEhCkH,EAAKlK,QAAQwU,aAAetK,EAAK7B,MAAQ6B,EAAK7B,KAAKnF,OAASqC,EAAWnH,KAAKS,MAAQqL,EAAK7B,KAAKrI,QAAQwU,YAAa,CACtH,MAAMlH,EAAM,sDACZ/B,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWD,kBAAkB4E,EAAK7B,KAAMiF,IAG9D,IAAImH,EAAYvK,EAAK7B,KAErB,IAAKoM,GAAavK,EAAK/G,MAAMjD,OAAS,EAAG,CAIvCuU,EAAY,IAAIlP,EAAWA,WAAWA,EAAWnH,KAAKY,MAAO,IAC7DyV,EAAUzU,QAAU,CAClB6S,OAAQ3I,EACR5K,IAAK4K,EAAKlK,QAAQV,KAEpB,MAAMoV,EAAMxK,EAAK7G,MAAMlD,MAAQ,EAU/B,GATAsU,EAAUpR,MAAQ,CAChBlD,MAAOuU,EACPnU,IAAKmU,GAEPD,EAAUnR,WAAa,CACrBnD,MAAOuU,EACPnU,IAAKmU,GAG6B,iBAAzBxK,EAAK7G,MAAM9B,UAAwB,CAC5C,MAAMoT,EAAUzK,EAAK7G,MAAM9B,UAAY,EACvCkT,EAAUpR,MAAM9B,UAAYkT,EAAUpR,MAAM7B,QAAUmT,EACtDF,EAAUnR,WAAW/B,UAAYkT,EAAUnR,WAAW9B,QAAUmT,GAIpE,MAAMjJ,EAAO,IAAIV,EAAK5N,EAAK4V,EAAYzH,EAAKkJ,IAC5ChB,EAAmBvJ,EAAMwB,GACzB7C,EAAMnJ,KAAKgM,GAEPtO,GAA2B,iBAAbmX,GACZrK,EAAK7G,MAAMlD,MAAQoU,EAAW,MAAMhJ,EAAI5F,OAAOjG,KAAKmR,EAAgBjR,EAAKxC,IAG/EA,OAAMmL,EACNgM,EAAW,KAEb,MAEF,aACchM,IAARnL,GAAmByL,EAAMnJ,KAAK,IAAIsL,EAAK5N,IAC3CA,EAAM4V,EAAYzH,EAAKrB,GACvBqK,EAAWrK,EAAK7G,MAAMlD,MAClB+J,EAAKlH,OAAOuI,EAAI5F,OAAOjG,KAAKwK,EAAKlH,OAErCpB,EAAM,IAAK,IAAIgT,EAAI/Y,EAAI,KAAM+Y,EAAG,CAC9B,MAAMC,EAAWjV,EAAIiJ,MAAM+L,GAE3B,OAAQC,GAAYA,EAAS3R,MAC3B,KAAKqC,EAAWnH,KAAKE,WACrB,KAAKiH,EAAWnH,KAAKJ,QACnB,SAAS4D,EAEX,KAAK2D,EAAWnH,KAAKW,UACnB,MAAM6C,EAER,QACE,CACE,MAAM0L,EAAM,sDACZ/B,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWD,kBAAkB4E,EAAMoD,IACvD,MAAM1L,IAKd,GAAIsI,EAAK4K,0BAA2B,CAClC,MAAMxH,EAAM,gDACZ/B,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWD,kBAAkB4E,EAAMoD,WAMnD/E,IAARnL,GAAmByL,EAAMnJ,KAAK,IAAIsL,EAAK5N,IAC3C,MAAO,CACLwG,WACAiF,SAvN0EkM,CAAqBxJ,EAAK3L,GAChGoH,EAAM,IAAI2G,EAChB3G,EAAI6B,MAAQA,EACZkI,EAAgB/J,EAAKpD,GACrB,IAAIoR,GAAmB,EAEvB,IAAK,IAAInZ,EAAI,EAAGA,EAAIgN,EAAM3I,SAAUrE,EAAG,CACrC,MACEuB,IAAK6X,GACHpM,EAAMhN,GAGV,GAFIoZ,aAAgB/M,IAAY8M,GAAmB,GAE/CzJ,EAAI7D,OAAOwN,OAASD,GA1/BV,OA0/BkBA,EAAKnY,MAAqB,CACxD+L,EAAMhN,GAAK,IAAImS,EAAMnF,EAAMhN,IAC3B,MAAMsZ,EAAUtM,EAAMhN,GAAGiB,MAAM+L,MAC/B,IAAI7F,EAAQ,KACZmS,EAAQC,KAAK/M,IACX,GAAIA,aAAgBuE,EAAO,CAGzB,MAAM,KACJ1J,GACEmF,EAAKtD,OACT,OAAI7B,IAASqC,EAAWnH,KAAKS,KAAOqE,IAASqC,EAAWnH,KAAKO,WACtDqE,EAAQ,8CAGjB,OAAOA,EAAQ,oDAEbA,GAAOuI,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWD,kBAAkB1F,EAAKoD,SAEjE,IAAK,IAAI4R,EAAI/Y,EAAI,EAAG+Y,EAAI/L,EAAM3I,SAAU0U,EAAG,CACzC,MACExX,IAAKiY,GACHxM,EAAM+L,GAEV,GAAIK,IAASI,GAAQJ,GAAQI,GAAQ9Y,OAAOkB,UAAUC,eAAe1B,KAAKiZ,EAAM,UAAYA,EAAKnY,QAAUuY,EAAKvY,MAAO,CACrH,MAAMwQ,EAAM,6BAA6B2H,iBACzC1J,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWD,kBAAkB1F,EAAK0N,IACtD,QAMR,GAAI0H,IAAqBzJ,EAAIS,QAAQL,SAAU,CAC7C,MAAM2J,EAAO,2HACb/J,EAAIqG,SAASlS,KAAK,IAAI6F,EAAWc,YAAYzG,EAAK0V,IAIpD,OADA1V,EAAI4T,SAAWxM,EACRA,GA8bTrL,EAAQqX,YAAcA,EACtBrX,EAAQ4Z,WA/LR,SAAoBhK,EAAK3L,GACvB,GAAIA,EAAIsD,OAASqC,EAAWnH,KAAKe,KAAOS,EAAIsD,OAASqC,EAAWnH,KAAKQ,SAAU,CAC7E,MAAM0O,EAAM,KAAK1N,EAAIsD,6CAErB,OADAqI,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWa,gBAAgBxG,EAAK0N,IAC7C,KAGT,MAAM,SACJ1J,EAAQ,MACRiF,GACEjJ,EAAIsD,OAASqC,EAAWnH,KAAKQ,SA0DnC,SAA6B2M,EAAK3L,GAChC,MAAMgE,EAAW,GACXiF,EAAQ,GACd,IAAIqD,GAAc,EACd9O,OAAMmL,EACNgM,EAAW,KACX3S,EAAO,IACP4T,EAAW,KAEf,IAAK,IAAI3Z,EAAI,EAAGA,EAAI+D,EAAIiJ,MAAM3I,SAAUrE,EAAG,CACzC,MAAMqO,EAAOtK,EAAIiJ,MAAMhN,GAEvB,GAAyB,iBAAdqO,EAAKuG,KAAmB,CACjC,MAAM,KACJA,EAAI,OACJjR,GACE0K,EAUJ,GARa,MAATuG,IAAiBvE,QAAuB3D,IAARnL,IAC9B8O,QAAuB3D,IAARnL,IAAmBA,EAAMwE,EAAOiH,EAAM4M,MAAQ,MACjE5M,EAAMnJ,KAAK,IAAIsL,EAAK5N,IACpB8O,GAAc,EACd9O,OAAMmL,EACNgM,EAAW,MAGT9D,IAAS7O,EACXA,EAAO,UACF,GAAKA,GAAiB,MAAT6O,GAEb,GAAa,MAAT7O,GAAyB,MAAT6O,QAAwBlI,IAARnL,EAAmB,CAC5D,GAAa,MAATwE,EAAc,CAGhB,GAFAxE,EAAMyL,EAAM4M,MAERrY,aAAe4N,EAAM,CACvB,MAAMsC,EAAM,0CACNqD,EAAM,IAAIpL,EAAWD,kBAAkB1F,EAAK0N,GAClDqD,EAAInR,OAASA,EACb+L,EAAI5F,OAAOjG,KAAKiR,GAGlB,IAAKzE,GAAmC,iBAAbqI,EAAuB,CAChD,MAAMmB,EAASxL,EAAK7G,MAAQ6G,EAAK7G,MAAMlD,MAAQ+J,EAAK1K,OAChDkW,EAASnB,EAAW,MAAMhJ,EAAI5F,OAAOjG,KAAKmR,EAAgBjR,EAAKxC,IACnE,MAAM,IACJkC,GACEkW,EAASxV,QAEb,IAAK,IAAInE,EAAI0Y,EAAU1Y,EAAI6Z,IAAU7Z,EAAG,GAAe,OAAXyD,EAAIzD,GAAa,CAC3D,MAAMyR,EAAM,mEACZ/B,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWD,kBAAkBkQ,EAAUlI,IAC3D,aAIJlQ,EAAM,KAGRmX,EAAW,KACXrI,GAAc,EACdtK,EAAO,UACF,GAAa,MAATA,GAAyB,MAAT6O,GAAgB5U,EAAI+D,EAAIiJ,MAAM3I,OAAS,EAAG,CACnE,MAAMoN,EAAM,wCAAwCmD,EAC9CE,EAAM,IAAIpL,EAAWa,gBAAgBxG,EAAK0N,GAChDqD,EAAInR,OAASA,EACb+L,EAAI5F,OAAOjG,KAAKiR,SApChBzE,GAAc,OAsCX,GAAIhC,EAAKhH,OAASqC,EAAWnH,KAAKE,WACvCsF,EAASlE,KAAK,CACZwR,OAAQrI,EAAM3I,cAEX,GAAIgK,EAAKhH,OAASqC,EAAWnH,KAAKJ,QACvC4S,EAAsBrF,EAAI5F,OAAQuE,GAClCtG,EAASlE,KAAK,CACZmE,QAASqG,EAAKrG,QACdqN,OAAQrI,EAAM3I,aAEX,CACL,GAAI0B,EAAM,CACR,MAAM0L,EAAM,cAAc1L,qBAC1B2J,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWD,kBAAkB4E,EAAMoD,IAGzD,MAAMxQ,EAAQkW,EAAYzH,EAAKrB,QAEnB3B,IAARnL,GACFyL,EAAMnJ,KAAK5C,GACX0Y,EAAWtL,IAEXrB,EAAMnJ,KAAK,IAAIsL,EAAK5N,EAAKN,IACzBM,OAAMmL,GAGRgM,EAAWrK,EAAK7G,MAAMlD,MACtByB,EAAO,KAIX4O,EAAuBjF,EAAI5F,OAAQ/F,QACvB2I,IAARnL,GAAmByL,EAAMnJ,KAAK,IAAIsL,EAAK5N,IAC3C,MAAO,CACLwG,WACAiF,SAhK0C8M,CAAoBpK,EAAK3L,GAcvE,SAA8B2L,EAAK3L,GACjC,MAAMgE,EAAW,GACXiF,EAAQ,GAEd,IAAK,IAAIhN,EAAI,EAAGA,EAAI+D,EAAIiJ,MAAM3I,SAAUrE,EAAG,CACzC,MAAMqO,EAAOtK,EAAIiJ,MAAMhN,GAEvB,OAAQqO,EAAKhH,MACX,KAAKqC,EAAWnH,KAAKE,WACnBsF,EAASlE,KAAK,CACZwR,OAAQrI,EAAM3I,SAEhB,MAEF,KAAKqF,EAAWnH,KAAKJ,QACnB4F,EAASlE,KAAK,CACZmE,QAASqG,EAAKrG,QACdqN,OAAQrI,EAAM3I,SAEhB,MAEF,KAAKqF,EAAWnH,KAAKgB,SAInB,GAHI8K,EAAKlH,OAAOuI,EAAI5F,OAAOjG,KAAKwK,EAAKlH,OACrC6F,EAAMnJ,KAAKsT,EAAYzH,EAAKrB,EAAK7B,OAE7B6B,EAAK0L,SAAU,CACjB,MAAMtI,EAAM,oEACZ/B,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWD,kBAAkB4E,EAAMoD,IAGzD,MAEF,QACMpD,EAAKlH,OAAOuI,EAAI5F,OAAOjG,KAAKwK,EAAKlH,OACrCuI,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWa,gBAAgB8D,EAAM,cAAcA,EAAKhH,2BAI9E,MAAO,CACLU,WACAiF,SAtD0EgN,CAAqBtK,EAAK3L,GAChGiL,EAAM,IAAIH,EAIhB,GAHAG,EAAIhC,MAAQA,EACZkI,EAAgBlG,EAAKjH,IAEhB2H,EAAIS,QAAQL,UAAY9C,EAAMuM,KAAKxK,GAAMA,aAAcI,GAAQJ,EAAGxN,eAAe8K,GAAa,CACjG,MAAMoN,EAAO,2HACb/J,EAAIqG,SAASlS,KAAK,IAAI6F,EAAWc,YAAYzG,EAAK0V,IAIpD,OADA1V,EAAI4T,SAAW3I,EACRA,GA2KTlP,EAAQwV,cAAgBA,EACxBxV,EAAQ0S,WAAaA,EACrB1S,EAAQma,gBA76BR,UAAyB,OACvBjH,EAAM,kBACNkH,EAAiB,IACjB7R,EAAG,MACHpH,IAEA,GAAqB,iBAAVA,EAAoB,OAAOoK,OAAOpK,GAC7C,IAAKkZ,SAASlZ,GAAQ,OAAOmZ,MAAMnZ,GAAS,OAASA,EAAQ,EAAI,QAAU,OAC3E,IAAIQ,EAAIyN,KAAKrB,UAAU5M,GAEvB,IAAK+R,GAAUkH,KAAuB7R,GAAe,4BAARA,IAAsC,MAAM4K,KAAKxR,GAAI,CAChG,IAAIzB,EAAIyB,EAAEmC,QAAQ,KAEd5D,EAAI,IACNA,EAAIyB,EAAE4C,OACN5C,GAAK,KAGP,IAAInB,EAAI4Z,GAAqBzY,EAAE4C,OAASrE,EAAI,GAE5C,KAAOM,KAAM,GAAGmB,GAAK,IAGvB,OAAOA,GAu5BT3B,EAAQua,gBAx+BR,SAAyBhM,EAAM7E,EAAKkE,EAAWC,GAC7C,MAAM,YACJ2E,GACEE,GACE,YACJlC,EAAW,OACX3G,GACEH,EACJ,IAAI,KACFnC,EAAI,MACJpG,GACEoN,EAEiB,iBAAVpN,IACTA,EAAQoK,OAAOpK,GACfoN,EAAO3N,OAAOsN,OAAO,GAAIK,EAAM,CAC7BpN,WAIJ,MAAMqZ,EAAaC,IACjB,OAAQA,GACN,KAAK7Q,EAAWnH,KAAKG,aACrB,KAAKgH,EAAWnH,KAAKI,cACnB,OAAOyR,EAAY/F,EAAM7E,EAAKkE,EAAWC,GAE3C,KAAKjE,EAAWnH,KAAKa,aACnB,OAAO4Q,EAAmB/S,EAAOuI,GAEnC,KAAKE,EAAWnH,KAAKc,aACnB,OAAO8Q,EAAmBlT,EAAOuI,GAEnC,KAAKE,EAAWnH,KAAKY,MACnB,OA5FR,SAAqBkL,EAAM7E,EAAKkE,EAAWC,GACzC,MAAM,QACJ3F,EAAO,KACPX,EAAI,MACJpG,GACEoN,GACE,aACJmM,EAAY,YACZlK,EAAW,OACX5J,EAAM,OACNiD,GACEH,EAEJ,GAAI8G,GAAe,aAAa2C,KAAKhS,IAAU0I,GAAU,WAAWsJ,KAAKhS,GACvE,OAAO+S,EAAmB/S,EAAOuI,GAGnC,IAAKvI,GAAS,oFAAoFgS,KAAKhS,GAOrG,OAAOqP,GAAe3G,IAAmC,IAAzB1I,EAAM2C,QAAQ,OAAuC,IAAxB3C,EAAM2C,QAAQ,OAAuC,IAAxB3C,EAAM2C,QAAQ,KAAcuQ,EAAmBlT,EAAOuI,GAAOwK,EAAmB/S,EAAOuI,GAAO4K,EAAY/F,EAAM7E,EAAKkE,EAAWC,GAG5N,IAAK2C,IAAgB3G,GAAUtC,IAASqC,EAAWnH,KAAKY,QAAkC,IAAzBlC,EAAM2C,QAAQ,MAE7E,OAAOwQ,EAAY/F,EAAM7E,EAAKkE,EAAWC,GAG3C,GAAe,KAAXjH,GAAiBqN,EAAuB9S,GAE1C,OADAuI,EAAI6K,kBAAmB,EAChBD,EAAY/F,EAAM7E,EAAKkE,EAAWC,GAG3C,MAAM7H,EAAM7E,EAAM+J,QAAQ,OAAQ,OAAOtE,GAIzC,GAAI8T,EAAc,CAChB,MAAM,KACJ1H,GACEtJ,EAAIkG,IAAI7D,OAEZ,GAAwB,iBADPgH,EAAc/M,EAAKgN,EAAMA,EAAKC,gBAAgB9R,MAC7B,OAAO+S,EAAmB/S,EAAOuI,GAGrE,MAAMkL,EAAOpE,EAAcxK,EAAMwN,EAAcxN,EAAKY,EAtYpC,OAsYuDoN,EAAetK,IAEtF,OAAIxB,GAAY2B,IAAmC,IAAxB+K,EAAK9Q,QAAQ,QAA2C,IAA3BoE,EAAQpE,QAAQ,MAKjE8Q,GAJDhH,GAAWA,IA9kCnB,SAA0B5H,EAAKY,EAAQsB,GACrC,OAAKA,EAEE,IADIA,EAAQgD,QAAQ,YAAa,KAAKtE,UAC3BA,IAASZ,IAFNA,EA8kCZ2U,CAAiB/F,EAAMhO,EAAQsB,IAuC3B0S,CAAYrM,EAAM7E,EAAKkE,EAAWC,GAE3C,QACE,OAAO,OAITtG,IAASqC,EAAWnH,KAAKa,cAAgB,gCAAgC6P,KAAKhS,GAEhFoG,EAAOqC,EAAWnH,KAAKa,cACbkN,IAAe3G,GAAYtC,IAASqC,EAAWnH,KAAKG,cAAgB2E,IAASqC,EAAWnH,KAAKI,gBAEvG0E,EAAOqC,EAAWnH,KAAKa,cAGzB,IAAIoI,EAAM8O,EAAWjT,GAErB,GAAY,OAARmE,IACFA,EAAM8O,EAAWhI,GACL,OAAR9G,GAAc,MAAM,IAAIvC,MAAM,mCAAmCqJ,GAGvE,OAAO9G,GAk7BT1L,EAAQmL,OAASA,G,cClkEjBlL,EAAOD,QAAUkC,QAAQ,W,cCAzBjC,EAAOD,QAAUkC,QAAQ,Q,8YCCzB,aAEA,OAaA,IAAK2Y,EAWL,SAASC,EAAO9O,GACZ,OAAO+O,EAAGC,WAAWhP,GAGzB,SAAeiP,EAAiBC,G,yCAE5B,OAAO,IAAIC,QAAQ,CAAC/H,EAASgI,KACpBN,EAAOI,GAIZG,EAAIC,UAAUL,iBAAiBC,GAAUK,KACrCnI,EACAgI,GALAhI,EAAQ,WAuBpB,SAASoI,EAAgBN,GACrB,MAAMO,EAASP,EAASQ,YAAY,KACpC,OAAOR,EAASlW,OAAO,EAAGyW,GAvD9B,UAAe,CACXE,gBAiBJ,SAAyBT,EAAkBU,GACvC,MAAO,GAAGJ,EAAgBN,MAAaU,KAjBvCd,SACAe,YAuDJ,SAAqBX,GACjB,MAAMY,EAAWZ,EAASQ,YAAY,KACtC,OAAOR,EAASa,UAAUD,IAxD1BE,aA2DJ,SAAsBd,GAClB,MAAMY,EAAWZ,EAASQ,YAAY,KACtC,OAAOR,EAASlW,OAAO,EAAG8W,IA5D1BG,iBAmCJ,SACIf,EACAgB,EAA6Bb,EAAIc,WAAWC,Q,yCAE5C,MAAMxM,QAAYqL,EAAiBC,GACnC,QAAKtL,IACLyL,EAAIgB,OAAOC,iBACP1M,EACAsM,EAAWK,YAER,OA5CPtB,mBACAO,kBACAgB,cA4DJ,SAAuBtB,EAAkBuB,GACrC1B,EAAG2B,cAAcxB,EAAUuB,KA1D/B,SAAK5B,GACD,wBACA,wBACA,iBACA,iBAJJ,CAAKA,MAAW,M,cChBhB5a,EAAOD,QAAUkC,QAAQ,S,cCAzBjC,EAAOD,QAAUkC,QAAQ,O,6BCEzB,IAAI0H,EAAa,EAAQ,GACrBgQ,EAAa,EAAQ,GACrB3D,EAAW,EAAQ,IAkBvB,MAAM5K,EAAM,CACVc,WAjBF,SAAmBJ,EAAQnB,EAAKlB,GAC9B,MAAM2B,EAAM,IAAIuO,EAAW5H,QAAQjG,GAEnC,GAAInB,aAAe4E,IACjB,IAAK,MAAO/N,EAAKN,KAAUyJ,EAAKS,EAAI6B,MAAMnJ,KAAKgI,EAAO4Q,WAAWlb,EAAKN,EAAOuI,SACxE,GAAIkB,GAAsB,iBAARA,EACvB,IAAK,MAAMnJ,KAAOb,OAAO2Q,KAAK3G,GAAMS,EAAI6B,MAAMnJ,KAAKgI,EAAO4Q,WAAWlb,EAAKmJ,EAAInJ,GAAMiI,IAOtF,MAJqC,mBAA1BqC,EAAOoG,gBAChB9G,EAAI6B,MAAM0P,KAAK7Q,EAAOoG,gBAGjB9G,GAKPwR,SAAS,EACTC,UAAWlD,EAAW5H,QACtBzJ,IAAK,wBACL6K,QAASwG,EAAWlB,YAgBtB,MAAMxJ,EAAM,CACV/C,WAdF,SAAmBJ,EAAQnB,EAAKlB,GAC9B,MAAMwF,EAAM,IAAI0K,EAAW7K,QAAQhD,GAEnC,GAAInB,GAAOA,EAAI3J,OAAOoL,UACpB,IAAK,MAAM4C,KAAMrE,EAAK,CACpB,MAAMU,EAAIS,EAAOI,WAAW8C,EAAIvF,EAAIqT,YAAa,KAAMrT,GACvDwF,EAAIhC,MAAMnJ,KAAKuH,GAInB,OAAO4D,GAKP2N,SAAS,EACTC,UAAWlD,EAAW7K,QACtBxG,IAAK,wBACL6K,QAASwG,EAAWA,YAGhBoD,EAAS,CACbC,SAAU9b,GAA0B,iBAAVA,EAC1B0b,SAAS,EACTtU,IAAK,wBACL6K,QAASwG,EAAWpE,cAEpBzH,UAAS,CAACQ,EAAM7E,EAAKkE,EAAWC,KAC9BnE,EAAM9I,OAAOsN,OAAO,CAClBwM,cAAc,GACbhR,GACIkQ,EAAWW,gBAAgBhM,EAAM7E,EAAKkE,EAAWC,IAG1DwC,QAASuJ,EAAWlH,YAGhBwK,EAAW,CAAC7R,EAAK6D,EAAK8N,GAItBG,EAAchc,GAA0B,iBAAVA,GAAsByK,OAAOM,UAAU/K,GAErEic,EAAa,CAACzZ,EAAK0Z,EAAMC,IAAU1D,EAAWtB,WAAWC,SAAWgF,OAAO5Z,GAAO6Z,SAASH,EAAMC,GAEvG,SAASG,EAAa/Q,EAAM4Q,EAAO1H,GACjC,MAAM,MACJzU,GACEuL,EACJ,OAAIyQ,EAAYhc,IAAUA,GAAS,EAAUyU,EAASzU,EAAMgO,SAASmO,GAC9D1D,EAAWO,gBAAgBzN,GAGpC,MAAMgR,EAAU,CACdT,SAAU9b,GAAkB,MAATA,EACnBgL,WAAY,CAACJ,EAAQ5K,EAAOuI,IAAQA,EAAIqT,YAAc,IAAInD,EAAW/N,OAAO,MAAQ,KACpFgR,SAAS,EACTtU,IAAK,yBACL4K,KAAM,wBACNC,QAAS,IAAM,KACf/C,QAASuJ,EAAWpB,YACpBzK,UAAW,IAAM6L,EAAWpB,YAAYC,SAEpCkF,EAAU,CACdV,SAAU9b,GAA0B,kBAAVA,EAC1B0b,SAAS,EACTtU,IAAK,yBACL4K,KAAM,oCACNC,QAASpN,GAAkB,MAAXA,EAAI,IAAyB,MAAXA,EAAI,GACtCqK,QAASuJ,EAAWzB,YACpBpK,UAAW,EACT5M,WACIA,EAAQyY,EAAWzB,YAAYC,QAAUwB,EAAWzB,YAAYE,UAElEuF,EAAS,CACbX,SAAU9b,GAASgc,EAAYhc,IAAUA,GAAS,EAClD0b,SAAS,EACTtU,IAAK,wBACL2K,OAAQ,MACRC,KAAM,eACNC,QAAS,CAACpN,EAAK6X,IAAQT,EAAWpX,EAAK6X,EAAK,GAC5CxN,QAASuJ,EAAWtB,WACpBvK,UAAWrB,GAAQ+Q,EAAa/Q,EAAM,EAAG,OAErCoR,EAAS,CACbb,SAAUE,EACVN,SAAS,EACTtU,IAAK,wBACL4K,KAAM,gBACNC,QAASpN,GAAOoX,EAAWpX,EAAKA,EAAK,IACrCqK,QAASuJ,EAAWtB,WACpBvK,UAAW6L,EAAWO,iBAElB4D,EAAS,CACbd,SAAU9b,GAASgc,EAAYhc,IAAUA,GAAS,EAClD0b,SAAS,EACTtU,IAAK,wBACL2K,OAAQ,MACRC,KAAM,qBACNC,QAAS,CAACpN,EAAKgY,IAAQZ,EAAWpX,EAAKgY,EAAK,IAC5C3N,QAASuJ,EAAWtB,WACpBvK,UAAWrB,GAAQ+Q,EAAa/Q,EAAM,GAAI,OAEtCuR,EAAS,CACbhB,SAAU9b,GAA0B,iBAAVA,EAC1B0b,SAAS,EACTtU,IAAK,0BACL4K,KAAM,4BACNC,QAAS,CAACpN,EAAKkY,IAAQA,EAAMC,IAAiB,MAAXnY,EAAI,GAAa4F,OAAOwS,kBAAoBxS,OAAOyS,kBACtFtQ,UAAW6L,EAAWO,iBAElBmE,EAAS,CACbrB,SAAU9b,GAA0B,iBAAVA,EAC1B0b,SAAS,EACTtU,IAAK,0BACL2K,OAAQ,MACRC,KAAM,yDACNC,QAASpN,GAAOuY,WAAWvY,GAC3B+H,UAAW,EACT5M,WACIyK,OAAOzK,GAAOqd,iBAEhBC,EAAW,CACfxB,SAAU9b,GAA0B,iBAAVA,EAC1B0b,SAAS,EACTtU,IAAK,0BACL4K,KAAM,yCAEN,QAAQnN,EAAK0Y,EAAOC,GAClB,MAAMC,EAAOF,GAASC,EAChBjS,EAAO,IAAIkN,EAAW/N,OAAO0S,WAAWvY,IAE9C,OADI4Y,GAAkC,MAA1BA,EAAKA,EAAKra,OAAS,KAAYmI,EAAK0N,kBAAoBwE,EAAKra,QAClEmI,GAGTqB,UAAW6L,EAAWO,iBAElB0E,EAAO3B,EAAS/F,OAAO,CAACuG,EAASC,EAASC,EAAQE,EAAQC,EAAQE,EAAQK,EAAQG,IAIlFK,EAAgB3d,GAA0B,iBAAVA,GAAsByK,OAAOM,UAAU/K,GAEvE4d,EAAgB,EACpB5d,WACIiO,KAAKrB,UAAU5M,GAEfgT,EAAO,CAAC9I,EAAK6D,EAAK,CACtB+N,SAAU9b,GAA0B,iBAAVA,EAC1B0b,SAAS,EACTtU,IAAK,wBACL6K,QAASwG,EAAWpE,cACpBzH,UAAWgR,GACV,CACD9B,SAAU9b,GAAkB,MAATA,EACnBgL,WAAY,CAACJ,EAAQ5K,EAAOuI,IAAQA,EAAIqT,YAAc,IAAInD,EAAW/N,OAAO,MAAQ,KACpFgR,SAAS,EACTtU,IAAK,yBACL4K,KAAM,SACNC,QAAS,IAAM,KACfrF,UAAWgR,GACV,CACD9B,SAAU9b,GAA0B,kBAAVA,EAC1B0b,SAAS,EACTtU,IAAK,yBACL4K,KAAM,eACNC,QAASpN,GAAe,SAARA,EAChB+H,UAAWgR,GACV,CACD9B,SAAU6B,EACVjC,SAAS,EACTtU,IAAK,wBACL4K,KAAM,wBACNC,QAASpN,GAAO4T,EAAWtB,WAAWC,SAAWgF,OAAOvX,GAAOwX,SAASxX,EAAK,IAC7E+H,UAAW,EACT5M,WACI2d,EAAc3d,GAASA,EAAMgO,WAAaC,KAAKrB,UAAU5M,IAC9D,CACD8b,SAAU9b,GAA0B,iBAAVA,EAC1B0b,SAAS,EACTtU,IAAK,0BACL4K,KAAM,yDACNC,QAASpN,GAAOuY,WAAWvY,GAC3B+H,UAAWgR,IAGb5K,EAAKlB,eAAiBjN,IACpB,MAAM,IAAIgZ,YAAY,2BAA2B5P,KAAKrB,UAAU/H,KAKlE,MAAMiZ,EAAgB,EACpB9d,WACIA,EAAQyY,EAAWzB,YAAYC,QAAUwB,EAAWzB,YAAYE,SAEhE6G,EAAgB/d,GAA0B,iBAAVA,GAAsByK,OAAOM,UAAU/K,GAE7E,SAASge,EAAaC,EAAMzb,EAAK2Z,GAC/B,IAAItX,EAAMrC,EAAIuH,QAAQ,KAAM,IAE5B,GAAI0O,EAAWtB,WAAWC,SAAU,CAClC,OAAQ+E,GACN,KAAK,EACHtX,EAAM,KAAKA,EACX,MAEF,KAAK,EACHA,EAAM,KAAKA,EACX,MAEF,KAAK,GACHA,EAAM,KAAKA,EAIf,MAAMrE,EAAI4b,OAAOvX,GACjB,MAAgB,MAAToZ,EAAe7B,QAAQ,GAAK5b,EAAIA,EAGzC,MAAMA,EAAI6b,SAASxX,EAAKsX,GACxB,MAAgB,MAAT8B,GAAgB,EAAIzd,EAAIA,EAGjC,SAAS0d,EAAe3S,EAAM4Q,EAAO1H,GACnC,MAAM,MACJzU,GACEuL,EAEJ,GAAIwS,EAAc/d,GAAQ,CACxB,MAAM6E,EAAM7E,EAAMgO,SAASmO,GAC3B,OAAOnc,EAAQ,EAAI,IAAMyU,EAAS5P,EAAIhB,OAAO,GAAK4Q,EAAS5P,EAG7D,OAAO4T,EAAWO,gBAAgBzN,GAGpC,MAAM4S,EAASpC,EAAS/F,OAAO,CAAC,CAC9B8F,SAAU9b,GAAkB,MAATA,EACnBgL,WAAY,CAACJ,EAAQ5K,EAAOuI,IAAQA,EAAIqT,YAAc,IAAInD,EAAW/N,OAAO,MAAQ,KACpFgR,SAAS,EACTtU,IAAK,yBACL4K,KAAM,wBACNC,QAAS,IAAM,KACf/C,QAASuJ,EAAWpB,YACpBzK,UAAW,IAAM6L,EAAWpB,YAAYC,SACvC,CACDwE,SAAU9b,GAA0B,kBAAVA,EAC1B0b,SAAS,EACTtU,IAAK,yBACL4K,KAAM,6CACNC,QAAS,KAAM,EACf/C,QAASuJ,EAAWzB,YACpBpK,UAAWkR,GACV,CACDhC,SAAU9b,GAA0B,kBAAVA,EAC1B0b,SAAS,EACTtU,IAAK,yBACL4K,KAAM,gDACNC,QAAS,KAAM,EACf/C,QAASuJ,EAAWzB,YACpBpK,UAAWkR,GACV,CACDhC,SAAUiC,EACVrC,SAAS,EACTtU,IAAK,wBACL2K,OAAQ,MACRC,KAAM,uBACNC,QAAS,CAACpN,EAAKoZ,EAAMG,IAAQJ,EAAaC,EAAMG,EAAK,GACrDxR,UAAWrB,GAAQ2S,EAAe3S,EAAM,EAAG,OAC1C,CACDuQ,SAAUiC,EACVrC,SAAS,EACTtU,IAAK,wBACL2K,OAAQ,MACRC,KAAM,sBACNC,QAAS,CAACpN,EAAKoZ,EAAMvB,IAAQsB,EAAaC,EAAMvB,EAAK,GACrD9P,UAAWrB,GAAQ2S,EAAe3S,EAAM,EAAG,MAC1C,CACDuQ,SAAUiC,EACVrC,SAAS,EACTtU,IAAK,wBACL4K,KAAM,0BACNC,QAAS,CAACpN,EAAKoZ,EAAMI,IAAQL,EAAaC,EAAMI,EAAK,IACrDzR,UAAW6L,EAAWO,iBACrB,CACD8C,SAAUiC,EACVrC,SAAS,EACTtU,IAAK,wBACL2K,OAAQ,MACRC,KAAM,6BACNC,QAAS,CAACpN,EAAKoZ,EAAMpB,IAAQmB,EAAaC,EAAMpB,EAAK,IACrDjQ,UAAWrB,GAAQ2S,EAAe3S,EAAM,GAAI,OAC3C,CACDuQ,SAAU9b,GAA0B,iBAAVA,EAC1B0b,SAAS,EACTtU,IAAK,0BACL4K,KAAM,4BACNC,QAAS,CAACpN,EAAKkY,IAAQA,EAAMC,IAAiB,MAAXnY,EAAI,GAAa4F,OAAOwS,kBAAoBxS,OAAOyS,kBACtFtQ,UAAW6L,EAAWO,iBACrB,CACD8C,SAAU9b,GAA0B,iBAAVA,EAC1B0b,SAAS,EACTtU,IAAK,0BACL2K,OAAQ,MACRC,KAAM,oDACNC,QAASpN,GAAOuY,WAAWvY,EAAIkF,QAAQ,KAAM,KAC7C6C,UAAW,EACT5M,WACIyK,OAAOzK,GAAOqd,iBACnB,CACDvB,SAAU9b,GAA0B,iBAAVA,EAC1B0b,SAAS,EACTtU,IAAK,0BACL4K,KAAM,sCAEN,QAAQnN,EAAK4Y,GACX,MAAMlS,EAAO,IAAIkN,EAAW/N,OAAO0S,WAAWvY,EAAIkF,QAAQ,KAAM,MAEhE,GAAI0T,EAAM,CACR,MAAMa,EAAIb,EAAK1T,QAAQ,KAAM,IACL,MAApBuU,EAAEA,EAAElb,OAAS,KAAYmI,EAAK0N,kBAAoBqF,EAAElb,QAG1D,OAAOmI,GAGTqB,UAAW6L,EAAWO,kBACpBlE,EAASyJ,OAAQzJ,EAAS0J,KAAM1J,EAAS2J,MAAO3J,EAASpJ,IAAKoJ,EAAS4J,QAAS5J,EAAS6J,UAAW7J,EAAS8J,WAE3GC,EAAU,CACdnB,OACA3B,WACA/I,OACAmL,UAEItM,EAAO,CACX0M,OAAQzJ,EAASyJ,OACjBO,KAAMtC,EACNuC,MAAOzB,EACP0B,SAAU7B,EACV8B,SAAUnC,EACV6B,UAAW7J,EAAS6J,UACpBO,IAAKvC,EACLwC,OAAQvC,EACRwC,OAAQ3C,EACRiC,QAAS5J,EAAS4J,QAClBxU,MACAmV,KAAM9C,EACNiC,KAAM1J,EAAS0J,KACfC,MAAO3J,EAAS2J,MAChB1Q,MACArC,IAAKoJ,EAASpJ,IACdkT,UAAW9J,EAAS8J,WAetB,SAAS5T,EAAWhL,EAAOmV,EAAS5M,GAClC,GAAIvI,aAAiByY,EAAW7T,KAAM,OAAO5E,EAC7C,MAAM,cACJsf,EAAa,SACbC,EAAQ,YACRC,EAAW,OACX5U,EAAM,YACNgR,GACErT,EACA4M,GAAWA,EAAQ2B,WAAW,QAAO3B,EAAUmK,EAAgBnK,EAAQxR,MAAM,IACjF,IAAI8b,EAtBN,SAAuBzf,EAAOmV,EAAStD,GACrC,GAAIsD,EAAS,CACX,MAAM1N,EAAQoK,EAAK6N,OAAOzf,GAAKA,EAAEmH,MAAQ+N,GACnCsK,EAAShY,EAAM4I,KAAKpQ,IAAMA,EAAE8R,SAAWtK,EAAM,GACnD,IAAKgY,EAAQ,MAAM,IAAIzX,MAAM,OAAOmN,eACpC,OAAOsK,EAIT,OAAO5N,EAAKxB,KAAKpQ,IAAMA,EAAE6b,UAAY7b,EAAE6b,SAAS9b,IAAUC,EAAE0f,OAAS3f,aAAiBC,EAAE0f,SAAW1f,EAAE8R,QAaxF6N,CAAc5f,EAAOmV,EAASvK,EAAOiH,MAElD,IAAK4N,EAAQ,CAEX,GAD4B,mBAAjBzf,EAAMgK,SAAuBhK,EAAQA,EAAMgK,UACjC,iBAAVhK,EAAoB,OAAO4b,EAAc,IAAInD,EAAW/N,OAAO1K,GAASA,EACnFyf,EAASzf,aAAiBqO,IAAMnE,EAAMlK,EAAMF,OAAOoL,UAAY6C,EAAM7D,EAGnEqV,IACFA,EAASE,UACFlX,EAAIgX,UAKb,MAAM9V,EAAM,GAEZ,GAAIzJ,GAA0B,iBAAVA,GAAsBwf,EAAa,CACrD,MAAMta,EAAOsa,EAAY5f,IAAII,GAE7B,GAAIkF,EAAM,CACR,MAAM2a,EAAQ,IAAIpH,EAAW3I,MAAM5K,GAInC,OAFAqD,EAAIuX,WAAWld,KAAKid,GAEbA,EAGTpW,EAAIzJ,MAAQA,EACZwf,EAAY9T,IAAI1L,EAAOyJ,GAKzB,OAFAA,EAAI8B,KAAOkU,EAAOzU,WAAayU,EAAOzU,WAAWzC,EAAIqC,OAAQ5K,EAAOuI,GAAOqT,EAAc,IAAInD,EAAW/N,OAAO1K,GAASA,EACpHmV,GAAW1L,EAAI8B,gBAAgBkN,EAAW7T,OAAM6E,EAAI8B,KAAKnE,IAAM+N,GAC5D1L,EAAI8B,KAmCb,MAAMwU,EAAsB,CAACzP,EAAG0P,IAAM1P,EAAEhQ,IAAM0f,EAAE1f,KAAO,EAAIgQ,EAAEhQ,IAAM0f,EAAE1f,IAAM,EAAI,EAE/E,MAAM2f,EAGJ,aAAY,WACVC,EAAU,MACV9H,EAAK,OACLxN,EAAM,eACNoG,EACAa,KAAMsO,IAEN5b,KAAK6T,QAAUA,EACf7T,KAAKjF,KAAOsL,EACZrG,KAAKyM,gBAAoC,IAAnBA,EAA0B+O,EAAsB/O,GAAkB,MACnFkP,GAAcC,GAAsBrL,EAASsL,sBAAsB,OAAQ,cAChF7b,KAAKsN,KAhDT,SAAuBgN,EAASwB,EAAWH,EAAYI,GACrD,IAAIzO,EAAOgN,EAAQyB,EAASvW,QAAQ,MAAO,KAE3C,IAAK8H,EAAM,CACT,MAAMzB,EAAO3Q,OAAO2Q,KAAKyO,GAAS3U,IAAI5J,GAAO2N,KAAKrB,UAAUtM,IAAM0G,KAAK,MACvE,MAAM,IAAIgB,MAAM,mBAAmBsY,kBAAyBlQ,KAG9D,GAAIpN,MAAMC,QAAQid,GAChB,IAAK,MAAM9Y,KAAO8Y,EAAYrO,EAAOA,EAAKmE,OAAO5O,OAClB,mBAAf8Y,IAChBrO,EAAOqO,EAAWrO,EAAKlO,UAGzB,IAAK,IAAI5E,EAAI,EAAGA,EAAI8S,EAAKzO,SAAUrE,EAAG,CACpC,MAAMqI,EAAMyK,EAAK9S,GAEjB,GAAmB,iBAARqI,EAAkB,CAC3B,MAAMqY,EAASY,EAAUjZ,GAEzB,IAAKqY,EAAQ,CACX,MAAMrP,EAAO3Q,OAAO2Q,KAAKiQ,GAAWnW,IAAI5J,GAAO2N,KAAKrB,UAAUtM,IAAM0G,KAAK,MACzE,MAAM,IAAIgB,MAAM,uBAAuBZ,kBAAoBgJ,KAG7DyB,EAAK9S,GAAK0gB,GAId,OAAO5N,EAmBO0O,CAAc1B,EAAShN,EAAMqO,GAAcC,EAAsBvV,GAG/E,WAAW5K,EAAO4b,EAAazG,EAAS5M,GACtC,MAAMiY,EAAU,CACdlB,cAAeW,EAAOX,cACtB1U,OAAQrG,KACRqX,eAGF,OAAO5Q,EAAWhL,EAAOmV,EADP5M,EAAM9I,OAAOsN,OAAOxE,EAAKiY,GAAWA,GAIxD,WAAWlgB,EAAKN,EAAOuI,GAChBA,IAAKA,EAAM,CACdqT,aAAa,IAEf,MAAM9Q,EAAIvG,KAAKyG,WAAW1K,EAAKiI,EAAIqT,YAAa,KAAMrT,GAChD4B,EAAI5F,KAAKyG,WAAWhL,EAAOuI,EAAIqT,YAAa,KAAMrT,GACxD,OAAO,IAAIkQ,EAAWvK,KAAKpD,EAAGX,IAKlC1B,EAAWe,gBAAgByW,EAAQ,gBAAiBxX,EAAWkB,kBAE/DlB,EAAWe,gBAAgByW,EAAQ,cAAexX,EAAWmB,aAE7D/K,EAAQohB,OAASA,G,6BCvgBjB,IAAIxX,EAAa,EAAQ,GACrBgQ,EAAa,EAAQ,GAGzB,MAAM8F,EAAS,CACbzC,SAAU9b,GAASA,aAAiBygB,WAEpC/E,SAAS,EACTtU,IAAK,2BAUL6K,QAAS,CAACxD,EAAKlD,KACb,MAAM/I,EAAMiW,EAAWpE,cAAc5F,EAAKlD,GAE1C,GAAsB,mBAAXmV,OACT,OAAOA,OAAOC,KAAKne,EAAK,UACnB,GAAoB,mBAAToe,KAAqB,CAErC,MAAM/b,EAAM+b,KAAKpe,EAAIuH,QAAQ,UAAW,KAClC8W,EAAS,IAAIJ,WAAW5b,EAAIzB,QAElC,IAAK,IAAIrE,EAAI,EAAGA,EAAI8F,EAAIzB,SAAUrE,EAAG8hB,EAAO9hB,GAAK8F,EAAIic,WAAW/hB,GAEhE,OAAO8hB,EACF,CACL,MAAMrQ,EAAM,2FAEZ,OADA/B,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWY,mBAAmBkC,EAAMiF,IACjD,OAGXtB,QAASuJ,EAAWrH,cACpBxE,UAAW,EACT7F,UACAX,OACApG,SACCuI,EAAKkE,EAAWC,KACjB,IAAIlK,EAEJ,GAAsB,mBAAXke,OACTle,EAAMxC,aAAiB0gB,OAAS1gB,EAAMgO,SAAS,UAAY0S,OAAOC,KAAK3gB,EAAM6gB,QAAQ7S,SAAS,cACzF,IAAoB,mBAAT+S,KAOhB,MAAM,IAAI/Y,MAAM,4FAPqB,CACrC,IAAIlH,EAAI,GAER,IAAK,IAAI/B,EAAI,EAAGA,EAAIiB,EAAMoD,SAAUrE,EAAG+B,GAAKsJ,OAAO4W,aAAahhB,EAAMjB,IAEtEyD,EAAMue,KAAKjgB,IAOb,GAFKsF,IAAMA,EAAOqS,EAAWrH,cAAcC,aAEvCjL,IAASqC,EAAWnH,KAAKa,aAC3BnC,EAAQwC,MACH,CACL,MAAM,UACJ8O,GACEmH,EAAWrH,cACT5Q,EAAIuD,KAAKkd,KAAKze,EAAIY,OAASkO,GAC3B4P,EAAQ,IAAIle,MAAMxC,GAExB,IAAK,IAAIzB,EAAI,EAAGS,EAAI,EAAGT,EAAIyB,IAAKzB,EAAGS,GAAK8R,EACtC4P,EAAMniB,GAAKyD,EAAIqB,OAAOrE,EAAG8R,GAG3BtR,EAAQkhB,EAAMla,KAAKZ,IAASqC,EAAWnH,KAAKI,cAAgB,KAAO,KAGrE,OAAO+W,EAAWW,gBAAgB,CAChCrS,UACAX,OACApG,SACCuI,EAAKkE,EAAWC,KAIvB,SAASyU,EAAW1S,EAAK3L,GACvB,MAAMiL,EAAM0K,EAAWA,WAAWhK,EAAK3L,GAEvC,IAAK,IAAI/D,EAAI,EAAGA,EAAIgP,EAAIhC,MAAM3I,SAAUrE,EAAG,CACzC,IAAIqO,EAAOW,EAAIhC,MAAMhN,GACrB,KAAIqO,aAAgBqL,EAAWvK,MAA/B,CAAmD,GAAId,aAAgBqL,EAAW5H,QAAS,CACzF,GAAIzD,EAAKrB,MAAM3I,OAAS,EAAG,CACzB,MAAMoN,EAAM,iDACZ,MAAM,IAAI/H,EAAWD,kBAAkB1F,EAAK0N,GAG9C,MAAM5B,EAAOxB,EAAKrB,MAAM,IAAM,IAAI0M,EAAWvK,KACzCd,EAAKnB,gBAAe2C,EAAK3C,cAAgB2C,EAAK3C,cAAgB,GAAGmB,EAAKnB,kBAAkB2C,EAAK3C,gBAAkBmB,EAAKnB,eACpHmB,EAAKrG,UAAS6H,EAAK7H,QAAU6H,EAAK7H,QAAU,GAAGqG,EAAKrG,YAAY6H,EAAK7H,UAAYqG,EAAKrG,SAC1FqG,EAAOwB,EAETb,EAAIhC,MAAMhN,GAAKqO,aAAgBqL,EAAWvK,KAAOd,EAAO,IAAIqL,EAAWvK,KAAKd,IAG9E,OAAOW,EAET,SAASqT,EAAYxW,EAAQyW,EAAU9Y,GACrC,MAAMkW,EAAQ,IAAIhG,EAAW7K,QAAQhD,GACrC6T,EAAMrX,IAAM,0BAEZ,IAAK,MAAM0G,KAAMuT,EAAU,CACzB,IAAI/gB,EAAKN,EAET,GAAIgD,MAAMC,QAAQ6K,GAAK,CACrB,GAAkB,IAAdA,EAAG1K,OAGA,MAAM,IAAIke,UAAU,gCAAgCxT,GAFzDxN,EAAMwN,EAAG,GACT9N,EAAQ8N,EAAG,QAER,GAAIA,GAAMA,aAAcrO,OAAQ,CACrC,MAAM2Q,EAAO3Q,OAAO2Q,KAAKtC,GAEzB,GAAoB,IAAhBsC,EAAKhN,OAGF,MAAM,IAAIke,UAAU,kCAAkCxT,GAF3DxN,EAAM8P,EAAK,GACXpQ,EAAQ8N,EAAGxN,QAGbA,EAAMwN,EAGR,MAAMc,EAAOhE,EAAO4Q,WAAWlb,EAAKN,EAAOuI,GAC3CkW,EAAM1S,MAAMnJ,KAAKgM,GAGnB,OAAO6P,EAET,MAAMA,EAAQ,CACZ/C,SAAS,EACTtU,IAAK,0BACL6K,QAASkP,EACTnW,WAAYoW,GAGd,MAAMG,UAAiB9I,EAAW7K,QAChC,cACEzF,QAEAM,EAAWe,gBAAgBjF,KAAM,MAAOkU,EAAW5H,QAAQlQ,UAAU0K,IAAI9K,KAAKgE,OAE9EkE,EAAWe,gBAAgBjF,KAAM,SAAUkU,EAAW5H,QAAQlQ,UAAUgL,OAAOpL,KAAKgE,OAEpFkE,EAAWe,gBAAgBjF,KAAM,MAAOkU,EAAW5H,QAAQlQ,UAAUf,IAAIW,KAAKgE,OAE9EkE,EAAWe,gBAAgBjF,KAAM,MAAOkU,EAAW5H,QAAQlQ,UAAUuL,IAAI3L,KAAKgE,OAE9EkE,EAAWe,gBAAgBjF,KAAM,MAAOkU,EAAW5H,QAAQlQ,UAAU+K,IAAInL,KAAKgE,OAE9EA,KAAK6C,IAAMma,EAASna,IAGtB,OAAOE,EAAGiB,GACR,MAAM2B,EAAM,IAAImE,IACZ9F,GAAOA,EAAI+B,UAAU/B,EAAI+B,SAASJ,GAEtC,IAAK,MAAM0E,KAAQrK,KAAKwH,MAAO,CAC7B,IAAIzL,EAAKN,EAST,GAPI4O,aAAgB6J,EAAWvK,MAC7B5N,EAAMmY,EAAWzO,OAAO4E,EAAKtO,IAAK,GAAIiI,GACtCvI,EAAQyY,EAAWzO,OAAO4E,EAAK5O,MAAOM,EAAKiI,IAE3CjI,EAAMmY,EAAWzO,OAAO4E,EAAM,GAAIrG,GAGhC2B,EAAIgC,IAAI5L,GAAM,MAAM,IAAI0H,MAAM,gDAClCkC,EAAIwB,IAAIpL,EAAKN,GAGf,OAAOkK,GAKXzB,EAAWe,gBAAgB+X,EAAU,MAAO,0BA6B5C,MAAM/C,EAAO,CACX1C,SAAU9b,GAASA,aAAiBqO,IACpCsN,UAAW4F,EACX7F,SAAS,EACTtU,IAAK,yBACL6K,QAhCF,SAAmBxD,EAAK3L,GACtB,MAAM2b,EAAQ0C,EAAW1S,EAAK3L,GACxB0e,EAAW,GAEjB,IAAK,MAAM,IACTlhB,KACGme,EAAM1S,MACT,GAAIzL,aAAemY,EAAW/N,OAAQ,CACpC,GAAI8W,EAASlU,SAAShN,EAAIN,OAAQ,CAChC,MAAMwQ,EAAM,+CACZ,MAAM,IAAI/H,EAAWD,kBAAkB1F,EAAK0N,GAE5CgR,EAAS5e,KAAKtC,EAAIN,OAKxB,OAAOP,OAAOsN,OAAO,IAAIwU,EAAY9C,IAgBrCzT,WAbF,SAAoBJ,EAAQyW,EAAU9Y,GACpC,MAAMkW,EAAQ2C,EAAYxW,EAAQyW,EAAU9Y,GACtCiW,EAAO,IAAI+C,EAEjB,OADA/C,EAAKzS,MAAQ0S,EAAM1S,MACZyS,IAYT,MAAMiD,UAAgBhJ,EAAW5H,QAC/B,cACE1I,QACA5D,KAAK6C,IAAMqa,EAAQra,IAGrB,IAAI9G,GACF,MAAMsO,EAAOtO,aAAemY,EAAWvK,KAAO5N,EAAM,IAAImY,EAAWvK,KAAK5N,GAC3DmY,EAAW7H,SAASrM,KAAKwH,MAAO6C,EAAKtO,MACvCiE,KAAKwH,MAAMnJ,KAAKgM,GAG7B,IAAItO,EAAKohB,GACP,MAAM9S,EAAO6J,EAAW7H,SAASrM,KAAKwH,MAAOzL,GAC7C,OAAQohB,GAAY9S,aAAgB6J,EAAWvK,KAAOU,EAAKtO,eAAemY,EAAW/N,OAASkE,EAAKtO,IAAIN,MAAQ4O,EAAKtO,IAAMsO,EAG5H,IAAItO,EAAKN,GACP,GAAqB,kBAAVA,EAAqB,MAAM,IAAIgI,MAAM,wEAAwEhI,GACxH,MAAMkF,EAAOuT,EAAW7H,SAASrM,KAAKwH,MAAOzL,GAEzC4E,IAASlF,EACXuE,KAAKwH,MAAM8B,OAAOtJ,KAAKwH,MAAMpJ,QAAQuC,GAAO,IAClCA,GAAQlF,GAClBuE,KAAKwH,MAAMnJ,KAAK,IAAI6V,EAAWvK,KAAK5N,IAIxC,OAAOgH,EAAGiB,GACR,OAAOJ,MAAM6B,OAAO1C,EAAGiB,EAAK+F,KAG9B,SAAS/F,EAAKkE,EAAWC,GACvB,IAAKnE,EAAK,OAAO0F,KAAKrB,UAAUrI,MAChC,GAAIA,KAAKuI,mBAAoB,OAAO3E,MAAM6F,SAASzF,EAAKkE,EAAWC,GAAkB,MAAM,IAAI1E,MAAM,wCAKzGS,EAAWe,gBAAgBiY,EAAS,MAAO,yBAgB3C,MAAM/V,EAAM,CACVoQ,SAAU9b,GAASA,aAAiBsO,IACpCqN,UAAW8F,EACX/F,SAAS,EACTtU,IAAK,wBACL6K,QAnBF,SAAkBxD,EAAK3L,GACrB,MAAMoH,EAAMuO,EAAWlB,WAAW9I,EAAK3L,GACvC,IAAKoH,EAAI4C,mBAAoB,MAAM,IAAIrE,EAAWD,kBAAkB1F,EAAK,uCACzE,OAAOrD,OAAOsN,OAAO,IAAI0U,EAAWvX,IAiBpCc,WAdF,SAAmBJ,EAAQyW,EAAU9Y,GACnC,MAAMmD,EAAM,IAAI+V,EAEhB,IAAK,MAAMzhB,KAASqhB,EAAU3V,EAAIK,MAAMnJ,KAAKgI,EAAO4Q,WAAWxb,EAAO,KAAMuI,IAE5E,OAAOmD,IAYHiW,EAAmB,CAAC1D,EAAM2D,KAC9B,MAAMphB,EAAIohB,EAAMjP,MAAM,KAAKxF,OAAO,CAAC3M,EAAGK,IAAU,GAAJL,EAASiK,OAAO5J,GAAI,GAChE,MAAgB,MAATod,GAAgBzd,EAAIA,GAIvBqhB,EAAuB,EAC3B7hB,YAEA,GAAImZ,MAAMnZ,KAAWkZ,SAASlZ,GAAQ,OAAOyY,EAAWO,gBAAgBhZ,GACxE,IAAIie,EAAO,GAEPje,EAAQ,IACVie,EAAO,IACPje,EAAQ+D,KAAKsa,IAAIre,IAGnB,MAAM4hB,EAAQ,CAAC5hB,EAAQ,IAcvB,OAZIA,EAAQ,GACV4hB,EAAME,QAAQ,IAEd9hB,EAAQ+D,KAAKC,OAAOhE,EAAQ4hB,EAAM,IAAM,IACxCA,EAAME,QAAQ9hB,EAAQ,IAElBA,GAAS,KACXA,EAAQ+D,KAAKC,OAAOhE,EAAQ4hB,EAAM,IAAM,IACxCA,EAAME,QAAQ9hB,KAIXie,EAAO2D,EAAM1X,IAAI1J,GAAKA,EAAI,GAAK,IAAM4J,OAAO5J,GAAK4J,OAAO5J,IAAIwG,KAAK,KAAK+C,QAAQ,aAAc,KAI/F2U,EAAU,CACd5C,SAAU9b,GAA0B,iBAAVA,EAC1B0b,SAAS,EACTtU,IAAK,wBACL2K,OAAQ,OACRC,KAAM,2CACNC,QAAS,CAACpN,EAAKoZ,EAAM2D,IAAUD,EAAiB1D,EAAM2D,EAAM7X,QAAQ,KAAM,KAC1E6C,UAAWiV,GAEPlD,EAAY,CAChB7C,SAAU9b,GAA0B,iBAAVA,EAC1B0b,SAAS,EACTtU,IAAK,0BACL2K,OAAQ,OACRC,KAAM,oDACNC,QAAS,CAACpN,EAAKoZ,EAAM2D,IAAUD,EAAiB1D,EAAM2D,EAAM7X,QAAQ,KAAM,KAC1E6C,UAAWiV,GAEPjD,EAAY,CAChB9C,SAAU9b,GAASA,aAAiB+hB,KACpCrG,SAAS,EACTtU,IAAK,8BAIL4K,KAAMgQ,OAAO,iKAKb/P,QAAS,CAACpN,EAAKod,EAAMC,EAAOC,EAAKC,EAAMC,EAAQC,EAAQC,EAAUC,KAC3DD,IAAUA,GAAYA,EAAW,MAAM1e,OAAO,EAAG,IACrD,IAAI4e,EAAOV,KAAKW,IAAIT,EAAMC,EAAQ,EAAGC,EAAKC,GAAQ,EAAGC,GAAU,EAAGC,GAAU,EAAGC,GAAY,GAE3F,GAAIC,GAAa,MAAPA,EAAY,CACpB,IAAInjB,EAAIsiB,EAAiBa,EAAG,GAAIA,EAAG7e,MAAM,IACrCI,KAAKsa,IAAIhf,GAAK,KAAIA,GAAK,IAC3BojB,GAAQ,IAAQpjB,EAGlB,OAAO,IAAI0iB,KAAKU,IAElB7V,UAAW,EACT5M,WACIA,EAAM2iB,cAAc5Y,QAAQ,yBAA0B,KAI9D,SAAS6Y,EAAWC,GAClB,MAAMC,EAAyB,oBAAZC,SAA2BA,QAAQD,KAAO,GAE7D,OAAID,EAC+C,oBAAtCG,mCAA2DA,mCAC9DF,EAAIE,kCAGuB,oBAA1BC,uBAA+CA,uBAClDH,EAAIG,sBAGd,SAASzK,EAAK0K,EAAS9c,GACrB,GAAIwc,GAAW,GAAQ,CACrB,MAAMO,EAA0B,oBAAZJ,SAA2BA,QAAQK,YAGnDD,EAAMA,EAAKD,EAAS9c,GAEtBid,QAAQ7K,KAAKpS,EAAO,GAAGA,MAAS8c,IAAYA,IAUlD,MAAMI,EAAS,GAUfzkB,EAAQ0f,OAASA,EACjB1f,EAAQ8f,UAAYA,EACpB9f,EAAQ6f,QAAUA,EAClB7f,EAAQ2f,KAAOA,EACf3f,EAAQ4f,MAAQA,EAChB5f,EAAQ6M,IAAMA,EACd7M,EAAQ+f,UAAYA,EACpB/f,EAAQ2Z,KAAOA,EACf3Z,EAAQ0kB,oBAxBR,SAA6BxJ,GAC3B,GAAI6I,GAAW,GAAO,CAEpBpK,EAAK,sBADQuB,EAAShQ,QAAQ,eAAgB,IAAIA,QAAQ,QAAS,IAAIA,QAAQ,MAAO,6CACb,wBAsB7ElL,EAAQuhB,sBAlBR,SAA+B9gB,EAAMkkB,GACnC,IAAKF,EAAOhkB,IAASsjB,GAAW,GAAO,CACrCU,EAAOhkB,IAAQ,EACf,IAAIkR,EAAM,eAAelR,yCACzBkR,GAAOgT,EAAc,UAAUA,cAA0B,IACzDhL,EAAKhI,EAAK,yB,cClZd1R,EAAOD,QAAUkC,QAAQ,U,6aCEzB,aACA,OACA,QACA,QAGA,oBAAyBmC,GAIrB,MAEMugB,EAAmC,CACrC,CAAC,MAFS,GAGV,CAAC,KAJQ,GAKT,CAAC,KALQ,GAMT,CAAC,MANQ,GAOT,CAAC,OANS,GAOV,CAAC,OAPS,GAQV,CAAC,OATQ,GAUT,CAAC,OAVQ,IAYb,IAAK,MAAMC,KAAUD,EAAS,CAC1B,MAAOE,EAAW5I,GAAc2I,EAC1BE,EAAK,0CAA0CD,EAAUE,cACzDC,EAAa5J,EAAI6J,SAASC,gBAC5BJ,EACA,IAAMK,EAASN,EAAW5I,IAE9B7X,EAAQghB,cAActhB,KAAKkhB,GAG/B5gB,EAAQghB,cAActhB,KAClBsX,EAAI6J,SAASC,gBACT,wDACA,UAAYG,cAIpBjhB,EAAQghB,cAActhB,KAClBsX,EAAI6J,SAASC,gBACT,4CACA,UAAMI,OAIdlhB,EAAQghB,cAActhB,KAClBsX,EAAI6J,SAASC,gBACT,sCACA,KACkB9J,EAAIgB,OAAOmJ,mBACrB,OACA,oBACAnK,EAAIc,WAAWsJ,OACf,CACIC,eAAe,EACfC,mBAAmB,IAGrBC,QAAQC,KAAO,mgBA6BrC,0BAGA,MAAMC,EAAmD,CACrDC,IAAK,CAAC,KAAM,MACZC,GAAI,CAAC,MAAO,MACZC,GAAI,CAAC,KAAM,OACX9R,KAAM,CAAC,MAAO,OAAQ,OACtB+R,KAAM,CAAC,MAAO,OAAQ,QAE1B,SAAed,EAASN,EAAmB5I,G,yCACvC,MAAMiK,EAAe9K,EAAIgB,OAAO+J,iBAChC,IAAKD,EAED,YADA9K,EAAIgB,OAAOgK,iBAAiB,0BAIhC,SAmBJ,SACIvB,EACA5I,EACAiK,G,yCAEA,MAAMG,EAAuB,CAACxB,GACxByB,EAAYT,EAAoBhB,GAClC3gB,MAAMC,QAAQmiB,IACdD,EAAWviB,QAAQwiB,GAGvB,IAAK,MAAMC,KAAOF,EAAY,CAC1B,MAAMpL,EAAmB,UAAKS,gBAC1BwK,EAAaM,SAASC,SACtBF,GAEJ,IAAK,UAAK1L,OAAOI,GAAW,SAE5B,MAAMtL,QAAY,UAAKqL,iBAAiBC,GACxC,OAAY,OAARtL,IACJyL,EAAIgB,OAAOC,iBAAiB1M,EAAK,CAAEsM,gBAC5B,GAGX,OAAO,KA3CGyK,CAAiB7B,EAAW5I,EAAYiK,GAAe,OAIjE,MAAMjL,EAAmB,UAAKS,gBAC1BwK,EAAaM,SAASC,SACtB5B,GAEJ,UAAKtI,cAActB,EAsCvB,SAA2B4J,EAAmB8B,GAC1C,OAAQ9B,GACJ,IAAK,OAAQ,MAMV,mFAJP,MAAO,GA1CsB+B,CAAkB/B,EAAWqB,EAAaM,SAASC,WAChF,MAAM9W,QAAY,UAAKqL,iBAAiBC,GAC5B,OAARtL,EACAyL,EAAIgB,OAAOC,iBAAiB1M,EAAK,CAAEsM,eAEnCb,EAAIgB,OAAOgK,iBACP,wBAAwBnL,Y,+FCzHpC,YAAS,yEAAA2B,Y,8YCET,aACA,OACA,QACA,QACA,OACA,QAGA,UAAe,CACX0I,KAGJ,W,yCACI,IACI,MAAMuB,QAAgBC,EAAE1K,OAAO2K,aAAa,CACxCC,OAAQ,uFACR9lB,MAAO,sGAEX,IAAK2lB,EAAS,OACd,MAAMI,EAAoBH,EAAE1K,OAAO8K,oBAAoB,YAAYL,GAC7DM,EA6Fd,SAAkCC,G,yCAC9B,IACI,MAAMC,QAAsB,UAAMD,GAC5BE,QAAqBD,EAAc/T,OAEzC,OADAiR,QAAQgD,IAAI,eAAgBD,GACrBA,EACT,MAAOE,GACL,KAAM,4BAA6BJ,UAAaI,QApGpBC,CAAmBZ,GAEzCa,QAAiBZ,EAAE1K,OAAO2K,aAAa,CACzCC,OAAQ,qCACR9lB,MAAO,OACPymB,cAAeC,IAEnB,IAAKF,EAAU,OACf,MAAMG,QAAmBV,EAEzB,GADAF,EAAkBa,WACbD,EAAY,OAEjB,MAAME,EAsGd,SAA4BF,G,yCACxB,MAAMG,EAAS,UAAOnjB,MAAMgjB,GAE5B,IAAIZ,EAAoBH,EAAE1K,OAAO8K,oBAAoB,yBACrD,IAAK,IAAIjnB,EAAI,EAAGA,EAAI+nB,EAAOC,KAAK3jB,OAAQrE,IAAK,CACzC,MAAMmnB,EAAMY,EAAOC,KAAKhoB,GACxB,IACIgnB,EAAkBa,UAClBb,EAAoBH,EAAE1K,OAAO8K,oBAAoB,gBAAgBjnB,EAAI,OAAO+nB,EAAOC,KAAK3jB,UACxF,MAAM4jB,QAAiB,UAAMd,GAC7B,IAAKc,EAASC,GACV,KAAM,SAASD,EAASE,WAAWF,EAASG,aAEhD,MAAMC,QAAoBJ,EAASI,cACnCN,EAAOO,KAAKzkB,KAAKwkB,GACnB,MAAOd,GACLQ,EAAOO,KAAKzkB,KAAK,MACjBgjB,EAAE1K,OAAOgK,iBACL,uBAAuBnmB,EAAI,OAAO+nB,EAAOC,KAAK3jB,YAAY8iB,QAAUI,MAMhF,OAFAP,EAAkBa,UAEX,CACHU,IAAKR,EAAOS,OAAOrd,IAAI,CAACsd,EAAOC,IACN,iBAAVD,EACA,KAAKA,KAASE,EAAaZ,EAAOC,KAAKS,MAE3CA,GACRxgB,KAAK,IACR2gB,MAAOb,EAAOO,KAAKnd,IAAI,CAACmd,EAAMI,KAAU,CACpCJ,OACAtN,SAAU,GAAG0N,KAASC,EAAaZ,EAAOC,KAAKU,aAvI9BG,CAAajB,GAE5BkB,EA6Dd,WACI,MAAMC,EAASlC,EAAE1K,OAAO+J,iBACxB,GAAI6C,EAAQ,CACR,MAAMjd,EAAekd,EAAKC,QAAQF,EAAOxC,SAASC,UAClD,OAAOK,EAAEqC,IAAIC,KAAKrd,GAGtB,MAAMsd,EAAUvC,EAAEzL,UAAUiO,iBAC5B,OAAKD,EACEA,EAAQ,GAAGE,SADJ,EArE4BC,GAChCC,QAAa3C,EAAE1K,OAAOsN,eAAe,CACvCX,aACAY,gBAAgB,EAChBC,kBAAkB,EAClBC,eAAe,EACfC,UAAW,SACXC,MAAO,iCAEX,IAAKN,EAAM,OACX,MAAMF,EAAME,EAAK,GACX1d,EAAOkd,EAAK9V,QAAQoW,EAAIxd,KAAM2b,GACpC,GAAI5M,EAAGC,WAAWhP,GAKd,YAJA+a,EAAE1K,OAAOgK,iBACL,mCAAmCra,EACnC,CAAEie,OAAO,UAIXlD,EAAEzL,UAAU4O,GAAGC,gBAAgBpD,EAAEqC,IAAIC,KAAKrd,IAChD,MAAMoe,QAAcpC,EACpB,IAAK,MAAMqC,KAAYD,EAAMtB,MACpBuB,EAAS7B,MAEdzN,EAAG2B,cACCwM,EAAK9V,QAAQpH,EAAMqe,EAASnP,UAC5B,IAAI0G,WAAWyI,EAAS7B,OAGhC,MAAM8B,EAAcpB,EAAK9V,QAAQpH,EAAS2b,EAAH,QACvC5M,EAAG2B,cAAc4N,EAAaF,EAAM3B,WAC9B,UAAKxM,iBAAiBqO,EAAavD,EAAE5K,WAAWC,QAEtD,MAAMmO,EAAoBrB,EAAK9V,QAAQpH,EAAM,KAAM,WACnD,GAAI+O,EAAGC,WAAWuP,GAAoB,CAClCxP,EAAG2B,cACCwM,EAAK9V,QAAQpH,EAAM,YACnB,4BAA4B2b,QAEhC,MAAM6C,EAActB,EAAK9V,QAAQpH,EAAS2b,EAAH,OACvC5M,EAAG2B,cACC8N,EACA,8CACJ7C,4DAEqCA,yCACjBA,eAGd,UAAK1L,iBAAiBuO,EAAazD,EAAE5K,WAAWsJ,aAEtDsB,EAAE1K,OAAOoO,uBAAuBF,GAEtC,MAAO9C,GACLV,EAAE1K,OAAOgK,iBACL,GAAGoB,EACH,CAAEwC,OAAO,UAiBrB,MAAMS,EAAgB,iCAEtB,SAAS7C,EAAY8C,GACjB,OAAOD,EAAcvX,KAAKwX,GAAS,GAAK,oEA8D5C,SAAS9B,EAAa3N,GAClB,MACM0P,EAAW1P,EAASQ,YAAY,KACtC,OAFmB,IAEfkP,EAA+B,GAC5B1P,EAASlW,OAAO4lB,EAAW,K,cClLtC3qB,EAAOD,QAAUkC,QAAQ,S,6BCAzB,mNASA,MAAM2oB,EAAW,EAAOA,SAElBC,EAAS7pB,OAAO,UAChB8pB,EAAO9pB,OAAO,QAEpB,MAAM+pB,EACL,cACCtlB,KAAKqlB,GAAQ,GAEb,MAAME,EAAYC,UAAU,GACtB7a,EAAU6a,UAAU,GAEpBC,EAAU,GAChB,IAAIC,EAAO,EAEX,GAAIH,EAAW,CACd,MAAMxZ,EAAIwZ,EACJ1mB,EAASqH,OAAO6F,EAAElN,QACxB,IAAK,IAAIrE,EAAI,EAAGA,EAAIqE,EAAQrE,IAAK,CAChC,MAAMmrB,EAAU5Z,EAAEvR,GAClB,IAAI8hB,EAEHA,EADGqJ,aAAmBxJ,OACbwJ,EACCC,YAAYC,OAAOF,GACpBxJ,OAAOC,KAAKuJ,EAAQrJ,OAAQqJ,EAAQG,WAAYH,EAAQI,YACvDJ,aAAmBC,YACpBzJ,OAAOC,KAAKuJ,GACXA,aAAmBL,EACpBK,EAAQP,GAERjJ,OAAOC,KAAwB,iBAAZuJ,EAAuBA,EAAU9f,OAAO8f,IAErED,GAAQpJ,EAAOzd,OACf4mB,EAAQpnB,KAAKie,IAIftc,KAAKolB,GAAUjJ,OAAO1K,OAAOgU,GAE7B,IAAI5jB,EAAO8I,QAA4BzD,IAAjByD,EAAQ9I,MAAsBgE,OAAO8E,EAAQ9I,MAAMmkB,cACrEnkB,IAAS,mBAAmB4L,KAAK5L,KACpC7B,KAAKqlB,GAAQxjB,GAGf,WACC,OAAO7B,KAAKolB,GAAQvmB,OAErB,WACC,OAAOmB,KAAKqlB,GAEb,OACC,OAAO5P,QAAQ/H,QAAQ1N,KAAKolB,GAAQ3b,YAErC,cACC,MAAMwc,EAAMjmB,KAAKolB,GACXc,EAAKD,EAAI3J,OAAOld,MAAM6mB,EAAIH,WAAYG,EAAIH,WAAaG,EAAIF,YACjE,OAAOtQ,QAAQ/H,QAAQwY,GAExB,SACC,MAAMC,EAAW,IAAIhB,EAIrB,OAHAgB,EAASC,MAAQ,aACjBD,EAAS9nB,KAAK2B,KAAKolB,IACnBe,EAAS9nB,KAAK,MACP8nB,EAER,WACC,MAAO,gBAER,QACC,MAAMT,EAAO1lB,KAAK0lB,KAEZ5mB,EAAQ0mB,UAAU,GAClBtmB,EAAMsmB,UAAU,GACtB,IAAIa,EAAeC,EAElBD,OADanf,IAAVpI,EACa,EACNA,EAAQ,EACFU,KAAKoM,IAAI8Z,EAAO5mB,EAAO,GAEvBU,KAAKI,IAAId,EAAO4mB,GAGhCY,OADWpf,IAARhI,EACWwmB,EACJxmB,EAAM,EACFM,KAAKoM,IAAI8Z,EAAOxmB,EAAK,GAErBM,KAAKI,IAAIV,EAAKwmB,GAE7B,MAAMa,EAAO/mB,KAAKoM,IAAI0a,EAAcD,EAAe,GAG7CG,EADSxmB,KAAKolB,GACQhmB,MAAMinB,EAAeA,EAAgBE,GAC3DE,EAAO,IAAInB,EAAK,GAAI,CAAEzjB,KAAM2jB,UAAU,KAE5C,OADAiB,EAAKrB,GAAUoB,EACRC,GA+BT,SAASC,EAAW/iB,EAAS9B,EAAM8kB,GACjCljB,MAAM9I,KAAKqF,KAAM2D,GAEjB3D,KAAK2D,QAAUA,EACf3D,KAAK6B,KAAOA,EAGR8kB,IACF3mB,KAAK0O,KAAO1O,KAAK4mB,MAAQD,EAAYjY,MAIvCjL,MAAMojB,kBAAkB7mB,KAAMA,KAAK8mB,aAOrC,IAAIC,EA9CJ7rB,OAAO8rB,iBAAiB1B,EAAKlpB,UAAW,CACvCspB,KAAM,CAAEtqB,YAAY,GACpByG,KAAM,CAAEzG,YAAY,GACpBgE,MAAO,CAAEhE,YAAY,KAGtBF,OAAOC,eAAemqB,EAAKlpB,UAAWb,OAAOC,YAAa,CACzDC,MAAO,OACPsG,UAAU,EACV3G,YAAY,EACZ+J,cAAc,IAgCfuhB,EAAWtqB,UAAYlB,OAAOY,OAAO2H,MAAMrH,WAC3CsqB,EAAWtqB,UAAU0qB,YAAcJ,EACnCA,EAAWtqB,UAAUrB,KAAO,aAG5B,IACCgsB,EAAUvqB,QAAQ,YAAYuqB,QAC7B,MAAOE,IAET,MAAMC,EAAY3rB,OAAO,kBAGnB4rB,EAAc,EAAOA,YAW3B,SAASC,EAAKlY,GACb,IAAImY,EAAQrnB,KAERsnB,EAAO9B,UAAU3mB,OAAS,QAAsBqI,IAAjBse,UAAU,GAAmBA,UAAU,GAAK,GAC3E+B,EAAYD,EAAK5B,KAErB,IAAIA,OAAqBxe,IAAdqgB,EAA0B,EAAIA,EACzC,IAAIC,EAAeF,EAAKG,QACxB,IAAIA,OAA2BvgB,IAAjBsgB,EAA6B,EAAIA,EAEnC,MAARtY,EAEHA,EAAO,KACGwY,EAAkBxY,GAE5BA,EAAOiN,OAAOC,KAAKlN,EAAKzF,YACdke,EAAOzY,IAAkBiN,OAAOyL,SAAS1Y,KAA2D,yBAAzChU,OAAOkB,UAAUqN,SAAS9O,KAAKuU,GAEpGA,EAAOiN,OAAOC,KAAKlN,GACT0W,YAAYC,OAAO3W,GAE7BA,EAAOiN,OAAOC,KAAKlN,EAAKoN,OAAQpN,EAAK4W,WAAY5W,EAAK6W,YAC5C7W,aAAgB,IAG1BA,EAAOiN,OAAOC,KAAKvW,OAAOqJ,MAE3BlP,KAAKknB,GAAa,CACjBhY,OACA2Y,WAAW,EACXlmB,MAAO,MAER3B,KAAK0lB,KAAOA,EACZ1lB,KAAKynB,QAAUA,EAEXvY,aAAgB,GACnBA,EAAK4Y,GAAG,SAAS,SAAUxY,GAC1B,MAAM3N,EAAqB,eAAb2N,EAAIvU,KAAwBuU,EAAM,IAAIoX,EAAW,+CAA+CW,EAAM1F,QAAQrS,EAAI3L,UAAW,SAAU2L,GACrJ+X,EAAMH,GAAWvlB,MAAQA,KA0H5B,SAASomB,IACR,IAAIC,EAAShoB,KAEb,GAAIA,KAAKknB,GAAWW,UACnB,OAAOT,EAAK3R,QAAQC,OAAO,IAAIqH,UAAU,0BAA0B/c,KAAK2hB,MAKzE,GAFA3hB,KAAKknB,GAAWW,WAAY,EAExB7nB,KAAKknB,GAAWvlB,MACnB,OAAOylB,EAAK3R,QAAQC,OAAO1V,KAAKknB,GAAWvlB,OAG5C,IAAIuN,EAAOlP,KAAKkP,KAGhB,GAAa,OAATA,EACH,OAAOkY,EAAK3R,QAAQ/H,QAAQyO,OAAO8L,MAAM,IAS1C,GALIN,EAAOzY,KACVA,EAAOA,EAAKgZ,UAIT/L,OAAOyL,SAAS1Y,GACnB,OAAOkY,EAAK3R,QAAQ/H,QAAQwB,GAI7B,KAAMA,aAAgB,GACrB,OAAOkY,EAAK3R,QAAQ/H,QAAQyO,OAAO8L,MAAM,IAK1C,IAAIE,EAAQ,GACRC,EAAa,EACbC,GAAQ,EAEZ,OAAO,IAAIjB,EAAK3R,SAAQ,SAAU/H,EAASgI,GAC1C,IAAI4S,EAGAN,EAAOP,UACVa,EAAaC,YAAW,WACvBF,GAAQ,EACR3S,EAAO,IAAIgR,EAAW,0CAA0CsB,EAAOrG,aAAaqG,EAAOP,aAAc,mBACvGO,EAAOP,UAIXvY,EAAK4Y,GAAG,SAAS,SAAUxY,GACT,eAAbA,EAAIvU,MAEPstB,GAAQ,EACR3S,EAAOpG,IAGPoG,EAAO,IAAIgR,EAAW,+CAA+CsB,EAAOrG,QAAQrS,EAAI3L,UAAW,SAAU2L,OAI/GJ,EAAK4Y,GAAG,QAAQ,SAAUU,GACzB,IAAIH,GAAmB,OAAVG,EAAb,CAIA,GAAIR,EAAOtC,MAAQ0C,EAAaI,EAAM3pB,OAASmpB,EAAOtC,KAGrD,OAFA2C,GAAQ,OACR3S,EAAO,IAAIgR,EAAW,mBAAmBsB,EAAOrG,mBAAmBqG,EAAOtC,OAAQ,aAInF0C,GAAcI,EAAM3pB,OACpBspB,EAAM9pB,KAAKmqB,OAGZtZ,EAAK4Y,GAAG,OAAO,WACd,IAAIO,EAAJ,CAIAI,aAAaH,GAEb,IACC5a,EAAQyO,OAAO1K,OAAO0W,EAAOC,IAC5B,MAAO9Y,GAERoG,EAAO,IAAIgR,EAAW,kDAAkDsB,EAAOrG,QAAQrS,EAAI3L,UAAW,SAAU2L,YA8EpH,SAASoY,EAAkBxiB,GAE1B,MAAmB,iBAARA,GAA0C,mBAAfA,EAAIwjB,QAA+C,mBAAfxjB,EAAIkC,QAA4C,mBAAZlC,EAAI7J,KAA4C,mBAAf6J,EAAIyjB,QAA4C,mBAAZzjB,EAAIyC,KAAyC,mBAAZzC,EAAIiC,MAKxL,oBAAzBjC,EAAI4hB,YAAY/rB,MAAsE,6BAAxCG,OAAOkB,UAAUqN,SAAS9O,KAAKuK,IAA2D,mBAAbA,EAAIgS,MAQvI,SAASyQ,EAAOziB,GACf,MAAsB,iBAARA,GAA+C,mBAApBA,EAAI2d,aAAkD,iBAAb3d,EAAIrD,MAA2C,mBAAfqD,EAAIgjB,QAAoD,mBAApBhjB,EAAI4hB,aAA8D,iBAAzB5hB,EAAI4hB,YAAY/rB,MAAqB,gBAAgB0S,KAAKvI,EAAI4hB,YAAY/rB,OAAS,gBAAgB0S,KAAKvI,EAAI3J,OAAOC,cASnT,SAASotB,EAAMC,GACd,IAAIC,EAAIC,EACJ7Z,EAAO2Z,EAAS3Z,KAGpB,GAAI2Z,EAASG,SACZ,MAAM,IAAIvlB,MAAM,sCAgBjB,OAXIyL,aAAgB,GAAsC,mBAArBA,EAAK+Z,cAEzCH,EAAK,IAAI3B,EACT4B,EAAK,IAAI5B,EACTjY,EAAKga,KAAKJ,GACV5Z,EAAKga,KAAKH,GAEVF,EAAS3B,GAAWhY,KAAO4Z,EAC3B5Z,EAAO6Z,GAGD7Z,EAYR,SAASia,EAAmBja,GAC3B,OAAa,OAATA,EAEI,KACmB,iBAATA,EAEV,2BACGwY,EAAkBxY,GAErB,kDACGyY,EAAOzY,GAEVA,EAAKrN,MAAQ,KACVsa,OAAOyL,SAAS1Y,IAGyB,yBAAzChU,OAAOkB,UAAUqN,SAAS9O,KAAKuU,IAG/B0W,YAAYC,OAAO3W,GAJtB,KAO+B,mBAArBA,EAAK+Z,YAEf,gCAAgC/Z,EAAK+Z,cAClC/Z,aAAgB,EAGnB,KAGA,2BAaT,SAASka,EAAcP,GACtB,MAAM3Z,EAAO2Z,EAAS3Z,KAGtB,OAAa,OAATA,EAEI,EACGyY,EAAOzY,GACVA,EAAKwW,KACFvJ,OAAOyL,SAAS1Y,GAEnBA,EAAKrQ,OACFqQ,GAAsC,mBAAvBA,EAAKma,gBAE1Bna,EAAKoa,mBAAsD,GAAjCpa,EAAKoa,kBAAkBzqB,QACrDqQ,EAAKqa,gBAAkBra,EAAKqa,kBAEpBra,EAAKma,gBAKN,KA1ZTjC,EAAKhrB,UAAY,CAChB,WACC,OAAO4D,KAAKknB,GAAWhY,MAGxB,eACC,OAAOlP,KAAKknB,GAAWW,WAQxB,cACC,OAAOE,EAAYptB,KAAKqF,MAAM6V,MAAK,SAAUoQ,GAC5C,OAAOA,EAAI3J,OAAOld,MAAM6mB,EAAIH,WAAYG,EAAIH,WAAaG,EAAIF,gBAS/D,OACC,IAAIyD,EAAKxpB,KAAKypB,SAAWzpB,KAAKypB,QAAQpuB,IAAI,iBAAmB,GAC7D,OAAO0sB,EAAYptB,KAAKqF,MAAM6V,MAAK,SAAUoQ,GAC5C,OAAO/qB,OAAOsN,OAEd,IAAI8c,EAAK,GAAI,CACZzjB,KAAM2nB,EAAGxD,gBACN,CACH,CAACZ,GAASa,QAUb,OACC,IAAIyD,EAAS1pB,KAEb,OAAO+nB,EAAYptB,KAAKqF,MAAM6V,MAAK,SAAUyG,GAC5C,IACC,OAAO5S,KAAKigB,MAAMrN,EAAO7S,YACxB,MAAO6F,GACR,OAAO8X,EAAK3R,QAAQC,OAAO,IAAIgR,EAAW,iCAAiCgD,EAAO/H,eAAerS,EAAI3L,UAAW,sBAUnH,OACC,OAAOokB,EAAYptB,KAAKqF,MAAM6V,MAAK,SAAUyG,GAC5C,OAAOA,EAAO7S,eAShB,SACC,OAAOse,EAAYptB,KAAKqF,OASzB,gBACC,IAAI4pB,EAAS5pB,KAEb,OAAO+nB,EAAYptB,KAAKqF,MAAM6V,MAAK,SAAUyG,GAC5C,OAwIH,SAAqBA,EAAQmN,GAC5B,GAAuB,mBAAZ1C,EACV,MAAM,IAAItjB,MAAM,gFAGjB,MAAM+lB,EAAKC,EAAQpuB,IAAI,gBACvB,IACI2K,EAAK1F,EADLupB,EAAU,QAIVL,IACHxjB,EAAM,mBAAmB8jB,KAAKN,IAI/BlpB,EAAMgc,EAAOld,MAAM,EAAG,MAAMqK,YAGvBzD,GAAO1F,IACX0F,EAAM,iCAAiC8jB,KAAKxpB,KAIxC0F,GAAO1F,IACX0F,EAAM,yEAAyE8jB,KAAKxpB,GAC/E0F,IACJA,EAAM,yEAAyE8jB,KAAKxpB,GAChF0F,GACHA,EAAIoO,OAIFpO,IACHA,EAAM,gBAAgB8jB,KAAK9jB,EAAIoO,UAK5BpO,GAAO1F,IACX0F,EAAM,mCAAmC8jB,KAAKxpB,IAI3C0F,IACH6jB,EAAU7jB,EAAIoO,MAIE,WAAZyV,GAAoC,QAAZA,IAC3BA,EAAU,YAKZ,OAAO9C,EAAQzK,EAAQ,QAASuN,GAASpgB,WA9LhCsgB,CAAYzN,EAAQsN,EAAOH,cAMrCvuB,OAAO8rB,iBAAiBI,EAAKhrB,UAAW,CACvC8S,KAAM,CAAE9T,YAAY,GACpB4tB,SAAU,CAAE5tB,YAAY,GACxBynB,YAAa,CAAEznB,YAAY,GAC3BqrB,KAAM,CAAErrB,YAAY,GACpBqT,KAAM,CAAErT,YAAY,GACpByS,KAAM,CAAEzS,YAAY,KAGrBgsB,EAAK4C,MAAQ,SAAUC,GACtB,IAAK,MAAMlvB,KAAQG,OAAOgvB,oBAAoB9C,EAAKhrB,WAElD,KAAMrB,KAAQkvB,GAAQ,CACrB,MAAME,EAAOjvB,OAAOkvB,yBAAyBhD,EAAKhrB,UAAWrB,GAC7DG,OAAOC,eAAe8uB,EAAOlvB,EAAMovB,KA+UtC/C,EAAK3R,QAAU4U,OAAO5U,QAQtB,MAAM6U,EAAoB,gCACpBC,EAAyB,0BAE/B,SAASC,EAAazvB,GAErB,GADAA,EAAO,GAAGA,EACNuvB,EAAkB7c,KAAK1S,IAAkB,KAATA,EACnC,MAAM,IAAIgiB,UAAahiB,EAAH,oCAItB,SAAS0vB,EAAchvB,GAEtB,GADAA,EAAQ,GAAGA,EACP8uB,EAAuB9c,KAAKhS,GAC/B,MAAM,IAAIshB,UAAathB,EAAH,qCAYtB,SAASqQ,EAAKnG,EAAK5K,GAClBA,EAAOA,EAAKirB,cACZ,IAAK,MAAMjqB,KAAO4J,EACjB,GAAI5J,EAAIiqB,gBAAkBjrB,EACzB,OAAOgB,EAMV,MAAMyB,EAAMjC,OAAO,OACnB,MAAMmvB,EAOL,cACC,IAAIC,EAAOnF,UAAU3mB,OAAS,QAAsBqI,IAAjBse,UAAU,GAAmBA,UAAU,QAAKte,EAI/E,GAFAlH,KAAKxC,GAAOtC,OAAOY,OAAO,MAEtB6uB,aAAgBD,EAApB,CACC,MAAME,EAAaD,EAAKE,MAClBC,EAAc5vB,OAAO2Q,KAAK+e,GAEhC,IAAK,MAAMG,KAAcD,EACxB,IAAK,MAAMrvB,KAASmvB,EAAWG,GAC9B/qB,KAAK0oB,OAAOqC,EAAYtvB,QAS3B,GAAY,MAARkvB,OAAqB,IAAoB,iBAATA,EA+BnC,MAAM,IAAI5N,UAAU,0CA/BkC,CACtD,MAAMiO,EAASL,EAAKpvB,OAAOoL,UAC3B,GAAc,MAAVqkB,EAAgB,CACnB,GAAsB,mBAAXA,EACV,MAAM,IAAIjO,UAAU,iCAKrB,MAAM7C,EAAQ,GACd,IAAK,MAAM7P,KAAQsgB,EAAM,CACxB,GAAoB,iBAATtgB,GAAsD,mBAA1BA,EAAK9O,OAAOoL,UAClD,MAAM,IAAIoW,UAAU,qCAErB7C,EAAM7b,KAAKI,MAAM2d,KAAK/R,IAGvB,IAAK,MAAMA,KAAQ6P,EAAO,CACzB,GAAoB,IAAhB7P,EAAKxL,OACR,MAAM,IAAIke,UAAU,+CAErB/c,KAAK0oB,OAAOre,EAAK,GAAIA,EAAK,UAI3B,IAAK,MAAMtO,KAAOb,OAAO2Q,KAAK8e,GAAO,CACpC,MAAMlvB,EAAQkvB,EAAK5uB,GACnBiE,KAAK0oB,OAAO3sB,EAAKN,MAcrB,IAAIV,GAEHyvB,EADAzvB,EAAO,GAAGA,GAEV,MAAMgB,EAAM+P,EAAK9L,KAAKxC,GAAMzC,GAC5B,YAAYmM,IAARnL,EACI,KAGDiE,KAAKxC,GAAKzB,GAAK0G,KAAK,MAU5B,QAAQwoB,GACP,IAAIC,EAAU1F,UAAU3mB,OAAS,QAAsBqI,IAAjBse,UAAU,GAAmBA,UAAU,QAAKte,EAE9EgT,EAAQiR,EAAWnrB,MACnBxF,EAAI,EACR,KAAOA,EAAI0f,EAAMrb,QAAQ,CACxB,IAAIusB,EAAWlR,EAAM1f,GACrB,MAAMO,EAAOqwB,EAAS,GAChB3vB,EAAQ2vB,EAAS,GAEvBH,EAAStwB,KAAKuwB,EAASzvB,EAAOV,EAAMiF,MACpCka,EAAQiR,EAAWnrB,MACnBxF,KAWF,IAAIO,EAAMU,GAETA,EAAQ,GAAGA,EACX+uB,EAFAzvB,EAAO,GAAGA,GAGV0vB,EAAchvB,GACd,MAAMM,EAAM+P,EAAK9L,KAAKxC,GAAMzC,GAC5BiF,KAAKxC,QAAa0J,IAARnL,EAAoBA,EAAMhB,GAAQ,CAACU,GAU9C,OAAOV,EAAMU,GAEZA,EAAQ,GAAGA,EACX+uB,EAFAzvB,EAAO,GAAGA,GAGV0vB,EAAchvB,GACd,MAAMM,EAAM+P,EAAK9L,KAAKxC,GAAMzC,QAChBmM,IAARnL,EACHiE,KAAKxC,GAAKzB,GAAKsC,KAAK5C,GAEpBuE,KAAKxC,GAAKzC,GAAQ,CAACU,GAUrB,IAAIV,GAGH,OADAyvB,EADAzvB,EAAO,GAAGA,QAEuBmM,IAA1B4E,EAAK9L,KAAKxC,GAAMzC,GASxB,OAAOA,GAENyvB,EADAzvB,EAAO,GAAGA,GAEV,MAAMgB,EAAM+P,EAAK9L,KAAKxC,GAAMzC,QAChBmM,IAARnL,UACIiE,KAAKxC,GAAKzB,GASnB,MACC,OAAOiE,KAAKxC,GAQb,OACC,OAAO6tB,EAAsBrrB,KAAM,OAQpC,SACC,OAAOqrB,EAAsBrrB,KAAM,SAUpC,CAACzE,OAAOoL,YACP,OAAO0kB,EAAsBrrB,KAAM,cAwBrC,SAASmrB,EAAW1B,GACnB,IAAI6B,EAAO9F,UAAU3mB,OAAS,QAAsBqI,IAAjBse,UAAU,GAAmBA,UAAU,GAAK,YAE/E,MAAM3Z,EAAO3Q,OAAO2Q,KAAK4d,EAAQjsB,IAAM0Z,OACvC,OAAOrL,EAAKlG,IAAa,QAAT2lB,EAAiB,SAAU/kB,GAC1C,OAAOA,EAAEyf,eACG,UAATsF,EAAmB,SAAU/kB,GAChC,OAAOkjB,EAAQjsB,GAAK+I,GAAG9D,KAAK,OACzB,SAAU8D,GACb,MAAO,CAACA,EAAEyf,cAAeyD,EAAQjsB,GAAK+I,GAAG9D,KAAK,SA9BhDioB,EAAQtuB,UAAUmvB,QAAUb,EAAQtuB,UAAUb,OAAOoL,UAErDzL,OAAOC,eAAeuvB,EAAQtuB,UAAWb,OAAOC,YAAa,CAC5DC,MAAO,UACPsG,UAAU,EACV3G,YAAY,EACZ+J,cAAc,IAGfjK,OAAO8rB,iBAAiB0D,EAAQtuB,UAAW,CAC1Cf,IAAK,CAAED,YAAY,GACnBkI,QAAS,CAAElI,YAAY,GACvB+L,IAAK,CAAE/L,YAAY,GACnBstB,OAAQ,CAAEttB,YAAY,GACtBuM,IAAK,CAAEvM,YAAY,GACnBgM,OAAQ,CAAEhM,YAAY,GACtByQ,KAAM,CAAEzQ,YAAY,GACpBowB,OAAQ,CAAEpwB,YAAY,GACtBmwB,QAAS,CAAEnwB,YAAY,KAgBxB,MAAMqwB,EAAWlwB,OAAO,YAExB,SAAS8vB,EAAsBK,EAAQJ,GACtC,MAAM3kB,EAAWzL,OAAOY,OAAO6vB,GAM/B,OALAhlB,EAAS8kB,GAAY,CACpBC,SACAJ,OACApI,MAAO,GAEDvc,EAGR,MAAMglB,EAA2BzwB,OAAO0wB,eAAe,CACtD,OAEC,IAAK5rB,MAAQ9E,OAAO2wB,eAAe7rB,QAAU2rB,EAC5C,MAAM,IAAI5O,UAAU,4CAGrB,IAAI+O,EAAY9rB,KAAKyrB,GACrB,MAAMC,EAASI,EAAUJ,OACnBJ,EAAOQ,EAAUR,KACjBpI,EAAQ4I,EAAU5I,MAElBsI,EAASL,EAAWO,EAAQJ,GAElC,OAAIpI,GADQsI,EAAO3sB,OAEX,CACNpD,WAAOyL,EACPN,MAAM,IAIR5G,KAAKyrB,GAAUvI,MAAQA,EAAQ,EAExB,CACNznB,MAAO+vB,EAAOtI,GACdtc,MAAM,MAGN1L,OAAO2wB,eAAe3wB,OAAO2wB,eAAe,GAAGtwB,OAAOoL,eAezD,SAASolB,EAA4BtC,GACpC,MAAMvkB,EAAMhK,OAAOsN,OAAO,CAAEwjB,UAAW,MAAQvC,EAAQjsB,IAIjDyuB,EAAgBngB,EAAK2d,EAAQjsB,GAAM,QAKzC,YAJsB0J,IAAlB+kB,IACH/mB,EAAI+mB,GAAiB/mB,EAAI+mB,GAAe,IAGlC/mB,EAvBRhK,OAAOC,eAAewwB,EAA0BpwB,OAAOC,YAAa,CACnEC,MAAO,kBACPsG,UAAU,EACV3G,YAAY,EACZ+J,cAAc,IAqDf,MAAM+mB,EAAc3wB,OAAO,sBAGrB4wB,EAAe,EAAKA,aAS1B,MAAMC,EACL,cACC,IAAIld,EAAOsW,UAAU3mB,OAAS,QAAsBqI,IAAjBse,UAAU,GAAmBA,UAAU,GAAK,KAC3E6G,EAAO7G,UAAU3mB,OAAS,QAAsBqI,IAAjBse,UAAU,GAAmBA,UAAU,GAAK,GAE/E4B,EAAKzsB,KAAKqF,KAAMkP,EAAMmd,GAEtB,MAAM1J,EAAS0J,EAAK1J,QAAU,IACxB8G,EAAU,IAAIiB,EAAQ2B,EAAK5C,SAEjC,GAAY,MAARva,IAAiBua,EAAQ9hB,IAAI,gBAAiB,CACjD,MAAM2kB,EAAcnD,EAAmBja,GACnCod,GACH7C,EAAQf,OAAO,eAAgB4D,GAIjCtsB,KAAKksB,GAAe,CACnBvK,IAAK0K,EAAK1K,IACVgB,SACAC,WAAYyJ,EAAKzJ,YAAcuJ,EAAaxJ,GAC5C8G,UACA8C,QAASF,EAAKE,SAIhB,UACC,OAAOvsB,KAAKksB,GAAavK,KAAO,GAGjC,aACC,OAAO3hB,KAAKksB,GAAavJ,OAM1B,SACC,OAAO3iB,KAAKksB,GAAavJ,QAAU,KAAO3iB,KAAKksB,GAAavJ,OAAS,IAGtE,iBACC,OAAO3iB,KAAKksB,GAAaK,QAAU,EAGpC,iBACC,OAAOvsB,KAAKksB,GAAatJ,WAG1B,cACC,OAAO5iB,KAAKksB,GAAazC,QAQ1B,QACC,OAAO,IAAI2C,EAASxD,EAAM5oB,MAAO,CAChC2hB,IAAK3hB,KAAK2hB,IACVgB,OAAQ3iB,KAAK2iB,OACbC,WAAY5iB,KAAK4iB,WACjB6G,QAASzpB,KAAKypB,QACd/G,GAAI1iB,KAAK0iB,GACT8J,WAAYxsB,KAAKwsB,cAKpBpF,EAAK4C,MAAMoC,EAAShwB,WAEpBlB,OAAO8rB,iBAAiBoF,EAAShwB,UAAW,CAC3CulB,IAAK,CAAEvmB,YAAY,GACnBunB,OAAQ,CAAEvnB,YAAY,GACtBsnB,GAAI,CAAEtnB,YAAY,GAClBoxB,WAAY,CAAEpxB,YAAY,GAC1BwnB,WAAY,CAAExnB,YAAY,GAC1BquB,QAAS,CAAEruB,YAAY,GACvBwtB,MAAO,CAAExtB,YAAY,KAGtBF,OAAOC,eAAeixB,EAAShwB,UAAWb,OAAOC,YAAa,CAC7DC,MAAO,WACPsG,UAAU,EACV3G,YAAY,EACZ+J,cAAc,IAGf,MAAMsnB,EAAclxB,OAAO,qBAGrBmxB,EAAY,EAAI/C,MAChBgD,EAAa,EAAInf,OAEjBof,EAA6B,YAAa,EAAOzH,SAAS/oB,UAQhE,SAASywB,EAAU5H,GAClB,MAAwB,iBAAVA,GAAoD,iBAAvBA,EAAMwH,GAelD,MAAMK,EACL,YAAY7H,GACX,IAEI8H,EAFApC,EAAOnF,UAAU3mB,OAAS,QAAsBqI,IAAjBse,UAAU,GAAmBA,UAAU,GAAK,GAK1EqH,EAAU5H,GAYd8H,EAAYL,EAAUzH,EAAMtD,MAP3BoL,EAJG9H,GAASA,EAAM+H,KAINN,EAAUzH,EAAM+H,MAGhBN,EAAU,GAAGzH,GAE1BA,EAAQ,IAKT,IAAI+F,EAASL,EAAKK,QAAU/F,EAAM+F,QAAU,MAG5C,GAFAA,EAASA,EAAO1L,eAEE,MAAbqL,EAAKzb,MAAgB2d,EAAU5H,IAAyB,OAAfA,EAAM/V,QAA8B,QAAX8b,GAA+B,SAAXA,GAC1F,MAAM,IAAIjO,UAAU,iDAGrB,IAAIkQ,EAAyB,MAAbtC,EAAKzb,KAAeyb,EAAKzb,KAAO2d,EAAU5H,IAAyB,OAAfA,EAAM/V,KAAgB0Z,EAAM3D,GAAS,KAEzGmC,EAAKzsB,KAAKqF,KAAMitB,EAAW,CAC1BxF,QAASkD,EAAKlD,SAAWxC,EAAMwC,SAAW,EAC1C/B,KAAMiF,EAAKjF,MAAQT,EAAMS,MAAQ,IAGlC,MAAM+D,EAAU,IAAIiB,EAAQC,EAAKlB,SAAWxE,EAAMwE,SAAW,IAE7D,GAAiB,MAAbwD,IAAsBxD,EAAQ9hB,IAAI,gBAAiB,CACtD,MAAM2kB,EAAcnD,EAAmB8D,GACnCX,GACH7C,EAAQf,OAAO,eAAgB4D,GAIjC,IAAIY,EAASL,EAAU5H,GAASA,EAAMiI,OAAS,KAG/C,GAFI,WAAYvC,IAAMuC,EAASvC,EAAKuC,QAEtB,MAAVA,IA5DN,SAAuBA,GACtB,MAAMjD,EAAQiD,GAA4B,iBAAXA,GAAuBhyB,OAAO2wB,eAAeqB,GAC5E,SAAUjD,GAAoC,gBAA3BA,EAAMnD,YAAY/rB,MA0DboyB,CAAcD,GACpC,MAAM,IAAInQ,UAAU,mDAGrB/c,KAAKysB,GAAe,CACnBzB,SACAoC,SAAUzC,EAAKyC,UAAYnI,EAAMmI,UAAY,SAC7C3D,UACAsD,YACAG,UAIDltB,KAAKqtB,YAAyBnmB,IAAhByjB,EAAK0C,OAAuB1C,EAAK0C,YAA0BnmB,IAAjB+d,EAAMoI,OAAuBpI,EAAMoI,OAAS,GACpGrtB,KAAKstB,cAA6BpmB,IAAlByjB,EAAK2C,SAAyB3C,EAAK2C,cAA8BpmB,IAAnB+d,EAAMqI,UAAyBrI,EAAMqI,SACnGttB,KAAKusB,QAAU5B,EAAK4B,SAAWtH,EAAMsH,SAAW,EAChDvsB,KAAKutB,MAAQ5C,EAAK4C,OAAStI,EAAMsI,MAGlC,aACC,OAAOvtB,KAAKysB,GAAazB,OAG1B,UACC,OAAO2B,EAAW3sB,KAAKysB,GAAaM,WAGrC,cACC,OAAO/sB,KAAKysB,GAAahD,QAG1B,eACC,OAAOzpB,KAAKysB,GAAaW,SAG1B,aACC,OAAOptB,KAAKysB,GAAaS,OAQ1B,QACC,OAAO,IAAIJ,EAAQ9sB,OA0GrB,SAASwtB,EAAW7pB,GAClBF,MAAM9I,KAAKqF,KAAM2D,GAEjB3D,KAAK6B,KAAO,UACZ7B,KAAK2D,QAAUA,EAGfF,MAAMojB,kBAAkB7mB,KAAMA,KAAK8mB,aA7GrCM,EAAK4C,MAAM8C,EAAQ1wB,WAEnBlB,OAAOC,eAAe2xB,EAAQ1wB,UAAWb,OAAOC,YAAa,CAC5DC,MAAO,UACPsG,UAAU,EACV3G,YAAY,EACZ+J,cAAc,IAGfjK,OAAO8rB,iBAAiB8F,EAAQ1wB,UAAW,CAC1C4uB,OAAQ,CAAE5vB,YAAY,GACtBumB,IAAK,CAAEvmB,YAAY,GACnBquB,QAAS,CAAEruB,YAAY,GACvBgyB,SAAU,CAAEhyB,YAAY,GACxBwtB,MAAO,CAAExtB,YAAY,GACrB8xB,OAAQ,CAAE9xB,YAAY,KAiGvBoyB,EAAWpxB,UAAYlB,OAAOY,OAAO2H,MAAMrH,WAC3CoxB,EAAWpxB,UAAU0qB,YAAc0G,EACnCA,EAAWpxB,UAAUrB,KAAO,aAG5B,MAAM0yB,EAAgB,EAAOtG,YACvBuG,EAAc,EAAIhgB,QASxB,SAASigB,EAAMhM,EAAK0K,GAGnB,IAAKsB,EAAMlY,QACV,MAAM,IAAIhS,MAAM,0EAMjB,OAHA2jB,EAAK3R,QAAUkY,EAAMlY,QAGd,IAAIkY,EAAMlY,SAAQ,SAAU/H,EAASgI,GAE3C,MAAMkY,EAAU,IAAId,EAAQnL,EAAK0K,GAC3B1hB,EApHR,SAA+BijB,GAC9B,MAAMb,EAAYa,EAAQnB,GAAaM,UACjCtD,EAAU,IAAIiB,EAAQkD,EAAQnB,GAAahD,SAQjD,GALKA,EAAQ9hB,IAAI,WAChB8hB,EAAQtiB,IAAI,SAAU,QAIlB4lB,EAAUc,WAAad,EAAUe,SACrC,MAAM,IAAI/Q,UAAU,oCAGrB,IAAK,YAAYtP,KAAKsf,EAAUc,UAC/B,MAAM,IAAI9Q,UAAU,wCAGrB,GAAI6Q,EAAQV,QAAUU,EAAQ1e,gBAAgB,EAAOiW,WAAayH,EACjE,MAAM,IAAInpB,MAAM,mFAIjB,IAAIsqB,EAAqB,KAIzB,GAHoB,MAAhBH,EAAQ1e,MAAgB,gBAAgBzB,KAAKmgB,EAAQ5C,UACxD+C,EAAqB,KAEF,MAAhBH,EAAQ1e,KAAc,CACzB,MAAM8e,EAAa5E,EAAcwE,GACP,iBAAfI,IACVD,EAAqBloB,OAAOmoB,IAG1BD,GACHtE,EAAQtiB,IAAI,iBAAkB4mB,GAI1BtE,EAAQ9hB,IAAI,eAChB8hB,EAAQtiB,IAAI,aAAc,0DAIvBymB,EAAQN,WAAa7D,EAAQ9hB,IAAI,oBACpC8hB,EAAQtiB,IAAI,kBAAmB,gBAGhC,IAAIomB,EAAQK,EAAQL,MAYpB,MAXqB,mBAAVA,IACVA,EAAQA,EAAMR,IAGVtD,EAAQ9hB,IAAI,eAAkB4lB,GAClC9D,EAAQtiB,IAAI,aAAc,SAMpBjM,OAAOsN,OAAO,GAAIukB,EAAW,CACnC/B,OAAQ4C,EAAQ5C,OAChBvB,QAASsC,EAA4BtC,GACrC8D,UAsDgBU,CAAsBL,GAEhCM,GAA6B,WAArBvjB,EAAQkjB,SAAwB,EAAQ,GAAMD,QACtDV,EAASU,EAAQV,OAEvB,IAAIzK,EAAW,KAEf,MAAM4F,EAAQ,WACb,IAAI1mB,EAAQ,IAAI6rB,EAAW,+BAC3B9X,EAAO/T,GACHisB,EAAQ1e,MAAQ0e,EAAQ1e,gBAAgB,EAAOiW,UAClDyI,EAAQ1e,KAAKif,QAAQxsB,GAEjB8gB,GAAaA,EAASvT,MAC3BuT,EAASvT,KAAK0P,KAAK,QAASjd,IAG7B,GAAIurB,GAAUA,EAAOkB,QAEpB,YADA/F,IAID,MAAMgG,EAAmB,WACxBhG,IACAiG,KAIKC,EAAML,EAAKvjB,GACjB,IAAI6jB,EAMJ,SAASF,IACRC,EAAIlG,QACA6E,GAAQA,EAAOuB,oBAAoB,QAASJ,GAChD5F,aAAa+F,GAPVtB,GACHA,EAAOwB,iBAAiB,QAASL,GAS9BT,EAAQnG,SACX8G,EAAII,KAAK,UAAU,SAAUC,GAC5BJ,EAAajG,YAAW,WACvB7S,EAAO,IAAIgR,EAAW,uBAAuBkH,EAAQjM,IAAO,oBAC5D2M,MACEV,EAAQnG,YAIb8G,EAAIzG,GAAG,SAAS,SAAUxY,GACzBoG,EAAO,IAAIgR,EAAW,cAAckH,EAAQjM,uBAAuBrS,EAAI3L,UAAW,SAAU2L,IAC5Fgf,OAGDC,EAAIzG,GAAG,YAAY,SAAU9hB,GAC5ByiB,aAAa+F,GAEb,MAAM/E,EAlcT,SAA8BvkB,GAC7B,MAAMukB,EAAU,IAAIiB,EACpB,IAAK,MAAM3vB,KAAQG,OAAO2Q,KAAK3G,GAC9B,IAAIolB,EAAkB7c,KAAK1S,GAG3B,GAAI0D,MAAMC,QAAQwG,EAAInK,IACrB,IAAK,MAAM8zB,KAAO3pB,EAAInK,GACjBwvB,EAAuB9c,KAAKohB,UAGL3nB,IAAvBuiB,EAAQjsB,GAAKzC,GAChB0uB,EAAQjsB,GAAKzC,GAAQ,CAAC8zB,GAEtBpF,EAAQjsB,GAAKzC,GAAMsD,KAAKwwB,SAGftE,EAAuB9c,KAAKvI,EAAInK,MAC3C0uB,EAAQjsB,GAAKzC,GAAQ,CAACmK,EAAInK,KAG5B,OAAO0uB,EA6aWqF,CAAqB9oB,EAAIyjB,SAGzC,GAAIkE,EAAMoB,WAAW/oB,EAAIgpB,YAAa,CAErC,MAAMC,EAAWxF,EAAQpuB,IAAI,YAGvB6zB,EAA2B,OAAbD,EAAoB,KAAOvB,EAAYE,EAAQjM,IAAKsN,GAGxE,OAAQrB,EAAQR,UACf,IAAK,QAGJ,OAFA1X,EAAO,IAAIgR,EAAW,0EAA0EkH,EAAQjM,IAAO,qBAC/G2M,IAED,IAAK,SAEJ,GAAoB,OAAhBY,EAEH,IACCzF,EAAQtiB,IAAI,WAAY+nB,GACvB,MAAO5f,GAERoG,EAAOpG,GAGT,MACD,IAAK,SAEJ,GAAoB,OAAhB4f,EACH,MAID,GAAItB,EAAQrB,SAAWqB,EAAQP,OAG9B,OAFA3X,EAAO,IAAIgR,EAAW,gCAAgCkH,EAAQjM,IAAO,sBACrE2M,IAMD,MAAMa,EAAc,CACnB1F,QAAS,IAAIiB,EAAQkD,EAAQnE,SAC7B4D,OAAQO,EAAQP,OAChBd,QAASqB,EAAQrB,QAAU,EAC3BgB,MAAOK,EAAQL,MACfD,SAAUM,EAAQN,SAClBtC,OAAQ4C,EAAQ5C,OAChB9b,KAAM0e,EAAQ1e,KACdge,OAAQU,EAAQV,OAChBzF,QAASmG,EAAQnG,QACjB/B,KAAMkI,EAAQlI,MAIf,OAAuB,MAAnB1f,EAAIgpB,YAAsBpB,EAAQ1e,MAAmC,OAA3Bka,EAAcwE,IAC3DlY,EAAO,IAAIgR,EAAW,2DAA4D,8BAClF4H,MAKsB,MAAnBtoB,EAAIgpB,aAA0C,MAAnBhpB,EAAIgpB,YAAyC,MAAnBhpB,EAAIgpB,YAA0C,SAAnBpB,EAAQ5C,UAC3FmE,EAAYnE,OAAS,MACrBmE,EAAYjgB,UAAOhI,EACnBioB,EAAY1F,QAAQriB,OAAO,mBAI5BsG,EAAQigB,EAAM,IAAIb,EAAQoC,EAAaC,UACvCb,MAMHtoB,EAAI2oB,KAAK,OAAO,WACXzB,GAAQA,EAAOuB,oBAAoB,QAASJ,MAEjD,IAAInf,EAAOlJ,EAAIkjB,KAAK,IAAIuE,GAExB,MAAM2B,EAAmB,CACxBzN,IAAKiM,EAAQjM,IACbgB,OAAQ3c,EAAIgpB,WACZpM,WAAY5c,EAAIqpB,cAChB5F,QAASA,EACT/D,KAAMkI,EAAQlI,KACd+B,QAASmG,EAAQnG,QACjB8E,QAASqB,EAAQrB,SAIZ+C,EAAU7F,EAAQpuB,IAAI,oBAU5B,IAAKuyB,EAAQN,UAA+B,SAAnBM,EAAQ5C,QAAiC,OAAZsE,GAAuC,MAAnBtpB,EAAIgpB,YAAyC,MAAnBhpB,EAAIgpB,WAGvG,OAFAvM,EAAW,IAAI2J,EAASld,EAAMkgB,QAC9B1hB,EAAQ+U,GAST,MAAM8M,EAAc,CACnBC,MAAO,EAAKC,aACZC,YAAa,EAAKD,cAInB,GAAe,QAAXH,GAAgC,UAAXA,EAIxB,OAHApgB,EAAOA,EAAKga,KAAK,EAAKyG,aAAaJ,IACnC9M,EAAW,IAAI2J,EAASld,EAAMkgB,QAC9B1hB,EAAQ+U,GAKT,GAAe,WAAX6M,GAAmC,aAAXA,EAA5B,CAkBA,GAAe,MAAXA,GAA0D,mBAAhC,EAAKM,uBAIlC,OAHA1gB,EAAOA,EAAKga,KAAK,EAAK0G,0BACtBnN,EAAW,IAAI2J,EAASld,EAAMkgB,QAC9B1hB,EAAQ+U,GAKTA,EAAW,IAAI2J,EAASld,EAAMkgB,GAC9B1hB,EAAQ+U,OA3BR,CAGazc,EAAIkjB,KAAK,IAAIuE,GACrBkB,KAAK,QAAQ,SAAUnG,GAGzBtZ,EADyB,IAAV,GAAXsZ,EAAM,IACHtZ,EAAKga,KAAK,EAAK2G,iBAEf3gB,EAAKga,KAAK,EAAK4G,oBAEvBrN,EAAW,IAAI2J,EAASld,EAAMkgB,GAC9B1hB,EAAQ+U,UAv8Bb,SAAuBsN,EAAMlH,GAC5B,MAAM3Z,EAAO2Z,EAAS3Z,KAGT,OAATA,EAEH6gB,EAAK7wB,MACKyoB,EAAOzY,GACjBA,EAAKgZ,SAASgB,KAAK6G,GACT5T,OAAOyL,SAAS1Y,IAE1B6gB,EAAKC,MAAM9gB,GACX6gB,EAAK7wB,OAGLgQ,EAAKga,KAAK6G,GA08BVE,CAAc1B,EAAKX,MASrBD,EAAMoB,WAAa,SAAUrgB,GAC5B,OAAgB,MAATA,GAAyB,MAATA,GAAyB,MAATA,GAAyB,MAATA,GAAyB,MAATA,GAIxEif,EAAMlY,QAAU4U,OAAO5U,QAER,a,8ECpmDf,UAAe,CACXya,iBACA9wB,MAWJ,SAAegjB,GACX,MAAMI,EAAiB,GACjBQ,EAAiC,GACjCjM,EAAUmZ,EAAe9N,GAC/B,IAAI+N,EAAS,EAEb,OAAa,CACT,MAAMC,EAAYrZ,EAAQ3Y,QAAQ,OAAQ+xB,GAC1C,IAhBU,IAgBNC,EAAyB,CACzBpN,EAAO3kB,KAAK0Y,EAAQzX,OAAO6wB,IAC3B,MAEJnN,EAAO3kB,KAAK0Y,EAAQV,UAAU8Z,EAAQC,EAAY,OAAOvxB,SACzD,MAAMwxB,EAAatZ,EAAQ3Y,QAAQ,IAAKgyB,EAAY,OAAOvxB,QAC3D,IAtBU,IAsBNwxB,EAA0B,MAE9BrN,EAAO3kB,KAAKmkB,EAAK3jB,QACjB,MAAM8iB,EAAM5K,EAAQV,UAAU+Z,EAAY,OAAOvxB,OAAQwxB,GACzD7N,EAAKnkB,KAAKsjB,GACVwO,EAASE,EAGb,MAAO,CAAE7N,OAAMQ,SAAQF,KAAM,MAGjC,SAASoN,EAAenZ,GACpB,MAAMiM,EAAmB,GACzB,IAAImN,EAAS,EAEb,OAAa,CACT,MAAMC,EAAYrZ,EAAQ3Y,QAAQ,KAAM+xB,GACxC,IAvCU,IAuCNC,EAAyB,CACzBpN,EAAO3kB,KAAK0Y,EAAQzX,OAAO6wB,IAC3B,MAEJnN,EAAO3kB,KAAK0Y,EAAQV,UAAU8Z,EAAQC,IACtC,MAAMC,EAAatZ,EAAQ3Y,QAAQ,KAAM+xB,EAAS,KAAKtxB,QACvD,IA7CU,IA6CNwxB,EAA0B,MAC9BF,EAASE,EAAa,KAAKxxB,OAG/B,OAAOmkB,EAAOvgB,KAAK,M,8YCrDvB,aACA,QACA,QACA,OAEA,UAAe,CAAEmd,YAmBjB,W,+CACI,MAAMa,EAAe9K,EAAIgB,OAAO+J,iBAChC,IAAKD,EAED,YADA9K,EAAIgB,OAAOgK,iBAAiB,0BAGhC,MAAMnL,EAAWiL,EAAaM,SAASC,SACvC,IAAKxL,EAAS8a,SAAS,WAAa9a,EAAS8a,SAAS,QAElD,YADA3a,EAAIgB,OAAOgK,iBAAiB,4BAIhC,MAAM5J,EAAU0J,EAAaM,SAASwP,UAAU/qB,QAAQ,KAAM,QAC9D,IAAI/J,EAAa,KACjB,IACIA,EAAQ+0B,EAAK7G,MACT5S,EAAS,CACT7V,OAAQ,EACRuvB,cAAc,IAItB,MAAO1O,GACHjD,QAAQnd,MAAM,oFACdmd,QAAQnd,MAAMogB,GACd,IAAI2O,EAAe,uBAAuB3O,EAiB1C,OAhBIA,aAAc,EAAA9d,kBACdysB,EAAe,+BAAyC,QAAV,EAAA3O,EAAGje,eAAO,eAAEhF,MAAMC,UACtDgjB,EAAGpe,YAGRoe,aAAc,EAAAve,YACnBktB,EAAe,gBAAgB3O,EAAGpe,cAhD5B,IAkDN+sB,EAAatyB,QAAQ,uCACrBsyB,GAAgB,6DAChBA,GAAgB,wCAEpB/a,EAAIgB,OAAOgK,iBACP+P,EACA,CAAEnM,OAAO,IAIjB,MAAMoM,EAAc,UAAK1a,gBAAgBT,EAAU,QACnD,UAAKsB,cACD6Z,EACAjnB,KAAKrB,UAAU5M,EAAO,KAhEF,eAkElB,UAAK8a,iBAAiBoa,S,gBC1EhCp2B,EAAOD,QAAU,EAAQ,IAAUk2B,M,6BCEnC,IAAItsB,EAAa,EAAQ,GACrB0sB,EAAW,EAAQ,IACvB,EAAQ,GACR,IAAIC,EAAa,EAAQ,IACrBnV,EAAS,EAAQ,GACjBnL,EAAW,EAAQ,IAavB,MAAMugB,UAAiBD,EAAWC,SAChC,YAAYnmB,GACV/G,MAAM1I,OAAOsN,OAAO,GAAIqoB,EAAWE,eAAgBpmB,KAmBvD,SAASqmB,EAAc/yB,EAAK0M,GAC1B,MAAMpM,EAAMqyB,EAASjH,MAAM1rB,GACrBiM,EAAM,IAAI4mB,EAASnmB,GAASgf,MAAMprB,EAAI,IAE5C,GAAIA,EAAIM,OAAS,EAAG,CAClB,MAAMoyB,EAAS,0EACf/mB,EAAI5F,OAAOiZ,QAAQ,IAAIrZ,EAAWD,kBAAkB1F,EAAI,GAAI0yB,IAG9D,OAAO/mB,EAgBT,MAAMsmB,EAAO,CACX/pB,WA1DF,SAAoBhL,EAAO4b,GAAc,EAAMxU,QACjCqE,IAARrE,GAA4C,iBAAhBwU,IAC9BxU,EAAMwU,EACNA,GAAc,GAGhB,MAAM1M,EAAUzP,OAAOsN,OAAO,GAAIqoB,EAAWC,SAASI,SAASL,EAAWE,eAAezgB,SAAUugB,EAAWE,gBAE9G,OADe,IAAIrV,EAAOA,OAAO/Q,GACnBlE,WAAWhL,EAAO4b,EAAaxU,IAmD7CkuB,eAAgBF,EAAWE,eAC3BD,WACAnH,MAjBF,SAAe1rB,EAAK0M,GAClB,MAAMT,EAAM8mB,EAAc/yB,EAAK0M,GAE/B,GADAT,EAAIqG,SAASjN,QAAQqb,GAAWpO,EAAS0D,KAAK0K,IAC1CzU,EAAI5F,OAAOzF,OAAS,EAAG,MAAMqL,EAAI5F,OAAO,GAC5C,OAAO4F,EAAIzE,UAcX0rB,kBA5CF,SAA2BlzB,EAAK0M,GAC9B,MAAMud,EAAS,GACf,IAAIvnB,EAEJ,IAAK,MAAMywB,KAAUR,EAASjH,MAAM1rB,GAAM,CACxC,MAAMiM,EAAM,IAAI4mB,EAASnmB,GACzBT,EAAIyf,MAAMyH,EAAQzwB,GAClBunB,EAAO7pB,KAAK6L,GACZvJ,EAAOuJ,EAGT,OAAOge,GAkCPmJ,SAAUT,EAASjH,MACnBqH,gBACAM,cAAeT,EAAWS,cAC1BjpB,UAfF,SAAmB5M,EAAOkP,GACxB,MAAMT,EAAM,IAAI4mB,EAASnmB,GAEzB,OADAT,EAAIqnB,SAAW91B,EACRoK,OAAOqE,KAehB5P,EAAQk2B,KAAOA,G,6BC5Ef,IAAItsB,EAAa,EAAQ,GAEzB,MAAMstB,UAAkBttB,EAAW7D,KACjC,cACEuD,MAAMM,EAAWnH,KAAKE,YAKxB,4BAGE,OAAO,EAWT,MAAM0B,EAASG,GAGb,OAFAkB,KAAKrB,QAAUA,EACfqB,KAAKgC,MAAQ,IAAIkC,EAAWpE,MAAMhB,EAAOA,EAAQ,GAC1CA,EAAQ,GAKnB,MAAM2yB,UAAuBvtB,EAAW7D,KACtC,YAAYwB,EAAMC,GAChB8B,MAAM/B,EAAMC,GACZ9B,KAAKgH,KAAO,KAGd,4BACE,QAAShH,KAAKgH,MAAQhH,KAAKgH,KAAK0qB,sBASlC,MAAM/yB,EAASG,GACbkB,KAAKrB,QAAUA,EACf,MAAM,UACJgzB,EAAS,IACT1zB,GACEU,EACJ,IAAI,YACFwU,EAAW,UACXhS,GACExC,EACCwU,GAAenT,KAAK6B,OAASqC,EAAWnH,KAAKgB,WAAUiC,KAAK2B,MAAQ,IAAIuC,EAAWD,kBAAkBjE,KAAM,oEAChH,MAAMkB,EAASiS,EAAcrU,EAAQqC,EAAYxC,EAAQuC,OACzD,IAAI/C,EAAS+F,EAAW7D,KAAKG,gBAAgBvC,EAAKa,EAAQ,GACtDiC,EAAK9C,EAAIE,GACb,MAAMyzB,EAAuB,MAAP7wB,EAChBwB,EAAW,GACjB,IAAIsvB,EAAY,KAEhB,KAAc,OAAP9wB,GAAsB,MAAPA,GAAY,CAChC,GAAW,MAAPA,EAAY,CACd,MAAM7B,EAAMgF,EAAW7D,KAAK8C,UAAUlF,EAAKE,EAAS,GACpDoE,EAASlE,KAAK,IAAI6F,EAAWpE,MAAM3B,EAAQe,IAC3Cf,EAASe,MACJ,CACLiU,GAAc,EACdhS,EAAYhD,EAAS,EAGF,OAAfF,EAFUiG,EAAW7D,KAAKG,gBAAgBvC,EAAKkD,KAEJ,IAApBoB,EAAS1D,SAClCgzB,EAAY,IAAIL,EAChBrwB,EAAY0wB,EAAUlI,MAAM,CAC1B1rB,OACCkD,IAGLhD,EAAS+F,EAAW7D,KAAKgB,YAAYpD,EAAKkD,GAG5CJ,EAAK9C,EAAIE,GAeX,GAZI+F,EAAW7D,KAAKyxB,mBAAmB/wB,EAAI5C,GAAUgD,EAAYD,GAASlB,KAAK6B,OAASqC,EAAWnH,KAAKgB,UACtGiC,KAAKgH,KAAO2qB,EAAU,CACpBxe,cACA4e,cAAc,EACd7wB,SACAC,YACAqQ,OAAQxR,MACP7B,GACM4C,GAAMI,EAAYrC,EAAQ,IACnCX,EAASgD,EAAY,GAGnBnB,KAAKgH,KAAM,CACb,GAAI6qB,EAAW,CAIb,MAAMrqB,EAAQ7I,EAAQ6S,OAAOhK,OAAS7I,EAAQ6S,OAAO+f,SACjD/pB,GAAOA,EAAMnJ,KAAKwzB,GAGpBtvB,EAAS1D,QAAQJ,MAAMrC,UAAUiC,KAAKsP,MAAM3N,KAAK8B,MAAOS,GAC5DpE,EAAS6B,KAAKgH,KAAKhF,MAAM9C,SAEzB,GAAI0yB,EAAe,CACjB,MAAM/2B,EAAI0H,EAAS,GACnBvC,KAAK8B,MAAMzD,KAAKxD,GAChBsD,EAAStD,EAAEqE,SAEXf,EAAS+F,EAAW7D,KAAK8C,UAAUlF,EAAKa,EAAQ,GAIpD,MAAMI,EAAMc,KAAKgH,KAAOhH,KAAKgH,KAAK/E,WAAW/C,IAAMf,EAEnD,OADA6B,KAAKiC,WAAa,IAAIiC,EAAWpE,MAAMhB,EAAOI,GACvCf,EAGT,cAAc8B,EAAI9B,GAEhB,OADAA,EAASyF,MAAMouB,cAAc/xB,EAAI9B,GAC1B6B,KAAKgH,KAAOhH,KAAKgH,KAAKgrB,cAAc/xB,EAAI9B,GAAUA,EAG3D,WACE,MACEQ,SAAS,IACPV,GACD,KACD+I,EAAI,MACJhF,EAAK,MACLvG,GACEuE,KACJ,GAAa,MAATvE,EAAe,OAAOA,EAC1B,MAAM6E,EAAM0G,EAAO/I,EAAImB,MAAM4C,EAAMlD,MAAOkI,EAAKhF,MAAMlD,OAAS+G,OAAOmB,GAAQ/I,EAAImB,MAAM4C,EAAMlD,MAAOkD,EAAM9C,KAC1G,OAAOgF,EAAW7D,KAAKkD,oBAAoBtF,EAAK+D,EAAM9C,IAAKoB,IAK/D,MAAM2xB,UAAgB/tB,EAAW7D,KAC/B,cACEuD,MAAMM,EAAWnH,KAAKJ,SAWxB,MAAMgC,EAASG,GACbkB,KAAKrB,QAAUA,EACf,MAAMR,EAAS6B,KAAK2E,aAAa7F,GAEjC,OADAkB,KAAKgC,MAAQ,IAAIkC,EAAWpE,MAAMhB,EAAOX,GAClCA,GAKX,SAAS+zB,EAA0BlrB,GACjC,IAAImrB,EAAQnrB,EAEZ,KAAOmrB,aAAiBV,GAAgBU,EAAQA,EAAMnrB,KAEtD,KAAMmrB,aAAiBtrB,GAAa,OAAO,KAC3C,MAAMurB,EAAMD,EAAM3qB,MAAM3I,OACxB,IAAIwzB,GAAM,EAEV,IAAK,IAAI73B,EAAI43B,EAAM,EAAG53B,GAAK,IAAKA,EAAG,CACjC,MAAMyB,EAAIk2B,EAAM3qB,MAAMhN,GAEtB,GAAIyB,EAAE4F,OAASqC,EAAWnH,KAAKJ,QAAS,CAEtC,MAAM,OACJuE,EAAM,UACNC,GACElF,EAAE0C,QACN,GAAIuC,EAAS,GAAKjF,EAAE+F,MAAMlD,OAASqC,EAAYD,EAAQ,MACvDmxB,EAAK73B,MACA,IAAIyB,EAAE4F,OAASqC,EAAWnH,KAAKE,WAAwB,MAAZo1B,EAAK73B,GAGzD,IAAY,IAAR63B,EAAW,OAAO,KACtB,MAAMngB,EAAKigB,EAAM3qB,MAAM8B,OAAO+oB,EAAID,EAAMC,GAClCC,EAAUpgB,EAAG,GAAGlQ,MAAMlD,MAE5B,KACEqzB,EAAMnwB,MAAM9C,IAAMozB,EACdH,EAAMlwB,YAAckwB,EAAMlwB,WAAW/C,IAAMozB,IAASH,EAAMlwB,WAAW/C,IAAMozB,GAC3EH,IAAUnrB,GACdmrB,EAAQA,EAAMxzB,QAAQ6S,OAGxB,OAAOU,EAET,MAAMrL,UAAmB3C,EAAW7D,KAClC,4BAA4BpC,EAAKE,EAAQ+C,GACvC,MAAMC,EAAY+C,EAAW7D,KAAK8C,UAAUlF,EAAKE,GAAU,EAErD4C,EAAK9C,EADXE,EAAS+F,EAAW7D,KAAKG,gBAAgBvC,EAAKkD,IAE9C,QAAKJ,IACD5C,GAAUgD,EAAYD,IACf,MAAPH,GAAqB,OAAPA,IACX8F,EAAW0rB,qBAAqBt0B,EAAKE,EAAQ+C,IAGtD,YAAYsxB,GACV5uB,MAAM4uB,EAAU3wB,OAASqC,EAAWnH,KAAKgB,SAAWmG,EAAWnH,KAAKe,IAAMoG,EAAWnH,KAAKS,KAE1F,IAAK,IAAIhD,EAAIg4B,EAAU1wB,MAAMjD,OAAS,EAAGrE,GAAK,IAAKA,EACjD,GAAIg4B,EAAU1wB,MAAMtH,GAAGsE,MAAQ0zB,EAAU7zB,QAAQwC,UAAW,CAE1DnB,KAAK8B,MAAQ0wB,EAAU1wB,MAAM1C,MAAM,EAAG5E,EAAI,GAC1Cg4B,EAAU1wB,MAAQ0wB,EAAU1wB,MAAM1C,MAAM5E,EAAI,GAC5C,MAAMi4B,EAAYD,EAAU1wB,MAAM,IAAM0wB,EAAUvwB,WAClDuwB,EAAUxwB,MAAMlD,MAAQ2zB,EAAU3zB,MAClC,MAIJkB,KAAKwH,MAAQ,CAACgrB,GACd,MAAME,EAAKR,EAA0BM,GACjCE,GAAIj0B,MAAMrC,UAAUiC,KAAKsP,MAAM3N,KAAKwH,MAAOkrB,GAGjD,4BACE,OAAO1yB,KAAKwH,MAAM3I,OAAS,EAS7B,MAAMF,EAASG,GACbkB,KAAKrB,QAAUA,EACf,MAAM,UACJgzB,EAAS,IACT1zB,GACEU,EAGJ,IAAIwC,EAAY+C,EAAW7D,KAAKsyB,YAAY10B,EAAKa,GACjD,MAAM0zB,EAAYxyB,KAAKwH,MAAM,GAG7BgrB,EAAU7zB,QAAQ6S,OAASxR,KAC3BA,KAAKiC,WAAaiC,EAAWpE,MAAM8yB,KAAKJ,EAAUvwB,YAClD,MAAMf,EAASsxB,EAAUxwB,MAAMlD,MAAQ0zB,EAAU7zB,QAAQwC,UACzD,IAAIhD,EAASW,EACbX,EAAS+F,EAAW7D,KAAKwyB,gBAAgB50B,EAAKE,GAC9C,IAAI4C,EAAK9C,EAAIE,GACTgV,EAAcjP,EAAW7D,KAAKG,gBAAgBvC,EAAKkD,KAAehD,EAClE20B,GAA4B,EAEhC,KAAO/xB,GAAI,CACT,KAAc,OAAPA,GAAsB,MAAPA,GAAY,CAChC,GAAIoS,GAAsB,OAAPpS,IAAgB+xB,EAA2B,CAC5D,MAAMjB,EAAY,IAAIL,EAMtB,GALArzB,EAAS0zB,EAAUlI,MAAM,CACvB1rB,OACCE,GACH6B,KAAKiC,WAAW/C,IAAMf,EAElBA,GAAUF,EAAIY,OAAQ,CACxBkC,EAAK,KACL,MAGFf,KAAKwH,MAAMnJ,KAAKwzB,GAChB1zB,GAAU,OACL,GAAW,MAAP4C,EAAY,CACrB,GAAI5C,EAASgD,EAAYD,IAAW2F,EAAW0rB,qBAAqBt0B,EAAKE,EAAQ+C,GAC/E,OAAO/C,EAGT,MAAMqE,EAAU,IAAIyvB,EASpB,GARA9zB,EAASqE,EAAQmnB,MAAM,CACrBzoB,SACAC,YACAlD,OACCE,GACH6B,KAAKwH,MAAMnJ,KAAKmE,GAChBxC,KAAKiC,WAAW/C,IAAMf,EAElBA,GAAUF,EAAIY,OAAQ,CACxBkC,EAAK,KACL,OAOJ,GAHAI,EAAYhD,EAAS,EACrBA,EAAS+F,EAAW7D,KAAKgB,YAAYpD,EAAKkD,GAEtC+C,EAAW7D,KAAKsC,QAAQ1E,EAAKE,GAAS,CACxC,MAAMmD,EAAQ4C,EAAW7D,KAAKG,gBAAgBvC,EAAKE,GAC7CoC,EAAOtC,EAAIqD,GAEZf,GAAiB,OAATA,GAA0B,MAATA,IAC5BpC,EAASmD,GAIbP,EAAK9C,EAAIE,GACTgV,GAAc,EAGhB,IAAKpS,EACH,MAGF,GAAI5C,IAAWgD,EAAYD,IAAWiS,GAAsB,MAAPpS,GAAa,CAChE,GAAI5C,EAASgD,EAAYD,EAAQ,CAC3BC,EAAYrC,IAAOX,EAASgD,GAChC,MACK,IAAKnB,KAAK2B,MAAO,CACtB,MAAMsK,EAAM,qDACZjM,KAAK2B,MAAQ,IAAIuC,EAAWa,gBAAgB/E,KAAMiM,IAItD,GAAIumB,EAAU3wB,OAASqC,EAAWnH,KAAKgB,UACrC,GAAW,MAAPgD,EAAY,CACVI,EAAYrC,IAAOX,EAASgD,GAChC,YAEG,GAAW,MAAPJ,IAAef,KAAK2B,MAAO,CAEpC,MAAMpB,EAAOtC,EAAIE,EAAS,GAE1B,IAAKoC,GAAiB,OAATA,GAA0B,OAATA,GAA0B,MAATA,EAAc,CAC3D,MAAM0L,EAAM,uDACZjM,KAAK2B,MAAQ,IAAIuC,EAAWa,gBAAgB/E,KAAMiM,IAItD,MAAMjF,EAAO2qB,EAAU,CACrBxe,cACA4e,cAAc,EACd7wB,SACAC,YACAqQ,OAAQxR,MACP7B,GACH,IAAK6I,EAAM,OAAO7I,EAWlB,GATA6B,KAAKwH,MAAMnJ,KAAK2I,GAChBhH,KAAKiC,WAAW/C,IAAM8H,EAAK/E,WAAW/C,IACtCf,EAAS+F,EAAW7D,KAAKwyB,gBAAgB50B,EAAK+I,EAAKhF,MAAM9C,KACzD6B,EAAK9C,EAAIE,GACTgV,GAAc,EACd2f,EAA4B9rB,EAAK0qB,sBAI7B3wB,EAAI,CACN,IAAI7C,EAAKC,EAAS,EACdwC,EAAO1C,EAAIC,GAEf,KAAgB,MAATyC,GAAyB,OAATA,GAAeA,EAAO1C,IAAMC,GAEtC,OAATyC,IACFQ,EAAYjD,EAAK,EACjBiV,GAAc,GAIlB,MAAMuf,EAAKR,EAA0BlrB,GACjC0rB,GAAIj0B,MAAMrC,UAAUiC,KAAKsP,MAAM3N,KAAKwH,MAAOkrB,GAGjD,OAAOv0B,EAGT,cAAc8B,EAAI9B,GAKhB,OAJAA,EAASyF,MAAMouB,cAAc/xB,EAAI9B,GACjC6B,KAAKwH,MAAMlE,QAAQ0D,IACjB7I,EAAS6I,EAAKgrB,cAAc/xB,EAAI9B,KAE3BA,EAGT,WACE,MACEQ,SAAS,IACPV,GACD,MACDuJ,EAAK,MACLxF,EAAK,MACLvG,GACEuE,KACJ,GAAa,MAATvE,EAAe,OAAOA,EAC1B,IAAI6E,EAAMrC,EAAImB,MAAM4C,EAAMlD,MAAO0I,EAAM,GAAGxF,MAAMlD,OAAS+G,OAAO2B,EAAM,IAEtE,IAAK,IAAIhN,EAAI,EAAGA,EAAIgN,EAAM3I,SAAUrE,EAAG,CACrC,MAAMqO,EAAOrB,EAAMhN,IACb,YACJ2Y,EAAW,OACXjS,GACE2H,EAAKlK,QACT,GAAIwU,EAAa,IAAK,IAAI3Y,EAAI,EAAGA,EAAI0G,IAAU1G,EAAG8F,GAAO,IACzDA,GAAOuF,OAAOgD,GAGhB,OAAO3E,EAAW7D,KAAKkD,oBAAoBtF,EAAK+D,EAAM9C,IAAKoB,IAK/D,MAAMyyB,UAAkB7uB,EAAW7D,KACjC,cACEuD,MAAMM,EAAWnH,KAAKK,WACtB4C,KAAKjF,KAAO,KAGd,iBACE,MAAM8vB,EAAM7qB,KAAK6R,SACjB,OAAOgZ,EAAMA,EAAImI,OAAO5kB,MAAM,UAAY,GAG5C,UAAUtP,GACR,MAAM,IACJb,GACE+B,KAAKrB,QACT,IAAIR,EAASW,EACTiC,EAAK9C,EAAIE,GAEb,KAAO4C,GAAa,OAAPA,GAAsB,OAAPA,GAAsB,MAAPA,GAAYA,EAAK9C,EAAIE,GAAU,GAG1E,OADA6B,KAAKjF,KAAOkD,EAAImB,MAAMN,EAAOX,GACtBA,EAGT,gBAAgBW,GACd,MAAM,IACJb,GACE+B,KAAKrB,QACT,IAAIR,EAASW,EACTiC,EAAK9C,EAAIE,GAEb,KAAO4C,GAAa,OAAPA,GAAsB,MAAPA,GAAYA,EAAK9C,EAAIE,GAAU,GAG3D,OADA6B,KAAKiC,WAAa,IAAIiC,EAAWpE,MAAMhB,EAAOX,GACvCA,EAGT,MAAMQ,EAASG,GACbkB,KAAKrB,QAAUA,EACf,IAAIR,EAAS6B,KAAKizB,UAAUn0B,EAAQ,GAIpC,OAHAX,EAAS6B,KAAKkzB,gBAAgB/0B,GAC9BA,EAAS6B,KAAK2E,aAAaxG,GAC3B6B,KAAKgC,MAAQ,IAAIkC,EAAWpE,MAAMhB,EAAOX,GAClCA,GAKX,MAAM2yB,UAAiB5sB,EAAW7D,KAChC,kCAAkCpC,EAAKa,GACrC,MAAMX,EAAS+F,EAAW7D,KAAKG,gBAAgBvC,EAAKa,GAC9CiC,EAAK9C,EAAIE,GACf,MAAc,MAAP4C,GAAqB,OAAPA,EAAc5C,EAASW,EAG9C,cACE8E,MAAMM,EAAWnH,KAAKM,UACtB2C,KAAKmzB,WAAa,KAClBnzB,KAAKuxB,SAAW,KAChBvxB,KAAKozB,oBAAsB,KAC3BpzB,KAAKqzB,kBAAoB,KAG3B,gBAAgBv0B,GACd,MAAM,IACJb,GACE+B,KAAKrB,QACTqB,KAAKmzB,WAAa,GAClB,IAAIhgB,GAAc,EACdmgB,GAAgB,EAChBn1B,EAASW,EAEb,MAAQoF,EAAW7D,KAAKmE,mBAAmBvG,EAAKE,EAAQ+F,EAAWzH,KAAKI,iBAGtE,OAFAsB,EAAS2yB,EAASyC,2BAA2Bt1B,EAAKE,GAE1CF,EAAIE,IACV,IAAK,KACH,GAAIgV,EAAa,CACf,MAAM0e,EAAY,IAAIL,EACtBrzB,EAAS0zB,EAAUlI,MAAM,CACvB1rB,OACCE,GAECA,EAASF,EAAIY,QACfmB,KAAKmzB,WAAW90B,KAAKwzB,QAGvB1zB,GAAU,EACVgV,GAAc,EAGhB,MAEF,IAAK,IACH,CACE,MAAM3Q,EAAU,IAAIyvB,EACpB9zB,EAASqE,EAAQmnB,MAAM,CACrB1rB,OACCE,GACH6B,KAAKmzB,WAAW90B,KAAKmE,GACrB2Q,GAAc,EAEhB,MAEF,IAAK,IACH,CACE,MAAMqgB,EAAY,IAAIT,EACtB50B,EAASq1B,EAAU7J,MAAM,CACvBnY,OAAQxR,KACR/B,OACCE,GACH6B,KAAKmzB,WAAW90B,KAAKm1B,GACrBF,GAAgB,EAChBngB,GAAc,EAEhB,MAEF,QAQE,OAPImgB,EACFtzB,KAAK2B,MAAQ,IAAIuC,EAAWD,kBAAkBjE,KAAM,yCAC3CA,KAAKmzB,WAAWt0B,OAAS,IAClCmB,KAAKuxB,SAAWvxB,KAAKmzB,WACrBnzB,KAAKmzB,WAAa,IAGbh1B,EAIb,OAAIF,EAAIE,IACN6B,KAAKozB,oBAAsB,IAAIlvB,EAAWpE,MAAM3B,EAAQA,EAAS,GAC1DA,EAAS,IAGdm1B,EACFtzB,KAAK2B,MAAQ,IAAIuC,EAAWD,kBAAkBjE,KAAM,yCAC3CA,KAAKmzB,WAAWt0B,OAAS,IAClCmB,KAAKuxB,SAAWvxB,KAAKmzB,WACrBnzB,KAAKmzB,WAAa,IAGbh1B,GAGT,cAAcW,GACZ,MAAM,UACJ6yB,EAAS,IACT1zB,GACE+B,KAAKrB,QACJqB,KAAKuxB,WAAUvxB,KAAKuxB,SAAW,IACpC,IAAIpwB,EAAYrC,EAEhB,KAA8B,MAAvBb,EAAIkD,EAAY,IAAYA,GAAa,EAEhD,IAAIhD,EAAS+F,EAAW7D,KAAKG,gBAAgBvC,EAAKa,GAC9CqU,EAAchS,IAAcrC,EAGhC,IAFAkB,KAAKiC,WAAa,IAAIiC,EAAWpE,MAAM3B,IAE/B+F,EAAW7D,KAAKmE,mBAAmBvG,EAAKE,EAAQ+F,EAAWzH,KAAKK,eAAe,CACrF,OAAQmB,EAAIE,IACV,IAAK,KACH,GAAIgV,EAAa,CACf,MAAM0e,EAAY,IAAIL,EACtBrzB,EAAS0zB,EAAUlI,MAAM,CACvB1rB,OACCE,GAECA,EAASF,EAAIY,QACfmB,KAAKuxB,SAASlzB,KAAKwzB,QAGrB1zB,GAAU,EACVgV,GAAc,EAGhBhS,EAAYhD,EACZ,MAEF,IAAK,IACH,CACE,MAAMqE,EAAU,IAAIyvB,EACpB9zB,EAASqE,EAAQmnB,MAAM,CACrB1rB,OACCE,GACH6B,KAAKuxB,SAASlzB,KAAKmE,GACnB2Q,GAAc,EAEhB,MAEF,QACE,CACE,MAAMsgB,EAAOvvB,EAAW7D,KAAKgB,YAAYpD,EAAKE,GASxC6I,EAAO2qB,EARG,CACdxe,cACAjS,QAAS,EACTiD,QAAQ,EACR4tB,cAAc,EACd5wB,YACAqQ,OAAQxR,MAEsByzB,GAChC,IAAKzsB,EAAM,OAAOhH,KAAKiC,WAAW/C,IAAMu0B,EAExCzzB,KAAKuxB,SAASlzB,KAAK2I,GACnB7I,EAAS6I,EAAKhF,MAAM9C,IACpBiU,GAAc,EACd,MAAMuf,EAAKR,EAA0BlrB,GACjC0rB,GAAIj0B,MAAMrC,UAAUiC,KAAKsP,MAAM3N,KAAKuxB,SAAUmB,IAIxDv0B,EAAS2yB,EAASyC,2BAA2Bt1B,EAAKE,GAKpD,GAFA6B,KAAKiC,WAAW/C,IAAMf,EAElBF,EAAIE,KACN6B,KAAKqzB,kBAAoB,IAAInvB,EAAWpE,MAAM3B,EAAQA,EAAS,GAC/DA,GAAU,EAENF,EAAIE,IAAS,CAGf,GAFAA,EAAS+F,EAAW7D,KAAKG,gBAAgBvC,EAAKE,GAE1B,MAAhBF,EAAIE,GAAiB,CACvB,MAAMqE,EAAU,IAAIyvB,EACpB9zB,EAASqE,EAAQmnB,MAAM,CACrB1rB,OACCE,GACH6B,KAAKuxB,SAASlzB,KAAKmE,GAGrB,OAAQvE,EAAIE,IACV,IAAK,KACHA,GAAU,EACV,MAEF,UAAK+I,EACH,MAEF,QACElH,KAAK2B,MAAQ,IAAIuC,EAAWa,gBAAgB/E,KAAM,8DAK1D,OAAO7B,EAST,MAAMQ,EAASG,GACbH,EAAQiE,KAAO5C,KACfA,KAAKrB,QAAUA,EACf,MAAM,IACJV,GACEU,EACJ,IAAIR,EAAmC,QAA1BF,EAAIse,WAAWzd,GAAoBA,EAAQ,EAAIA,EAI5D,OAFAX,EAAS6B,KAAK0zB,gBAAgBv1B,GAC9BA,EAAS6B,KAAK2zB,cAAcx1B,GACrBA,EAGT,cAAc8B,EAAI9B,GAUhB,OATAA,EAASyF,MAAMouB,cAAc/xB,EAAI9B,GACjC6B,KAAKmzB,WAAW7vB,QAAQ0D,IACtB7I,EAAS6I,EAAKgrB,cAAc/xB,EAAI9B,KAE9B6B,KAAKozB,sBAAqBj1B,EAAS6B,KAAKozB,oBAAoB/vB,aAAapD,EAAI9B,IACjF6B,KAAKuxB,SAASjuB,QAAQ0D,IACpB7I,EAAS6I,EAAKgrB,cAAc/xB,EAAI9B,KAE9B6B,KAAKqzB,oBAAmBl1B,EAAS6B,KAAKqzB,kBAAkBhwB,aAAapD,EAAI9B,IACtEA,EAGT,WACE,MAAM,SACJozB,EAAQ,WACR4B,EAAU,MACV13B,GACEuE,KACJ,GAAa,MAATvE,EAAe,OAAOA,EAC1B,IAAI6E,EAAM6yB,EAAW1wB,KAAK,IAQ1B,OANI8uB,EAAS1yB,OAAS,KAChBs0B,EAAWt0B,OAAS,GAAK0yB,EAAS,GAAG1vB,OAASqC,EAAWnH,KAAKJ,WAAS2D,GAAO,SAClFA,GAAOixB,EAAS9uB,KAAK,KAGK,OAAxBnC,EAAIA,EAAIzB,OAAS,KAAayB,GAAO,MAClCA,GAKX,MAAMiL,UAAcrH,EAAW7D,KAQ7B,MAAM1B,EAASG,GACbkB,KAAKrB,QAAUA,EACf,MAAM,IACJV,GACEU,EACJ,IAAIR,EAAS+F,EAAW7D,KAAKuzB,gBAAgB31B,EAAKa,EAAQ,GAI1D,OAHAkB,KAAKiC,WAAa,IAAIiC,EAAWpE,MAAMhB,EAAQ,EAAGX,GAClDA,EAAS+F,EAAW7D,KAAKG,gBAAgBvC,EAAKE,GAC9CA,EAAS6B,KAAK2E,aAAaxG,GACpBA,GAKX,MAAM01B,EACE,OADFA,EAEE,OAFFA,EAGG,QAET,MAAMC,UAAmB5vB,EAAW7D,KAClC,YAAYwB,EAAMC,GAChB8B,MAAM/B,EAAMC,GACZ9B,KAAK+zB,YAAc,KACnB/zB,KAAKg0B,SAAWH,EAChB7zB,KAAK0C,OAAS,KAGhB,4BACE,OAAO1C,KAAKg0B,WAAaH,EAG3B,eACE,IAAK7zB,KAAKiC,aAAejC,KAAKrB,QAAS,OAAO,KAC9C,IAAI,MACFG,EAAK,IACLI,GACEc,KAAKiC,WACT,MAAM,OACJf,EAAM,IACNjD,GACE+B,KAAKrB,QACT,GAAIqB,KAAKiC,WAAWyC,UAAW,MAAO,GACtC,IAAIuvB,EAAc,KACdlzB,EAAK9C,EAAIiB,EAAM,GAEnB,KAAc,OAAP6B,GAAsB,OAAPA,GAAsB,MAAPA,GAAY,CAG/C,GAFA7B,GAAO,EAEHA,GAAOJ,EAAO,CAChB,GAAIkB,KAAKg0B,WAAaH,EAAY,MAAW,MAAO,GAG3C,OAAP9yB,IAAakzB,EAAc/0B,GAC/B6B,EAAK9C,EAAIiB,EAAM,GAGjB,IAAIg1B,EAAYh1B,EAAM,EAElB+0B,IACEj0B,KAAKg0B,WAAaH,GACpBK,EAAYD,EACZ/0B,EAAMc,KAAKiC,WAAW/C,KAEtBA,EAAM+0B,GAIV,MAAME,EAAKjzB,EAASlB,KAAK+zB,YACnBK,EAASp0B,KAAK6B,OAASqC,EAAWnH,KAAKG,aAC7C,IAAIm3B,GAAU,EACV/zB,EAAM,GACNG,EAAM,GACN6zB,GAAmB,EAEvB,IAAK,IAAI95B,EAAIsE,EAAOtE,EAAI0E,IAAO1E,EAAG,CAChC,IAAK,IAAI+Y,EAAI,EAAGA,EAAI4gB,GACH,MAAXl2B,EAAIzD,KADgB+Y,EAExB/Y,GAAK,EAGP,MAAMuG,EAAK9C,EAAIzD,GAEf,GAAW,OAAPuG,EACU,OAARN,EAAcH,GAAO,KAAUG,EAAM,SACpC,CACL,MAAM8zB,EAAUrwB,EAAW7D,KAAK8C,UAAUlF,EAAKzD,GACzCuE,EAAOd,EAAImB,MAAM5E,EAAG+5B,GAC1B/5B,EAAI+5B,EAEAH,IAAkB,MAAPrzB,GAAqB,OAAPA,IAAgBvG,EAAI05B,GACnC,MAARzzB,EAAaA,EAAM,KAAe6zB,GAAqBD,GAAmB,OAAR5zB,IAAcA,EAAM,QAC1FH,GAAOG,EAAM1B,EAEb0B,EAAM8zB,EAAUr1B,GAAOjB,EAAIs2B,IAAY,GACvCD,GAAmB,IAEnBh0B,GAAOG,EAAM1B,EACb0B,EAAM2zB,GAAU55B,EAAI05B,EAAY,IAAM,KACtCI,GAAmB,GAGjBD,GAAoB,KAATt1B,IAAas1B,GAAU,IAI1C,OAAOr0B,KAAKg0B,WAAaH,EAAcvzB,EAAMA,EAAM,KAGrD,iBAAiBxB,GACf,MAAM,IACJb,GACE+B,KAAKrB,QACT,IAAIR,EAASW,EAAQ,EACjBq1B,EAAK,GAET,OAAa,CACX,MAAMpzB,EAAK9C,EAAIE,GAEf,OAAQ4C,GACN,IAAK,IACHf,KAAKg0B,SAAWH,EAChB,MAEF,IAAK,IACH7zB,KAAKg0B,SAAWH,EAChB,MAEF,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACHM,GAAMpzB,EACN,MAEF,QAGE,OAFAf,KAAK+zB,YAAc7tB,OAAOiuB,IAAO,KACjCn0B,KAAK0C,OAAS,IAAIwB,EAAWpE,MAAMhB,EAAOX,GACnCA,EAGXA,GAAU,GAId,gBAAgBW,GACd,MAAM,OACJoC,EAAM,IACNjD,GACE+B,KAAKrB,QACH61B,IAAax0B,KAAK+zB,YACxB,IAAI51B,EAASW,EACTyF,EAAWzF,EACX21B,EAAiB,EAErB,IAAK,IAAI1zB,EAAK9C,EAAIE,GAAgB,OAAP4C,IACzB5C,GAAU,GACN+F,EAAW7D,KAAKmE,mBAAmBvG,EAAKE,IAFN4C,EAAK9C,EAAIE,GAAS,CAGxD,MAAMe,EAAMgF,EAAW7D,KAAKoE,iBAAiBxG,EAAKiD,EAAQ/C,GAE1D,GAAY,OAARe,EAAc,MAClB,MAAM6B,EAAK9C,EAAIiB,GACTw1B,EAAax1B,GAAOf,EAAS+C,GAEnC,GAAKlB,KAAK+zB,aAcH,GAAIhzB,GAAa,OAAPA,GAAe2zB,EAAa10B,KAAK+zB,YAAa,CAC7D,GAAiB,MAAb91B,EAAIiB,GAAc,MAEtB,IAAKc,KAAK2B,MAAO,CACf,MACMsK,EAAM,uDADAuoB,EAAW,iCAAmC,cAE1Dx0B,KAAK2B,MAAQ,IAAIuC,EAAWD,kBAAkBjE,KAAMiM,UAlBtD,GAAiB,OAAbhO,EAAIiB,GAAe,CAErB,GAAIw1B,EAAaD,EAAgB,CAC/B,MAAMxoB,EAAM,kGACZjM,KAAK2B,MAAQ,IAAIuC,EAAWD,kBAAkBjE,KAAMiM,GAGtDjM,KAAK+zB,YAAcW,OACVA,EAAaD,IAEtBA,EAAiBC,GAanBv2B,EADe,OAAbF,EAAIiB,GACGA,EAEAqF,EAAWL,EAAW7D,KAAK8C,UAAUlF,EAAKiB,GASvD,OALIc,KAAKg0B,WAAaH,IACpB11B,EAASF,EAAIsG,GAAYA,EAAW,EAAIA,GAG1CvE,KAAKiC,WAAa,IAAIiC,EAAWpE,MAAMhB,EAAQ,EAAGX,GAC3CA,EAwBT,MAAMQ,EAASG,GACbkB,KAAKrB,QAAUA,EACf,MAAM,IACJV,GACEU,EACJ,IAAIR,EAAS6B,KAAK20B,iBAAiB71B,GAInC,OAHAX,EAAS+F,EAAW7D,KAAKG,gBAAgBvC,EAAKE,GAC9CA,EAAS6B,KAAK2E,aAAaxG,GAC3BA,EAAS6B,KAAK6E,gBAAgB1G,GACvBA,EAGT,cAAc8B,EAAI9B,GAEhB,OADAA,EAASyF,MAAMouB,cAAc/xB,EAAI9B,GAC1B6B,KAAK0C,OAAS1C,KAAK0C,OAAOW,aAAapD,EAAI9B,GAAUA,GAKhE,MAAMy2B,UAAuB1wB,EAAW7D,KACtC,YAAYwB,EAAMC,GAChB8B,MAAM/B,EAAMC,GACZ9B,KAAKwH,MAAQ,KAGf,mBAAmBtF,EAAMlC,KAAKwH,MAAM3I,QAClC,MAAMmI,EAAOhH,KAAKwH,MAAMtF,EAAM,GAC9B,QAAS8E,IAASA,EAAK6tB,UAAY7tB,EAAKnF,OAASqC,EAAWnH,KAAKJ,SAAWqD,KAAK80B,mBAAmB5yB,EAAM,IAS5G,MAAMvD,EAASG,GACbkB,KAAKrB,QAAUA,EACf,MAAM,UACJgzB,EAAS,IACT1zB,GACEU,EACJ,IAAI,OACFuC,EAAM,UACNC,GACExC,EACAyQ,EAAOnR,EAAIa,GAEfkB,KAAKwH,MAAQ,CAAC,CACZ4H,OACAjR,OAAQW,IAEV,IAAIX,EAAS+F,EAAW7D,KAAKG,gBAAgBvC,EAAKa,EAAQ,GAG1D,IAFAsQ,EAAOnR,EAAIE,GAEJiR,GAAiB,MAATA,GAAyB,MAATA,GAAc,CAC3C,OAAQA,GACN,IAAK,KAEDjO,EAAYhD,EAAS,EAGrB,GAAmB,OAAfF,EAFUiG,EAAW7D,KAAKG,gBAAgBvC,EAAKkD,IAE1B,CACvB,MAAM0wB,EAAY,IAAIL,EACtBrwB,EAAY0wB,EAAUlI,MAAM,CAC1B1rB,OACCkD,GACHnB,KAAKwH,MAAMnJ,KAAKwzB,GAKlB,GAFA1zB,EAAS+F,EAAW7D,KAAKgB,YAAYpD,EAAKkD,GAEtChD,GAAUgD,EAAYD,IACxBkO,EAAOnR,EAAIE,GAEPA,EAASgD,EAAYD,GAAmB,MAATkO,GAAyB,MAATA,GAAc,CAC/D,MAAMnD,EAAM,8CACZjM,KAAK2B,MAAQ,IAAIuC,EAAWD,kBAAkBjE,KAAMiM,GAI1D,MAEF,IAAK,IAEDjM,KAAKwH,MAAMnJ,KAAK,CACd+Q,OACAjR,WAEFA,GAAU,EAEZ,MAEF,IAAK,IACH,CACE,MAAMqE,EAAU,IAAIyvB,EACpB9zB,EAASqE,EAAQmnB,MAAM,CACrB1rB,OACCE,GACH6B,KAAKwH,MAAMnJ,KAAKmE,GAElB,MAEF,IAAK,IACL,IAAK,IACH,CACE,MAAMjC,EAAOtC,EAAIE,EAAS,GAE1B,GAAa,OAAToC,GAA0B,OAATA,GAA0B,MAATA,GAAyB,MAATA,GAC7C,MAAT6O,GAAgBpP,KAAK80B,qBAAsB,CACzC90B,KAAKwH,MAAMnJ,KAAK,CACd+Q,OACAjR,WAEFA,GAAU,EACV,OAKN,QACE,CACE,MAAM6I,EAAO2qB,EAAU,CACrBxe,aAAa,EACb4e,cAAc,EACd5tB,QAAQ,EACRjD,QAAS,EACTC,YACAqQ,OAAQxR,MACP7B,GAEH,IAAK6I,EAGH,OADAhH,KAAKiC,WAAa,IAAIiC,EAAWpE,MAAMhB,EAAOX,GACvCA,EAGT6B,KAAKwH,MAAMnJ,KAAK2I,GAChB7I,EAAS+F,EAAW7D,KAAKwyB,gBAAgB50B,EAAK+I,EAAKhF,MAAM9C,MAI/Df,EAAS+F,EAAW7D,KAAKG,gBAAgBvC,EAAKE,GAC9CiR,EAAOnR,EAAIE,GAcb,OAXA6B,KAAKiC,WAAa,IAAIiC,EAAWpE,MAAMhB,EAAOX,EAAS,GAEnDiR,IACFpP,KAAKwH,MAAMnJ,KAAK,CACd+Q,OACAjR,WAEFA,EAAS+F,EAAW7D,KAAKG,gBAAgBvC,EAAKE,EAAS,GACvDA,EAAS6B,KAAK2E,aAAaxG,IAGtBA,EAGT,cAAc8B,EAAI9B,GAkBhB,OAjBAA,EAASyF,MAAMouB,cAAc/xB,EAAI9B,GACjC6B,KAAKwH,MAAMlE,QAAQ0D,IACjB,GAAIA,aAAgB9C,EAAW7D,KAC7BlC,EAAS6I,EAAKgrB,cAAc/xB,EAAI9B,QAC3B,GAAkB,IAAd8B,EAAGpB,OACZmI,EAAK+tB,WAAa/tB,EAAK7I,WAClB,CACL,IAAI3D,EAAI2D,EAER,KAAO3D,EAAIyF,EAAGpB,UACRoB,EAAGzF,GAAKwM,EAAK7I,WAAqB3D,EAGxCwM,EAAK+tB,WAAa/tB,EAAK7I,OAAS3D,EAChC2D,EAAS3D,KAGN2D,EAGT,WACE,MACEQ,SAAS,IACPV,GACD,MACDuJ,EAAK,MACLxF,EAAK,MACLvG,GACEuE,KACJ,GAAa,MAATvE,EAAe,OAAOA,EAC1B,MAAMkN,EAAQnB,EAAM2T,OAAOtS,GAAQA,aAAgB3E,EAAW7D,MAC9D,IAAIC,EAAM,GACNgyB,EAAUtwB,EAAMlD,MAcpB,OAbA6J,EAAMrF,QAAQ0D,IACZ,MAAMkJ,EAASjS,EAAImB,MAAMkzB,EAAStrB,EAAKhF,MAAMlD,OAC7CwzB,EAAUtrB,EAAKhF,MAAM9C,IACrBoB,GAAO4P,EAASrK,OAAOmB,GAEK,OAAxB1G,EAAIA,EAAIzB,OAAS,IAAoC,OAArBZ,EAAIq0B,EAAU,IAAgC,OAAjBr0B,EAAIq0B,KAInEA,GAAW,KAGfhyB,GAAOrC,EAAImB,MAAMkzB,EAAStwB,EAAM9C,KACzBgF,EAAW7D,KAAKkD,oBAAoBtF,EAAK+D,EAAM9C,IAAKoB,IAK/D,MAAM00B,UAAoB9wB,EAAW7D,KACnC,kBAAkBpC,EAAKE,GACrB,IAAI4C,EAAK9C,EAAIE,GAEb,KAAO4C,GAAa,MAAPA,GAEXA,EAAK9C,EADLE,GAAiB,OAAP4C,EAAc,EAAI,GAI9B,OAAO5C,EAAS,EAOlB,eACE,IAAK6B,KAAKiC,aAAejC,KAAKrB,QAAS,OAAO,KAC9C,MAAM2F,EAAS,IACT,MACJxF,EAAK,IACLI,GACEc,KAAKiC,YACH,OACJf,EAAM,IACNjD,GACE+B,KAAKrB,QACY,MAAjBV,EAAIiB,EAAM,IAAYoF,EAAOjG,KAAK,IAAI6F,EAAWa,gBAAgB/E,KAAM,2BAG3E,IAAIM,EAAM,GAEV,IAAK,IAAI9F,EAAIsE,EAAQ,EAAGtE,EAAI0E,EAAM,IAAK1E,EAAG,CACxC,MAAMuG,EAAK9C,EAAIzD,GAEf,GAAW,OAAPuG,EAAa,CACXmD,EAAW7D,KAAKmE,mBAAmBvG,EAAKzD,EAAI,IAAI8J,EAAOjG,KAAK,IAAI6F,EAAWD,kBAAkBjE,KAAM,sEACvG,MAAM,KACJ4B,EAAI,OACJzD,EAAM,MACNwD,GACEuC,EAAW7D,KAAK+D,YAAYnG,EAAKzD,EAAG0G,GACxCZ,GAAOsB,EACPpH,EAAI2D,EACAwD,GAAO2C,EAAOjG,KAAK,IAAI6F,EAAWD,kBAAkBjE,KAAM,2EACzD,GAAW,OAAPe,EAGT,OAFAvG,GAAK,EAEGyD,EAAIzD,IACV,IAAK,IACH8F,GAAO,KACP,MAGF,IAAK,IACHA,GAAO,IACP,MAGF,IAAK,IACHA,GAAO,KACP,MAGF,IAAK,IACHA,GAAO,IACP,MAGF,IAAK,IACHA,GAAO,KACP,MAGF,IAAK,IACHA,GAAO,KACP,MAGF,IAAK,IACHA,GAAO,KACP,MAGF,IAAK,IACHA,GAAO,KACP,MAGF,IAAK,IACHA,GAAO,KACP,MAGF,IAAK,IACHA,GAAO,IACP,MAGF,IAAK,IACHA,GAAO,IACP,MAGF,IAAK,IACHA,GAAO,SACP,MAGF,IAAK,IACHA,GAAO,SACP,MAGF,IAAK,IACHA,GAAO,IACP,MAEF,IAAK,IACHA,GAAO,IACP,MAEF,IAAK,IACHA,GAAO,IACP,MAEF,IAAK,KACHA,GAAO,KACP,MAEF,IAAK,KACHA,GAAO,KACP,MAEF,IAAK,IACHA,GAAON,KAAKi1B,cAAcz6B,EAAI,EAAG,EAAG8J,GACpC9J,GAAK,EACL,MAEF,IAAK,IACH8F,GAAON,KAAKi1B,cAAcz6B,EAAI,EAAG,EAAG8J,GACpC9J,GAAK,EACL,MAEF,IAAK,IACH8F,GAAON,KAAKi1B,cAAcz6B,EAAI,EAAG,EAAG8J,GACpC9J,GAAK,EACL,MAEF,IAAK,KAEH,KAAsB,MAAfyD,EAAIzD,EAAI,IAA6B,OAAfyD,EAAIzD,EAAI,IAAaA,GAAK,EAEvD,MAEF,QACE8J,EAAOjG,KAAK,IAAI6F,EAAWa,gBAAgB/E,KAAM,2BAA2B/B,EAAIqB,OAAO9E,EAAI,EAAG,KAC9F8F,GAAO,KAAOrC,EAAIzD,QAEjB,GAAW,MAAPuG,GAAqB,OAAPA,EAAa,CAEpC,MAAMsD,EAAU7J,EAChB,IAAI+F,EAAOtC,EAAIzD,EAAI,GAEnB,KAAgB,MAAT+F,GAAyB,OAATA,GACrB/F,GAAK,EACL+F,EAAOtC,EAAIzD,EAAI,GAGJ,OAAT+F,IAAeD,GAAO9F,EAAI6J,EAAUpG,EAAImB,MAAMiF,EAAS7J,EAAI,GAAKuG,QAEpET,GAAOS,EAIX,OAAOuD,EAAOzF,OAAS,EAAI,CACzByF,SACAhE,OACEA,EAGN,cAAcnC,EAAQU,EAAQyF,GAC5B,MAAM,IACJrG,GACE+B,KAAKrB,QACH6T,EAAKvU,EAAIqB,OAAOnB,EAAQU,GAExB6P,EADK8D,EAAG3T,SAAWA,GAAU,iBAAiB4O,KAAK+E,GACvCsF,SAAStF,EAAI,IAAMiG,IAErC,OAAI7D,MAAMlG,IACRpK,EAAOjG,KAAK,IAAI6F,EAAWa,gBAAgB/E,KAAM,2BAA2B/B,EAAIqB,OAAOnB,EAAS,EAAGU,EAAS,KACrGZ,EAAIqB,OAAOnB,EAAS,EAAGU,EAAS,IAGlCgH,OAAOqvB,cAAcxmB,GAW9B,MAAM/P,EAASG,GACbkB,KAAKrB,QAAUA,EACf,MAAM,IACJV,GACEU,EACJ,IAAIR,EAAS62B,EAAYG,WAAWl3B,EAAKa,EAAQ,GAIjD,OAHAkB,KAAKiC,WAAa,IAAIiC,EAAWpE,MAAMhB,EAAOX,GAC9CA,EAAS+F,EAAW7D,KAAKG,gBAAgBvC,EAAKE,GAC9CA,EAAS6B,KAAK2E,aAAaxG,GACpBA,GAKX,MAAMi3B,UAAoBlxB,EAAW7D,KACnC,kBAAkBpC,EAAKE,GACrB,IAAI4C,EAAK9C,EAAIE,GAEb,KAAO4C,GACL,GAAW,MAAPA,EAAY,CACd,GAAwB,MAApB9C,EAAIE,EAAS,GAAY,MAC7B4C,EAAK9C,EAAIE,GAAU,QAEnB4C,EAAK9C,EAAIE,GAAU,GAIvB,OAAOA,EAAS,EAOlB,eACE,IAAK6B,KAAKiC,aAAejC,KAAKrB,QAAS,OAAO,KAC9C,MAAM2F,EAAS,IACT,MACJxF,EAAK,IACLI,GACEc,KAAKiC,YACH,OACJf,EAAM,IACNjD,GACE+B,KAAKrB,QACY,MAAjBV,EAAIiB,EAAM,IAAYoF,EAAOjG,KAAK,IAAI6F,EAAWa,gBAAgB/E,KAAM,2BAC3E,IAAIM,EAAM,GAEV,IAAK,IAAI9F,EAAIsE,EAAQ,EAAGtE,EAAI0E,EAAM,IAAK1E,EAAG,CACxC,MAAMuG,EAAK9C,EAAIzD,GAEf,GAAW,OAAPuG,EAAa,CACXmD,EAAW7D,KAAKmE,mBAAmBvG,EAAKzD,EAAI,IAAI8J,EAAOjG,KAAK,IAAI6F,EAAWD,kBAAkBjE,KAAM,sEACvG,MAAM,KACJ4B,EAAI,OACJzD,EAAM,MACNwD,GACEuC,EAAW7D,KAAK+D,YAAYnG,EAAKzD,EAAG0G,GACxCZ,GAAOsB,EACPpH,EAAI2D,EACAwD,GAAO2C,EAAOjG,KAAK,IAAI6F,EAAWD,kBAAkBjE,KAAM,2EACzD,GAAW,MAAPe,EACTT,GAAOS,EACPvG,GAAK,EACU,MAAXyD,EAAIzD,IAAY8J,EAAOjG,KAAK,IAAI6F,EAAWa,gBAAgB/E,KAAM,yDAChE,GAAW,MAAPe,GAAqB,OAAPA,EAAa,CAEpC,MAAMsD,EAAU7J,EAChB,IAAI+F,EAAOtC,EAAIzD,EAAI,GAEnB,KAAgB,MAAT+F,GAAyB,OAATA,GACrB/F,GAAK,EACL+F,EAAOtC,EAAIzD,EAAI,GAGJ,OAAT+F,IAAeD,GAAO9F,EAAI6J,EAAUpG,EAAImB,MAAMiF,EAAS7J,EAAI,GAAKuG,QAEpET,GAAOS,EAIX,OAAOuD,EAAOzF,OAAS,EAAI,CACzByF,SACAhE,OACEA,EAWN,MAAM3B,EAASG,GACbkB,KAAKrB,QAAUA,EACf,MAAM,IACJV,GACEU,EACJ,IAAIR,EAASi3B,EAAYD,WAAWl3B,EAAKa,EAAQ,GAIjD,OAHAkB,KAAKiC,WAAa,IAAIiC,EAAWpE,MAAMhB,EAAOX,GAC9CA,EAAS+F,EAAW7D,KAAKG,gBAAgBvC,EAAKE,GAC9CA,EAAS6B,KAAK2E,aAAaxG,GACpBA,GAmDX,MAAMk3B,EACJ,iBAAiBp3B,EAAKE,EAAQgG,GAC5B,OAAQlG,EAAIE,IACV,IAAK,IACH,OAAO+F,EAAWnH,KAAKC,MAEzB,IAAK,IACH,OAAOkH,EAAWnH,KAAKG,aAEzB,IAAK,IACH,OAAOgH,EAAWnH,KAAKI,cAEzB,IAAK,IACH,OAAO+G,EAAWnH,KAAKO,SAEzB,IAAK,IACH,OAAO4G,EAAWnH,KAAKQ,SAEzB,IAAK,IACH,OAAQ4G,GAAUD,EAAW7D,KAAKsC,QAAQ1E,EAAKE,EAAS,GAAG,GAAQ+F,EAAWnH,KAAKU,QAAUyG,EAAWnH,KAAKY,MAE/G,IAAK,IACH,OAAQwG,GAAUD,EAAW7D,KAAKsC,QAAQ1E,EAAKE,EAAS,GAAG,GAAQ+F,EAAWnH,KAAKW,UAAYwG,EAAWnH,KAAKY,MAEjH,IAAK,IACH,OAAQwG,GAAUD,EAAW7D,KAAKsC,QAAQ1E,EAAKE,EAAS,GAAG,GAAQ+F,EAAWnH,KAAKgB,SAAWmG,EAAWnH,KAAKY,MAEhH,IAAK,IACH,OAAOuG,EAAWnH,KAAKa,aAEzB,IAAK,IACH,OAAOsG,EAAWnH,KAAKc,aAEzB,QACE,OAAOqG,EAAWnH,KAAKY,OAI7B,YAAYoC,EAAO,IAAI,YACrBoT,EAAW,aACX4e,EAAY,OACZ5tB,EAAM,OACNjD,EAAM,UACNC,EAAS,OACTqQ,GACE,IACFtN,EAAWe,gBAAgBjF,KAAM,YAAa,CAACs1B,EAASx2B,KACtD,GAAIoF,EAAW7D,KAAKmE,mBAAmBxE,KAAK/B,IAAKa,GAAQ,OAAO,KAChE,MAAMH,EAAU,IAAI02B,EAAar1B,KAAMs1B,IACjC,MACJxzB,EAAK,KACLD,EAAI,WACJ0zB,GACE52B,EAAQ62B,WAAW12B,GACjBkI,EApGZ,SAAuBnF,EAAMC,GAC3B,OAAQD,GACN,KAAKqC,EAAWnH,KAAKC,MACnB,OAAO,IAAIuO,EAAM1J,EAAMC,GAEzB,KAAKoC,EAAWnH,KAAKG,aACrB,KAAKgH,EAAWnH,KAAKI,cACnB,OAAO,IAAI22B,EAAWjyB,EAAMC,GAE9B,KAAKoC,EAAWnH,KAAKO,SACrB,KAAK4G,EAAWnH,KAAKQ,SACnB,OAAO,IAAIq3B,EAAe/yB,EAAMC,GAElC,KAAKoC,EAAWnH,KAAKU,QACrB,KAAKyG,EAAWnH,KAAKW,UACrB,KAAKwG,EAAWnH,KAAKgB,SACnB,OAAO,IAAI0zB,EAAe5vB,EAAMC,GAElC,KAAKoC,EAAWnH,KAAKJ,QACrB,KAAKuH,EAAWnH,KAAKY,MACnB,OAAO,IAAIuG,EAAWA,WAAWrC,EAAMC,GAEzC,KAAKoC,EAAWnH,KAAKa,aACnB,OAAO,IAAIo3B,EAAYnzB,EAAMC,GAE/B,KAAKoC,EAAWnH,KAAKc,aACnB,OAAO,IAAIu3B,EAAYvzB,EAAMC,GAI/B,QACE,OAAO,MAqEM2zB,CAAc5zB,EAAMC,GACjC,IAAI3D,EAAS6I,EAAK2iB,MAAMhrB,EAAS42B,GAajC,GAZAvuB,EAAKhF,MAAQ,IAAIkC,EAAWpE,MAAMhB,EAAOX,GAGrCA,GAAUW,IAGZkI,EAAKrF,MAAQ,IAAI8B,MAAM,qCACvBuD,EAAKrF,MAAM+zB,SAAWv3B,EACtB6I,EAAKrF,MAAM+B,OAASsD,EACpBA,EAAKhF,MAAM9C,IAAMJ,EAAQ,GAGvBH,EAAQg3B,qBAAqB3uB,GAAO,CACjCA,EAAKrF,OAAUhD,EAAQwU,aAAexU,EAAQ6S,OAAO3P,OAASqC,EAAWnH,KAAKM,WACjF2J,EAAKrF,MAAQ,IAAIuC,EAAWa,gBAAgBiC,EAAM,0FAGpD,MAAM2I,EAAa,IAAI9I,EAAWG,GAGlC,OAFA7I,EAASwR,EAAWga,MAAM,IAAI0L,EAAa12B,GAAUR,GACrDwR,EAAW3N,MAAQ,IAAIkC,EAAWpE,MAAMhB,EAAOX,GACxCwR,EAGT,OAAO3I,IAGThH,KAAKmT,YAA6B,MAAfA,EAAsBA,EAAcpT,EAAKoT,cAAe,EAC3EnT,KAAK+xB,aAA+B,MAAhBA,EAAuBA,EAAehyB,EAAKgyB,eAAgB,EAC/E/xB,KAAKmE,OAAmB,MAAVA,EAAiBA,EAASpE,EAAKoE,SAAU,EACvDnE,KAAKkB,OAAmB,MAAVA,EAAiBA,EAASnB,EAAKmB,OAC7ClB,KAAKmB,UAAyB,MAAbA,EAAoBA,EAAYpB,EAAKoB,UACtDnB,KAAKwR,OAAmB,MAAVA,EAAiBA,EAASzR,EAAKyR,QAAU,GACvDxR,KAAK4C,KAAO7C,EAAK6C,KACjB5C,KAAK/B,IAAM8B,EAAK9B,IAGlB,qBAAqB+I,GACnB,MAAM,aACJ+qB,EAAY,OACZ5tB,EAAM,IACNlG,GACE+B,KACJ,GAAI+xB,GAAgB5tB,EAAQ,OAAO,EACnC,GAAI6C,aAAgByqB,EAAgB,OAAO,EAE3C,IAAItzB,EAAS6I,EAAKhF,MAAM9C,IACxB,MAAoB,OAAhBjB,EAAIE,IAAwC,OAApBF,EAAIE,EAAS,KACzCA,EAAS+F,EAAW7D,KAAKG,gBAAgBvC,EAAKE,GACvB,MAAhBF,EAAIE,IAKb,WAAWA,GACT,MAAM,OACJgG,EAAM,OACNqN,EAAM,IACNvT,GACE+B,KACE8B,EAAQ,GACd,IAAI8zB,GAAe,EAEf70B,EAAK9C,EADTE,EAAS6B,KAAKmT,YAAcjP,EAAW7D,KAAKgB,YAAYpD,EAAKE,GAAU+F,EAAW7D,KAAKG,gBAAgBvC,EAAKE,IAG5G,KAAO4C,IAAOmD,EAAWzH,KAAKC,QAAUqE,IAAOmD,EAAWzH,KAAKE,SAAWoE,IAAOmD,EAAWzH,KAAKG,KAAc,OAAPmE,GAAa,CACnH,GAAW,OAAPA,EAAa,CACf,MAAMI,EAAYhD,EAAS,EACrBiD,EAAQ8C,EAAW7D,KAAKgB,YAAYpD,EAAKkD,GACzCK,EAAaJ,GAASD,EAAYnB,KAAKkB,QACvC20B,EAAsBrkB,EAAO3P,OAASqC,EAAWnH,KAAKgB,UAAYyT,EAAO7S,QAAQwU,YACvF,IAAKjP,EAAW7D,KAAKyxB,mBAAmB7zB,EAAImD,GAAQI,GAAaq0B,GAAsB,MACvF71B,KAAKmT,aAAc,EACnBnT,KAAKmB,UAAYA,EACjBy0B,GAAe,EACfz3B,EAASiD,OACJ,GAAIL,IAAOmD,EAAWzH,KAAKE,QAAS,CACzC,MAAMuC,EAAMgF,EAAW7D,KAAK8C,UAAUlF,EAAKE,EAAS,GACpD2D,EAAMzD,KAAK,IAAI6F,EAAWpE,MAAM3B,EAAQe,IACxCf,EAASe,MACJ,CACL,IAAIA,EAAMgF,EAAW7D,KAAKuzB,gBAAgB31B,EAAKE,EAAS,GAEpD4C,IAAOmD,EAAWzH,KAAKG,KAAoB,MAAbqB,EAAIiB,IAAgB,yDAAyDuO,KAAKxP,EAAImB,MAAMjB,EAAS,EAAGe,EAAM,OAK9IA,EAAMgF,EAAW7D,KAAKuzB,gBAAgB31B,EAAKiB,EAAM,IAGnD4C,EAAMzD,KAAK,IAAI6F,EAAWpE,MAAM3B,EAAQe,IACxC02B,GAAe,EACfz3B,EAAS+F,EAAW7D,KAAKG,gBAAgBvC,EAAKiB,GAGhD6B,EAAK9C,EAAIE,GAIPy3B,GAAuB,MAAP70B,GAAcmD,EAAW7D,KAAKsC,QAAQ1E,EAAKE,EAAS,GAAG,KAAOA,GAAU,GAE5F,MAAO,CACL2D,QACAD,KAHWwzB,EAAaS,UAAU73B,EAAKE,EAAQgG,GAI/CoxB,WAAYp3B,IAwDlB7D,EAAQqvB,MA1CR,SAAe1rB,GACb,MAAMgC,EAAK,IAEgB,IAAvBhC,EAAIG,QAAQ,QACdH,EAAMA,EAAIuH,QAAQ,SAAU,CAACtC,EAAO/E,KAC9B+E,EAAMrE,OAAS,GAAGoB,EAAG5B,KAAKF,GACvB,QAIX,MAAM43B,EAAY,GAClB,IAAI53B,EAAS,EAEb,EAAG,CACD,MAAM+L,EAAM,IAAI4mB,EACVnyB,EAAU,IAAI02B,EAAa,CAC/Bp3B,QAEFE,EAAS+L,EAAIyf,MAAMhrB,EAASR,GAC5B43B,EAAU13B,KAAK6L,SACR/L,EAASF,EAAIY,QAmBtB,OAjBAk3B,EAAU/D,cAAgB,KACxB,GAAkB,IAAd/xB,EAAGpB,OAAc,OAAO,EAE5B,IAAK,IAAIrE,EAAI,EAAGA,EAAIyF,EAAGpB,SAAUrE,EAAGyF,EAAGzF,IAAMA,EAE7C,IAAIw7B,EAAW,EAEf,IAAK,IAAIx7B,EAAI,EAAGA,EAAIu7B,EAAUl3B,SAAUrE,EACtCw7B,EAAWD,EAAUv7B,GAAGw3B,cAAc/xB,EAAI+1B,GAI5C,OADA/1B,EAAGqJ,OAAO,EAAGrJ,EAAGpB,SACT,GAGTk3B,EAAUtsB,SAAW,IAAMssB,EAAUtzB,KAAK,SAEnCszB,I,6BC7sDT,IAAI7xB,EAAa,EAAQ,GACrBgQ,EAAa,EAAQ,GACrBwH,EAAS,EAAQ,GAErB,MAeM4V,EAAgB,CACpB,aACE,OAAOpd,EAAWrH,eAGpB,WAAWopB,GACT/6B,OAAOsN,OAAO0L,EAAWrH,cAAeopB,IAG1C,WACE,OAAO/hB,EAAWzB,aAGpB,SAASwjB,GACP/6B,OAAOsN,OAAO0L,EAAWzB,YAAawjB,IAGxC,UACE,OAAO/hB,EAAWtB,YAGpB,QAAQqjB,GACN/6B,OAAOsN,OAAO0L,EAAWtB,WAAYqjB,IAGvC,WACE,OAAO/hB,EAAWpB,aAGpB,SAASmjB,GACP/6B,OAAOsN,OAAO0L,EAAWpB,YAAamjB,IAGxC,UACE,OAAO/hB,EAAWlH,YAGpB,QAAQipB,GACN/6B,OAAOsN,OAAO0L,EAAWlH,WAAYipB,KAInCC,EAAkB,CACtB,MAAO,CACL7vB,OAAQ,WACRwN,OAAO,EACP1D,YAAa,CAAC,CACZnN,OAAQ,IACRkN,OAAQhM,EAAWkB,kBAClB,CACDpC,OAAQ,KACRkN,OAAQ,gCAGZ,IAAO,CACL7J,OAAQ,WACRwN,OAAO,EACP1D,YAAa,CAAC,CACZnN,OAAQ,IACRkN,OAAQ,KACP,CACDlN,OAAQ,KACRkN,OAAQhM,EAAWkB,oBAGvB,IAAO,CACLiB,OAAQ,OACRwN,OAAO,EACP1D,YAAa,CAAC,CACZnN,OAAQ,IACRkN,OAAQ,KACP,CACDlN,OAAQ,KACRkN,OAAQhM,EAAWkB,qBAKzB,SAAS+wB,EAAajsB,EAAKrH,GACzB,GAA6C,SAAxCqH,EAAIoG,SAAWpG,EAAIS,QAAQ2F,SAAoB,CAClD,MAAM8lB,EAAOvzB,EAAIK,MAAM,0CACvB,GAAIkzB,EAAM,MAAO,IAAMA,EAAK,GAC5B,MAAM5lB,EAAQ3N,EAAIK,MAAM,6CACxB,OAAOsN,EAAQ,IAAIA,EAAM,MAAMA,EAAM,KAAO,IAAI3N,EAAI2C,QAAQ,QAAS,IAGvE,IAAIlJ,EAAI4N,EAAIiG,YAAYrE,KAAKxP,GAA+B,IAA1BuG,EAAIzE,QAAQ9B,EAAE4T,SAEhD,IAAK5T,EAAG,CACN,MAAM8T,EAAMlG,EAAImG,cAAcF,YAC9B7T,EAAI8T,GAAOA,EAAItE,KAAKxP,GAA+B,IAA1BuG,EAAIzE,QAAQ9B,EAAE4T,SAGzC,IAAK5T,EAAG,MAAkB,MAAXuG,EAAI,GAAaA,EAAM,KAAKA,KAC3C,MAAMI,EAASJ,EAAIvD,OAAOhD,EAAE4T,OAAOrR,QAAQ2G,QAAQ,aAAczE,IAAM,CACrE,IAAK,MACL,IAAK,MACL,IAAK,MACL,IAAK,MACL,IAAK,MACL,IAAK,OACJA,KACH,OAAOzE,EAAE0G,OAASC,EAqDpB,SAASoF,EAAUQ,EAAM7E,EAAKkE,EAAWC,GACvC,MAAM,QACJrC,EAAO,OACPO,GACErC,EAAIkG,IACR,IAAIgR,EAEJ,KAAMrS,aAAgBqL,EAAW7T,MAAO,CACtC,MAAMg2B,EAAY,CAChB9a,WAAY,GACZP,SAAU/f,GAAKigB,EAASjgB,EACxBggB,YAAa,IAAInR,KAEnBjB,EAAOxC,EAAOI,WAAWoC,GAAM,EAAM,KAAMwtB,GAE3C,IAAK,MAAM/a,KAAS+a,EAAU9a,WAAY,CACxCD,EAAM5X,OAAS4X,EAAM5X,OAAOsD,KAC5B,IAAIjM,EAAO+K,EAAQoF,QAAQoQ,EAAM5X,QAE5B3I,IACHA,EAAO+K,EAAQkG,UACflG,EAAQH,IAAI5K,GAAQugB,EAAM5X,SAKhC,GAAImF,aAAgBqL,EAAWvK,KAAM,OAAOd,EAAKY,SAASzF,EAAKkE,EAAWC,GACrE+S,IAAQA,EA7Ef,SAAsB5N,EAAMzE,GAC1B,GAAIA,aAAgBqL,EAAW3I,MAAO,OAAO2I,EAAW3I,MAExD,GAAI1C,EAAKhG,IAAK,CACZ,MAAMK,EAAQoK,EAAK6N,OAAOzf,GAAKA,EAAEmH,MAAQgG,EAAKhG,KAC9C,GAAIK,EAAMrE,OAAS,EAAG,OAAOqE,EAAM4I,KAAKpQ,GAAKA,EAAE8R,SAAW3E,EAAK2E,SAAWtK,EAAM,GAGlF,IAAIgY,EAAQhW,EAEZ,GAAI2D,aAAgBqL,EAAW/N,OAAQ,CACrCjB,EAAM2D,EAAKpN,MAEX,MAAMyH,EAAQoK,EAAK6N,OAAOzf,GAAKA,EAAE6b,UAAY7b,EAAE6b,SAASrS,IAAQxJ,EAAE0f,OAASlW,aAAexJ,EAAE0f,OAC5FF,EAAShY,EAAM4I,KAAKpQ,GAAKA,EAAE8R,SAAW3E,EAAK2E,SAAWtK,EAAM4I,KAAKpQ,IAAMA,EAAE8R,aAEzEtI,EAAM2D,EACNqS,EAAS5N,EAAKxB,KAAKpQ,GAAKA,EAAE0b,WAAalS,aAAexJ,EAAE0b,WAG1D,IAAK8D,EAAQ,CACX,MAAMngB,EAAOmK,GAAOA,EAAI4hB,YAAc5hB,EAAI4hB,YAAY/rB,YAAcmK,EACpE,MAAM,IAAIzB,MAAM,wBAAwB1I,WAG1C,OAAOmgB,EAoDeob,CAAajwB,EAAOiH,KAAMzE,IAChD,MAAM/G,EAjDR,SAAwBkF,EAAMkU,GAAQ,QACpCpV,EAAO,IACPoE,IAEA,MAAMpI,EAAQ,GACRO,EAAS6H,EAAIpE,QAAQoF,QAAQlE,GAanC,OAXI3E,IACFyD,EAAQzD,GAAU2E,EAClBlF,EAAMzD,KAAK,IAAIgE,IAGb2E,EAAKnE,IACPf,EAAMzD,KAAK83B,EAAajsB,EAAKlD,EAAKnE,MACxBqY,EAAO/D,SACjBrV,EAAMzD,KAAK83B,EAAajsB,EAAKgR,EAAOrY,MAG/Bf,EAAMW,KAAK,KA+BJ8zB,CAAe1tB,EAAMqS,EAAQlX,GACvClC,EAAMjD,OAAS,IAAGmF,EAAIiH,eAAiBjH,EAAIiH,eAAiB,GAAKnJ,EAAMjD,OAAS,GACpF,MAAMyB,EAAkC,mBAArB4a,EAAO7S,UAA2B6S,EAAO7S,UAAUQ,EAAM7E,EAAKkE,EAAWC,GAAeU,aAAgBqL,EAAW/N,OAAS+N,EAAWW,gBAAgBhM,EAAM7E,EAAKkE,EAAWC,GAAeU,EAAKY,SAASzF,EAAKkE,EAAWC,GAC7O,OAAKrG,EACE+G,aAAgBqL,EAAW/N,QAAqB,MAAX7F,EAAI,IAAyB,MAAXA,EAAI,GAAa,GAAGwB,KAASxB,IAAQ,GAAGwB,MAAUkC,EAAI9C,SAASZ,IAD1GA,EAIrB,MAAMk2B,EACJ,uBAAuBxvB,GACrB,OAAOA,aAAgBkN,EAAW/N,QAAUa,aAAgBkN,EAAW7K,SAAWrC,aAAgBkN,EAAW5H,QAG/G,YAAY4D,GACVhM,EAAWe,gBAAgBjF,KAAM,MAAO,IAExCA,KAAKkQ,OAASA,EAGhB,YAAYlJ,EAAMjM,GAEhB,OADAiF,KAAKy2B,UAAUzvB,EAAMjM,GACd,IAAImZ,EAAW3I,MAAMvE,GAG9B,mBAAmB8M,GACjB,MAAMD,EAAQ,IAAIK,EAAWvH,MAU7B,OATAkH,EAAMpY,MAAM+L,MAAQsM,EAAQnO,IAAIpJ,IAC9B,GAAIA,aAAa2X,EAAW3I,OAC1B,GAAIhP,EAAEmH,kBAAkBwQ,EAAW5H,QAAS,OAAO/P,OAC9C,GAAIA,aAAa2X,EAAW5H,QACjC,OAAOtM,KAAK02B,YAAYn6B,GAG1B,MAAM,IAAIkH,MAAM,sDAEXoQ,EAGT,QAAQ7M,GACN,MAAM,IACJrB,GACE3F,KACJ,OAAO9E,OAAO2Q,KAAKlG,GAAKmG,KAAKC,GAAKpG,EAAIoG,KAAO/E,GAG/C,WACE,OAAO9L,OAAO2Q,KAAK7L,KAAK2F,KAG1B,QAAQ5K,GACN,OAAOiF,KAAK2F,IAAI5K,GAGlB,QAAQmV,GACDA,IAAQA,EAASlQ,KAAKkQ,QAC3B,MAAMymB,EAAQz7B,OAAO2Q,KAAK7L,KAAK2F,KAE/B,IAAK,IAAInL,EAAI,KAAWA,EAAG,CACzB,MAAMO,EAAO,GAAGmV,IAAS1V,IACzB,IAAKm8B,EAAM5tB,SAAShO,GAAO,OAAOA,GAKtC,eACE,MAAM,IACJ4K,EAAG,YACHmM,GACE9R,KACJ9E,OAAO2Q,KAAKlG,GAAKrC,QAAQyI,IACvBpG,EAAIoG,GAAKpG,EAAIoG,GAAGoG,WAGlBL,EAAYxO,QAAQyI,IAClBA,EAAErI,OAASqI,EAAErI,OAAOyO,kBAGfnS,KAAK8R,YAGd,UAAU9K,EAAMjM,GACd,GAAY,MAARiM,IAAiBwvB,EAAQI,gBAAgB5vB,GAC3C,MAAM,IAAIvD,MAAM,yDAGlB,GAAI1I,GAAQ,sBAAsB0S,KAAK1S,GACrC,MAAM,IAAI0I,MAAM,kEAGlB,MAAM,IACJkC,GACE3F,KACEW,EAAOqG,GAAQ9L,OAAO2Q,KAAKlG,GAAKmG,KAAKC,GAAKpG,EAAIoG,KAAO/E,GAE3D,GAAIrG,EAAM,CACR,IAAK5F,EACH,OAAO4F,EACEA,IAAS5F,WACX4K,EAAIhF,GACXgF,EAAI5K,GAAQiM,OAET,CACL,IAAKjM,EAAM,CACT,IAAKiM,EAAM,OAAO,KAClBjM,EAAOiF,KAAKgM,UAGdrG,EAAI5K,GAAQiM,EAGd,OAAOjM,GAKX,MAAM87B,EAAQ,CAAC7vB,EAAMsG,KACnB,GAAItG,GAAwB,iBAATA,EAAmB,CACpC,MAAM,IACJnE,GACEmE,EAEAA,aAAgBkN,EAAWrN,YACzBhE,IAAKyK,EAAKzK,IAAO,GACrBmE,EAAKQ,MAAMlE,QAAQrH,GAAK46B,EAAM56B,EAAGqR,KACxBtG,aAAgBkN,EAAWvK,MACpCktB,EAAM7vB,EAAKjL,IAAKuR,GAChBupB,EAAM7vB,EAAKvL,MAAO6R,IACTtG,aAAgBkN,EAAW/N,QAChCtD,IAAKyK,EAAKzK,IAAO,GAIzB,OAAOyK,GA2DT,SAASwpB,GAAoB,YAC3B3mB,GACCqjB,GACD,MAAOxwB,EAAQkN,GAAUsjB,EAAUuD,WAEnC,IAAK/zB,IAAWkN,EAAQ,CACtB,MAAMjE,EAAM,mDACZ,MAAM,IAAI/H,EAAWD,kBAAkBuvB,EAAWvnB,GAGpD,GAAIkE,EAAY4D,KAAKzX,GAAKA,EAAE0G,SAAWA,GAAS,CAC9C,MAAMiJ,EAAM,sFACZ,MAAM,IAAI/H,EAAWD,kBAAkBuvB,EAAWvnB,GAGpD,MAAO,CACLjJ,SACAkN,UAIJ,SAAS8mB,EAAqB9sB,EAAKspB,GACjC,IAAKljB,GAAWkjB,EAAUuD,WAG1B,GAFuB,aAAnBvD,EAAUz4B,OAAqBuV,EAAU,QAExCA,EAAS,CACZ,MAAMrE,EAAM,oDACZ,MAAM,IAAI/H,EAAWD,kBAAkBuvB,EAAWvnB,GAGpD,IAAKiqB,EAAgB5lB,GAAU,CAC7B,MACMrE,EAAM,mCADD/B,EAAIoG,SAAWpG,EAAIS,QAAQ2F,4BACgCA,IACtEpG,EAAIqG,SAASlS,KAAK,IAAI6F,EAAWc,YAAYwuB,EAAWvnB,IAG1D,OAAOqE,EAmET,SAAS2mB,EAAiB1F,GACxB,GAAIA,aAAoBrd,EAAWrN,WAAY,OAAO,EACtD,MAAM,IAAIpD,MAAM,mDAGlB,MAAMqtB,EACJ,YAAYnmB,GACV3K,KAAK8F,QAAU,IAAI0wB,EAAQ7rB,EAAQusB,cACnCl3B,KAAK0H,cAAgB,KACrB1H,KAAKwC,QAAU,KACfxC,KAAKuxB,SAAW,KAChBvxB,KAAKozB,oBAAsB,KAC3BpzB,KAAKsE,OAAS,GACdtE,KAAK2K,QAAUA,EACf3K,KAAKqG,OAAS,KACdrG,KAAKmQ,YAAc,GACnBnQ,KAAKsQ,QAAU,KACftQ,KAAKuQ,SAAW,GAGlB,IAAI9U,GAEF,OADAw7B,EAAiBj3B,KAAKuxB,UACfvxB,KAAKuxB,SAASzqB,IAAIrL,GAG3B,MAAM6K,EAAM7K,GACVw7B,EAAiBj3B,KAAKuxB,UACtBvxB,KAAKuxB,SAAStqB,MAAMX,EAAM7K,GAG5B,OAAOM,GAEL,OADAk7B,EAAiBj3B,KAAKuxB,UACfvxB,KAAKuxB,SAASnqB,OAAOrL,GAG9B,SAASuK,GACP,OAAI4N,EAAWxN,YAAYJ,GACJ,MAAjBtG,KAAKuxB,WACTvxB,KAAKuxB,SAAW,MACT,IAGT0F,EAAiBj3B,KAAKuxB,UACfvxB,KAAKuxB,SAASlqB,SAASf,IAGhC,cACE,OAAOwqB,EAASI,SAASlxB,KAAKsQ,UAAYwgB,EAASI,SAASlxB,KAAK2K,QAAQ2F,UAAY,GAGvF,IAAIvU,EAAKuL,GACP,OAAOtH,KAAKuxB,oBAAoBrd,EAAWrN,WAAa7G,KAAKuxB,SAASl2B,IAAIU,EAAKuL,QAAcJ,EAG/F,MAAMZ,EAAMgB,GACV,OAAI4M,EAAWxN,YAAYJ,IAAegB,GAActH,KAAKuxB,oBAAoBrd,EAAW/N,OAASnG,KAAKuxB,SAAS91B,MAAQuE,KAAKuxB,SACzHvxB,KAAKuxB,oBAAoBrd,EAAWrN,WAAa7G,KAAKuxB,SAAShqB,MAAMjB,EAAMgB,QAAcJ,EAGlG,IAAInL,GACF,OAAOiE,KAAKuxB,oBAAoBrd,EAAWrN,YAAa7G,KAAKuxB,SAAS5pB,IAAI5L,GAG5E,MAAMuK,GACJ,OAAI4N,EAAWxN,YAAYJ,QAAgCY,IAAlBlH,KAAKuxB,SACvCvxB,KAAKuxB,oBAAoBrd,EAAWrN,YAAa7G,KAAKuxB,SAAS3pB,MAAMtB,GAG9E,IAAIvK,EAAKN,GACPw7B,EAAiBj3B,KAAKuxB,UACtBvxB,KAAKuxB,SAASpqB,IAAIpL,EAAKN,GAGzB,MAAM6K,EAAM7K,GACNyY,EAAWxN,YAAYJ,GAAOtG,KAAKuxB,SAAW91B,GAChDw7B,EAAiBj3B,KAAKuxB,UACtBvxB,KAAKuxB,SAAS1pB,MAAMvB,EAAM7K,IAI9B,UAAU4jB,EAAI1D,GACZ,IAAK0D,IAAO1D,GAAc3b,KAAKqG,OAAQ,OACrB,iBAAPgZ,IAAiBA,EAAKA,EAAG8X,QAAQ,IAEjC,QAAP9X,GAAuB,QAAPA,GAAuB,QAAPA,GAC9Brf,KAAKsQ,QAAStQ,KAAKsQ,QAAU+O,EAAQrf,KAAK2K,QAAQ2F,QAAU+O,SACzDrf,KAAK2K,QAAQtE,QACXgZ,GAAoB,iBAAPA,IACtBrf,KAAK2K,QAAQtE,OAASgZ,GAGpB5gB,MAAMC,QAAQid,KAAa3b,KAAK2K,QAAQgR,WAAaA,GACzD,MAAMsa,EAAM/6B,OAAOsN,OAAO,GAAIxI,KAAKqQ,cAAerQ,KAAK2K,SACvD3K,KAAKqG,OAAS,IAAIqV,EAAOA,OAAOua,GAGlC,MAAMjvB,EAAMowB,GACNp3B,KAAK2K,QAAQqH,eAAchS,KAAKmM,QAAUnF,GAC1ChH,KAAK2K,QAAQsH,gBAAejS,KAAK6B,KAAO,YAC5C,MAAM,WACJsxB,EAAa,GAAE,SACf5B,EAAW,GAAE,oBACb6B,EAAmB,MACnBzxB,EAAK,WACLM,GACE+E,EAeJ,GAbIrF,IACGA,EAAM+B,SAAQ/B,EAAM+B,OAAS1D,MAClCA,KAAKsE,OAAOjG,KAAKsD,IA7KvB,SAAyBuI,EAAKipB,EAAYiE,GACxC,MAAMC,EAAoB,GAC1B,IAAI/D,GAAgB,EAEpB,IAAK,MAAME,KAAaL,EAAY,CAClC,MAAM,QACJ3wB,EAAO,KACPzH,GACEy4B,EAEJ,OAAQz4B,GACN,IAAK,MACH,IACEmP,EAAIiG,YAAY9R,KAAKy4B,EAAoB5sB,EAAKspB,IAC9C,MAAO7xB,GACPuI,EAAI5F,OAAOjG,KAAKsD,GAGlB2xB,GAAgB,EAChB,MAEF,IAAK,OACL,IAAK,WACH,GAAIppB,EAAIoG,QAAS,CACf,MAAMrE,EAAM,oEACZ/B,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWD,kBAAkBuvB,EAAWvnB,IAG9D,IACE/B,EAAIoG,QAAU0mB,EAAqB9sB,EAAKspB,GACxC,MAAO7xB,GACPuI,EAAI5F,OAAOjG,KAAKsD,GAGlB2xB,GAAgB,EAChB,MAEF,QACE,GAAIv4B,EAAM,CACR,MAAMkR,EAAM,0DAA0DlR,EACtEmP,EAAIqG,SAASlS,KAAK,IAAI6F,EAAWc,YAAYwuB,EAAWvnB,KAK1DzJ,GAAS60B,EAAkBh5B,KAAKmE,GAGtC,GAAI40B,IAAY9D,GAAiB,SAAWppB,EAAIoG,SAAW8mB,EAAQ9mB,SAAWpG,EAAIS,QAAQ2F,SAAU,CAClG,MAAMgnB,EAAgB,EACpBt0B,SACAkN,aACI,CACJlN,SACAkN,WAGFhG,EAAIiG,YAAcinB,EAAQjnB,YAAYxK,IAAI2xB,GAC1CptB,EAAIoG,QAAU8mB,EAAQ9mB,QAGxBpG,EAAIxC,cAAgB2vB,EAAkB50B,KAAK,OAAS,KAmHlDixB,CAAgB1zB,KAAMmzB,EAAYiE,GAC9BhE,IAAqBpzB,KAAKozB,qBAAsB,GACpDpzB,KAAKgC,MAAQC,EAAa,CAACA,EAAWnD,MAAOmD,EAAW/C,KAAO,KAC/Dc,KAAKu3B,YACLv3B,KAAK8F,QAAQgM,YAAc,GAjR/B,SAAuB5H,EAAKqnB,GAC1B,MAAMhvB,EAAW,CACfsN,OAAQ,GACRuB,MAAO,IAET,IAAIlC,OAAOhI,EACP4B,GAAc,EAElB,IAAK,MAAM9B,KAAQuqB,EACjB,GAAIvqB,EAAK/E,WAAY,CACnB,QAAaiF,IAATgI,EAAoB,CACtB,MAAMjD,EAAM,wEACZ/B,EAAI5F,OAAOjG,KAAK,IAAI6F,EAAWa,gBAAgBiC,EAAMiF,IACrD,MAGF,MAAMjG,EAAMkO,EAAWvC,YAAYzH,EAAKlD,GAEpC8B,IACF9C,EAAI8C,aAAc,EAClBA,GAAc,GAGhBoG,EAAOlJ,OACF,GAAqB,OAAjBgB,EAAKxE,QAAkB,OACZ0E,IAATgI,EAAqB3M,EAASsN,OAAStN,EAAS6O,OACxD/S,KAAK2I,EAAKxE,cACJwE,EAAKnF,OAASqC,EAAWnH,KAAKE,aACvC6L,GAAc,OAED5B,IAATgI,GAAsB3M,EAASsN,OAAOhR,OAAS,IAAMqL,EAAIxC,gBAE3DwC,EAAIxC,cAAgBnF,EAASsN,OAAOpN,KAAK,MACzCF,EAASsN,OAAS,KAOxB,GAFA3F,EAAIqnB,SAAWriB,GAAQ,KAElBA,EAEE,CACL,MAAMrF,EAAKtH,EAASsN,OAAOpN,KAAK,MAEhC,GAAIoH,EAAI,CACN,MAAM2tB,EAAStoB,aAAgBgF,EAAWrN,YAAcqI,EAAK1H,MAAM,GAAK0H,EAAK1H,MAAM,GAAK0H,EACxFsoB,EAAO9vB,cAAgB8vB,EAAO9vB,cAAgB,GAAGmC,MAAO2tB,EAAO9vB,gBAAkBmC,EAGnFK,EAAI1H,QAAUD,EAAS6O,MAAM3O,KAAK,OAAS,UAT3CyH,EAAI1H,QAAUD,EAASsN,OAAO4B,OAAOlP,EAAS6O,OAAO3O,KAAK,OAAS,KAyOnEkxB,CAAc3zB,KAAMuxB,GACpBvxB,KAAK8F,QAAQ2xB,eAETz3B,KAAK2K,QAAQ8lB,aAAc,CAC7B,IAAK,MAAM9uB,KAAS3B,KAAKsE,OAAY3C,aAAiBuC,EAAWV,WAAW7B,EAAM+1B,aAElF,IAAK,MAAMzjB,KAAQjU,KAAKuQ,SAAc0D,aAAgB/P,EAAWV,WAAWyQ,EAAKyjB,aAGnF,OAAO13B,KAGT,qBACE,OAjSiBgH,EAiSGhH,KAAKuxB,SAjSAr2B,OAAO2Q,KAAKgrB,EAAM7vB,EAAM,MAiSdmU,OAAOzf,GAAgD,IAA3CA,EAAE0C,QAAQsd,EAAOA,OAAOX,gBAjStD/T,MAoSnB,aAAahE,EAAQkN,GACnB,GAAkB,MAAdlN,EAAO,IAA4C,MAA9BA,EAAOA,EAAOnE,OAAS,GAAY,MAAM,IAAI4E,MAAM,oCAE5E,GAAIyM,EAAQ,CACV,MAAMvP,EAAOX,KAAKmQ,YAAYrE,KAAKxP,GAAKA,EAAE0G,SAAWA,GACjDrC,EAAMA,EAAKuP,OAASA,EAAYlQ,KAAKmQ,YAAY9R,KAAK,CACxD2E,SACAkN,gBAGFlQ,KAAKmQ,YAAcnQ,KAAKmQ,YAAYgL,OAAO7e,GAAKA,EAAE0G,SAAWA,GAIjE,OAAO0C,EAAKiyB,GACV,MAAM,gBACJC,EAAe,SACfttB,EAAQ,cACR4B,GACElM,KAAK2K,QACH1E,EAAO2xB,IAAmC,iBAARlyB,KAAsB1F,KAAKuxB,oBAAoBrd,EAAW/N,SAC5FnC,EAAM,CACVkG,IAAKlK,KACLoI,WAAY,KACZnC,OACAqE,SAAUrE,KAAUqE,EACpB4B,gBACA7D,aAGIwvB,EAAc38B,OAAO2Q,KAAK7L,KAAK8F,QAAQH,KACzCkyB,EAAYh5B,OAAS,IAAGmF,EAAI8B,QAAU,IAAIgE,IAAI+tB,EAAYlyB,IAAI5K,GAAQ,CAACiF,KAAK8F,QAAQH,IAAI5K,GAAO,CACjGugB,MAAO,GACP7P,WAAY,EACZD,MAAO,OAET,MAAMxF,EAAMkO,EAAWzO,OAAOzF,KAAKuxB,SAAU7rB,EAAK1B,GAClD,GAAwB,mBAAb2zB,GAA2B3zB,EAAI8B,QAAS,IAAK,MAAM,MAC5D0F,EAAK,IACLxF,KACGhC,EAAI8B,QAAQ0lB,SAAUmM,EAAS3xB,EAAKwF,GACzC,OAAOxF,EAGT,WACE,GAAIhG,KAAKsE,OAAOzF,OAAS,EAAG,MAAM,IAAI4E,MAAM,8CAC5C,MAAM+G,EAAaxK,KAAK2K,QAAQzJ,OAEhC,IAAKgF,OAAOM,UAAUgE,IAAeA,GAAc,EAAG,CACpD,MAAMjO,EAAImN,KAAKrB,UAAUmC,GACzB,MAAM,IAAI/G,MAAM,mDAAmDlH,GAGrEyD,KAAKu3B,YACL,MAAM5a,EAAQ,GACd,IAAI2W,GAAgB,EAEpB,GAAItzB,KAAKsQ,QAAS,CAChB,IAAIwnB,EAAK,YAEgB,aAArB93B,KAAKqG,OAAOtL,OACO,QAAjBiF,KAAKsQ,QAAmBwnB,EAAK,YAAsC,QAAjB93B,KAAKsQ,UAAmBwnB,EAAK,cAGrFnb,EAAMte,KAAKy5B,GACXxE,GAAgB,EAGlB,MAAMyE,EAAW/3B,KAAKg4B,qBACtBh4B,KAAKmQ,YAAY7M,QAAQ,EACvBN,SACAkN,aAEI6nB,EAAShkB,KAAKrY,GAA2B,IAAtBA,EAAE0C,QAAQ8R,MAC/ByM,EAAMte,KAAK,QAAQ2E,KAAUkN,KAC7BojB,GAAgB,MAGhBA,GAAiBtzB,KAAKozB,sBAAqBzW,EAAMte,KAAK,OAEtD2B,KAAK0H,iBACH4rB,GAAkBtzB,KAAKozB,qBAAqBzW,EAAMY,QAAQ,IAC9DZ,EAAMY,QAAQvd,KAAK0H,cAAclC,QAAQ,MAAO,OAGlD,MAAMxB,EAAM,CACV8B,QAAS,GACToE,IAAKlK,KACLkB,OAAQ,GACRkH,WAAY,IAAIvI,OAAO2K,GACvBnC,aAGF,IAAII,GAAY,EACZwvB,EAAiB,KAErB,GAAIj4B,KAAKuxB,SAAU,CACbvxB,KAAKuxB,oBAAoBrd,EAAW7T,OAClCL,KAAKuxB,SAASzoB,cAAgBwqB,GAAiBtzB,KAAKozB,sBAAsBzW,EAAMte,KAAK,IACrF2B,KAAKuxB,SAAS7pB,eAAeiV,EAAMte,KAAK2B,KAAKuxB,SAAS7pB,cAAclC,QAAQ,MAAO,MAEvFxB,EAAI6K,mBAAqB7O,KAAKwC,QAC9By1B,EAAiBj4B,KAAKuxB,SAAS/uB,SAGjC,MAAM2F,EAAc8vB,EAAiB,KAAO,IAAMxvB,GAAY,EACxDyG,EAAO7G,EAAUrI,KAAKuxB,SAAUvtB,EAAK,IAAMi0B,EAAiB,KAAM9vB,GACxEwU,EAAMte,KAAK6V,EAAW3O,WAAW2J,EAAM,GAAI+oB,cAChB/wB,IAAlBlH,KAAKuxB,UACd5U,EAAMte,KAAKgK,EAAUrI,KAAKuxB,SAAUvtB,IAQtC,OALIhE,KAAKwC,UACDiG,IAAawvB,GAA+C,KAA5Btb,EAAMA,EAAM9d,OAAS,IAAW8d,EAAMte,KAAK,IACjFse,EAAMte,KAAK2B,KAAKwC,QAAQgD,QAAQ,MAAO,OAGlCmX,EAAMla,KAAK,MAAQ,MAK9ByB,EAAWe,gBAAgB6rB,EAAU,WAAYoF,GAEjD57B,EAAQw2B,SAAWA,EACnBx2B,EAAQy2B,eA7uBe,CACrBmG,aAAc,IACdvb,WAAY,KACZza,OAAQ,EACRuJ,WAAW,EACXuH,cAAc,EACdC,eAAe,EACf2lB,iBAAiB,EACjBttB,UAAU,EACV4B,cAAe,IACfukB,cAAc,EAEd/lB,YAAY,EACZ4F,QAAS,OAiuBXhW,EAAQg3B,cAAgBA,G,gBCpvBxB,MAAM4G,EAAO,EAAQ,IAErB59B,EAAQ+R,SAAW6rB,EAAK7rB,SACxB/R,EAAQmL,OAASyyB,EAAKzyB,OACtBnL,EAAQ69B,SAAWD,EAAKC,SACxB79B,EAAQ89B,SAAWF,EAAKE,SAExB99B,EAAQma,gBAAkByjB,EAAKzjB,gBAC/Bna,EAAQua,gBAAkBqjB,EAAKrjB,gBAC/Bva,EAAQyC,KAAOm7B,EAAKn7B,KAEpBzC,EAAQkJ,UAAY00B,EAAK10B,UACzBlJ,EAAQwK,mBAAqBozB,EAAKpzB,mBAClCxK,EAAQ2J,kBAAoBi0B,EAAKj0B,kBACjC3J,EAAQyK,gBAAkBmzB,EAAKnzB,gBAC/BzK,EAAQ0K,YAAckzB,EAAKlzB,a,6BCb3B,IAAId,EAAa,EAAQ,GACrBgQ,EAAa,EAAQ,GAIzB5Z,EAAQyC,KAAOmH,EAAWnH,KAC1BzC,EAAQkJ,UAAYU,EAAWV,UAC/BlJ,EAAQwK,mBAAqBZ,EAAWY,mBACxCxK,EAAQ2J,kBAAoBC,EAAWD,kBACvC3J,EAAQyK,gBAAkBb,EAAWa,gBACrCzK,EAAQ0K,YAAcd,EAAWc,YACjC1K,EAAQ+R,SAAW6H,EAAW7H,SAC9B/R,EAAQ69B,SAAWjkB,EAAWlB,WAC9B1Y,EAAQ89B,SAAWlkB,EAAWA,WAC9B5Z,EAAQma,gBAAkBP,EAAWO,gBACrCna,EAAQua,gBAAkBX,EAAWW,gBACrCva,EAAQmL,OAASyO,EAAWzO","file":"extension.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 12);\n","module.exports = require(\"stream\");","module.exports = require(\"zlib\");","'use strict';\n\nconst Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nconst Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nconst defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  const ls = [0];\n  let offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  let lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts,\n    src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (let i = 0; i < lineStarts.length; ++i) {\n    const start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  const line = lineStarts.length;\n  return {\n    line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\nfunction getLine(line, cst) {\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  const start = lineStarts[line - 1];\n  let end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') --end;\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `…` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\nfunction getPrettyContext({\n  start,\n  end\n}, cst, maxWidth = 80) {\n  let src = getLine(start.line, cst);\n  if (!src) return null;\n  let {\n    col\n  } = start;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '…';\n    } else {\n      const halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';\n      col -= src.length - maxWidth;\n      src = '…' + src.substr(1 - maxWidth);\n    }\n  }\n\n  let errLen = 1;\n  let errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '…';\n    }\n  }\n\n  const offset = col > 1 ? ' '.repeat(col - 1) : '';\n  const err = '^'.repeat(errLen);\n  return `${src}\\n${offset}${err}${errEnd}`;\n}\n\nclass Range {\n  static copy(orig) {\n    return new Range(orig.start, orig.end);\n  }\n\n  constructor(start, end) {\n    this.start = start;\n    this.end = end || start;\n  }\n\n  isEmpty() {\n    return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n  }\n  /**\n   * Set `origStart` and `origEnd` to point to the original source range for\n   * this node, which may differ due to dropped CR characters.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRange(cr, offset) {\n    const {\n      start,\n      end\n    } = this;\n\n    if (cr.length === 0 || end <= cr[0]) {\n      this.origStart = start;\n      this.origEnd = end;\n      return offset;\n    }\n\n    let i = offset;\n\n    while (i < cr.length) {\n      if (cr[i] > start) break;else ++i;\n    }\n\n    this.origStart = start + i;\n    const nextOffset = i;\n\n    while (i < cr.length) {\n      // if end was at \\n, it should now be at \\r\n      if (cr[i] >= end) break;else ++i;\n    }\n\n    this.origEnd = end + i;\n    return nextOffset;\n  }\n\n}\n\n/** Root class of all nodes */\n\nclass Node {\n  static addStringTerminator(src, offset, str) {\n    if (str[str.length - 1] === '\\n') return str;\n    const next = Node.endOfWhiteSpace(src, offset);\n    return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n  } // ^(---|...)\n\n\n  static atDocumentBoundary(src, offset, sep) {\n    const ch0 = src[offset];\n    if (!ch0) return true;\n    const prev = src[offset - 1];\n    if (prev && prev !== '\\n') return false;\n\n    if (sep) {\n      if (ch0 !== sep) return false;\n    } else {\n      if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n    }\n\n    const ch1 = src[offset + 1];\n    const ch2 = src[offset + 2];\n    if (ch1 !== ch0 || ch2 !== ch0) return false;\n    const ch3 = src[offset + 3];\n    return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n  }\n\n  static endOfIdentifier(src, offset) {\n    let ch = src[offset];\n    const isVerbatim = ch === '<';\n    const notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n    while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];\n\n    if (isVerbatim && ch === '>') offset += 1;\n    return offset;\n  }\n\n  static endOfIndent(src, offset) {\n    let ch = src[offset];\n\n    while (ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfLine(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfWhiteSpace(src, offset) {\n    let ch = src[offset];\n\n    while (ch === '\\t' || ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static startOfLine(src, offset) {\n    let ch = src[offset - 1];\n    if (ch === '\\n') return offset;\n\n    while (ch && ch !== '\\n') ch = src[offset -= 1];\n\n    return offset + 1;\n  }\n  /**\n   * End of indentation, or null if the line's indent level is not more\n   * than `indent`\n   *\n   * @param {string} src\n   * @param {number} indent\n   * @param {number} lineStart\n   * @returns {?number}\n   */\n\n\n  static endOfBlockIndent(src, indent, lineStart) {\n    const inEnd = Node.endOfIndent(src, lineStart);\n\n    if (inEnd > lineStart + indent) {\n      return inEnd;\n    } else {\n      const wsEnd = Node.endOfWhiteSpace(src, inEnd);\n      const ch = src[wsEnd];\n      if (!ch || ch === '\\n') return wsEnd;\n    }\n\n    return null;\n  }\n\n  static atBlank(src, offset, endAsBlank) {\n    const ch = src[offset];\n    return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n  }\n\n  static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n    if (!ch || indentDiff < 0) return false;\n    if (indentDiff > 0) return true;\n    return indicatorAsIndent && ch === '-';\n  } // should be at line or string end, or at next non-whitespace char\n\n\n  static normalizeOffset(src, offset) {\n    const ch = src[offset];\n    return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n  } // fold single newline into space, multiple newlines to N - 1 newlines\n  // presumes src[offset] === '\\n'\n\n\n  static foldNewline(src, offset, indent) {\n    let inCount = 0;\n    let error = false;\n    let fold = '';\n    let ch = src[offset + 1];\n\n    while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n      switch (ch) {\n        case '\\n':\n          inCount = 0;\n          offset += 1;\n          fold += '\\n';\n          break;\n\n        case '\\t':\n          if (inCount <= indent) error = true;\n          offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n          break;\n\n        case ' ':\n          inCount += 1;\n          offset += 1;\n          break;\n      }\n\n      ch = src[offset + 1];\n    }\n\n    if (!fold) fold = ' ';\n    if (ch && inCount <= indent) error = true;\n    return {\n      fold,\n      offset,\n      error\n    };\n  }\n\n  constructor(type, props, context) {\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  getPropValue(idx, key, skipKey) {\n    if (!this.context) return null;\n    const {\n      src\n    } = this.context;\n    const prop = this.props[idx];\n    return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n  }\n\n  get anchor() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const anchor = this.getPropValue(i, Char.ANCHOR, true);\n      if (anchor != null) return anchor;\n    }\n\n    return null;\n  }\n\n  get comment() {\n    const comments = [];\n\n    for (let i = 0; i < this.props.length; ++i) {\n      const comment = this.getPropValue(i, Char.COMMENT, true);\n      if (comment != null) comments.push(comment);\n    }\n\n    return comments.length > 0 ? comments.join('\\n') : null;\n  }\n\n  commentHasRequiredWhitespace(start) {\n    const {\n      src\n    } = this.context;\n    if (this.header && start === this.header.end) return false;\n    if (!this.valueRange) return false;\n    const {\n      end\n    } = this.valueRange;\n    return start !== end || Node.atBlank(src, end - 1);\n  }\n\n  get hasComment() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] === Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get hasProps() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] !== Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get includesTrailingLines() {\n    return false;\n  }\n\n  get jsonLike() {\n    const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n    return jsonLikeTypes.indexOf(this.type) !== -1;\n  }\n\n  get rangeAsLinePos() {\n    if (!this.range || !this.context) return undefined;\n    const start = getLinePos(this.range.start, this.context.root);\n    if (!start) return undefined;\n    const end = getLinePos(this.range.end, this.context.root);\n    return {\n      start,\n      end\n    };\n  }\n\n  get rawValue() {\n    if (!this.valueRange || !this.context) return null;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    return this.context.src.slice(start, end);\n  }\n\n  get tag() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const tag = this.getPropValue(i, Char.TAG, false);\n\n      if (tag != null) {\n        if (tag[1] === '<') {\n          return {\n            verbatim: tag.slice(2, -1)\n          };\n        } else {\n          // eslint-disable-next-line no-unused-vars\n          const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);\n          return {\n            handle,\n            suffix\n          };\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get valueRangeContainsNewline() {\n    if (!this.valueRange || !this.context) return false;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n\n    for (let i = start; i < end; ++i) {\n      if (src[i] === '\\n') return true;\n    }\n\n    return false;\n  }\n\n  parseComment(start) {\n    const {\n      src\n    } = this.context;\n\n    if (src[start] === Char.COMMENT) {\n      const end = Node.endOfLine(src, start + 1);\n      const commentRange = new Range(start, end);\n      this.props.push(commentRange);\n      return end;\n    }\n\n    return start;\n  }\n  /**\n   * Populates the `origStart` and `origEnd` values of all ranges for this\n   * node. Extended by child classes to handle descendant nodes.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRanges(cr, offset) {\n    if (this.range) offset = this.range.setOrigRange(cr, offset);\n    if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n    this.props.forEach(prop => prop.setOrigRange(cr, offset));\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = src.slice(range.start, range.end);\n    return Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass YAMLError extends Error {\n  constructor(name, source, message) {\n    if (!message || !(source instanceof Node)) throw new Error(`Invalid arguments for new ${name}`);\n    super();\n    this.name = name;\n    this.message = message;\n    this.source = source;\n  }\n\n  makePretty() {\n    if (!this.source) return;\n    this.nodeType = this.source.type;\n    const cst = this.source.context && this.source.context.root;\n\n    if (typeof this.offset === 'number') {\n      this.range = new Range(this.offset, this.offset + 1);\n      const start = cst && getLinePos(this.offset, cst);\n\n      if (start) {\n        const end = {\n          line: start.line,\n          col: start.col + 1\n        };\n        this.linePos = {\n          start,\n          end\n        };\n      }\n\n      delete this.offset;\n    } else {\n      this.range = this.source.range;\n      this.linePos = this.source.rangeAsLinePos;\n    }\n\n    if (this.linePos) {\n      const {\n        line,\n        col\n      } = this.linePos.start;\n      this.message += ` at line ${line}, column ${col}`;\n      const ctx = cst && getPrettyContext(this.linePos, cst);\n      if (ctx) this.message += `:\\n\\n${ctx}\\n`;\n    }\n\n    delete this.source;\n  }\n\n}\nclass YAMLReferenceError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLReferenceError', source, message);\n  }\n\n}\nclass YAMLSemanticError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSemanticError', source, message);\n  }\n\n}\nclass YAMLSyntaxError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSyntaxError', source, message);\n  }\n\n}\nclass YAMLWarning extends YAMLError {\n  constructor(source, message) {\n    super('YAMLWarning', source, message);\n  }\n\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass PlainValue extends Node {\n  static endOfLine(src, start, inFlow) {\n    let ch = src[start];\n    let offset = start;\n\n    while (ch && ch !== '\\n') {\n      if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n      const next = src[offset + 1];\n      if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n      if ((ch === ' ' || ch === '\\t') && next === '#') break;\n      offset += 1;\n      ch = next;\n    }\n\n    return offset;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n    let ch = src[end - 1];\n\n    while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) ch = src[--end - 1];\n\n    let str = '';\n\n    for (let i = start; i < end; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        const {\n          fold,\n          offset\n        } = Node.foldNewline(src, i, -1);\n        str += fold;\n        i = offset;\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (i < end && (next === ' ' || next === '\\t')) {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    const ch0 = src[start];\n\n    switch (ch0) {\n      case '\\t':\n        {\n          const msg = 'Plain value cannot start with a tab character';\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      case '@':\n      case '`':\n        {\n          const msg = `Plain value cannot start with reserved character ${ch0}`;\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      default:\n        return str;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      inFlow,\n      src\n    } = this.context;\n    let offset = start;\n    let valueEnd = start;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      if (Node.atDocumentBoundary(src, offset + 1)) break;\n      const end = Node.endOfBlockIndent(src, indent, offset + 1);\n      if (end === null || src[end] === '#') break;\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        valueEnd = PlainValue.endOfLine(src, end, inFlow);\n        offset = valueEnd;\n      }\n    }\n\n    if (this.valueRange.isEmpty()) this.valueRange.start = start;\n    this.valueRange.end = valueEnd;\n    return valueEnd;\n  }\n  /**\n   * Parses a plain value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * #comment\n   *\n   * first line\n   *\n   * first line #comment\n   *\n   * first line\n   * block\n   * lines\n   *\n   * #comment\n   * block\n   * lines\n   * ```\n   * where block lines are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar, may be `\\n`\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      inFlow,\n      src\n    } = context;\n    let offset = start;\n    const ch = src[offset];\n\n    if (ch && ch !== '#' && ch !== '\\n') {\n      offset = PlainValue.endOfLine(src, start, inFlow);\n    }\n\n    this.valueRange = new Range(start, offset);\n    offset = Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n\n    if (!this.hasComment || this.valueRange.isEmpty()) {\n      offset = this.parseBlockValue(offset);\n    }\n\n    return offset;\n  }\n\n}\n\nexports.Char = Char;\nexports.Node = Node;\nexports.PlainValue = PlainValue;\nexports.Range = Range;\nexports.Type = Type;\nexports.YAMLError = YAMLError;\nexports.YAMLReferenceError = YAMLReferenceError;\nexports.YAMLSemanticError = YAMLSemanticError;\nexports.YAMLSyntaxError = YAMLSyntaxError;\nexports.YAMLWarning = YAMLWarning;\nexports._defineProperty = _defineProperty;\nexports.defaultTagPrefix = defaultTagPrefix;\nexports.defaultTags = defaultTags;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nfunction addCommentBefore(str, indent, comment) {\n  if (!comment) return str;\n  const cc = comment.replace(/[\\s\\S]^/gm, `$&${indent}#`);\n  return `#${cc}\\n${indent}${str}`;\n}\nfunction addComment(str, indent, comment) {\n  return !comment ? str : comment.indexOf('\\n') === -1 ? `${str} #${comment}` : `${str}\\n` + comment.replace(/^/gm, `${indent || ''}#`);\n}\n\nclass Node {}\n\nfunction toJSON(value, arg, ctx) {\n  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));\n\n  if (value && typeof value.toJSON === 'function') {\n    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);\n    if (anchor) ctx.onCreate = res => {\n      anchor.res = res;\n      delete ctx.onCreate;\n    };\n    const res = value.toJSON(arg, ctx);\n    if (anchor && ctx.onCreate) ctx.onCreate(res);\n    return res;\n  }\n\n  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);\n  return value;\n}\n\nclass Scalar extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n  toJSON(arg, ctx) {\n    return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);\n  }\n\n  toString() {\n    return String(this.value);\n  }\n\n}\n\nfunction collectionFromPath(schema, path, value) {\n  let v = value;\n\n  for (let i = path.length - 1; i >= 0; --i) {\n    const k = path[i];\n    const o = Number.isInteger(k) && k >= 0 ? [] : {};\n    o[k] = v;\n    v = o;\n  }\n\n  return schema.createNode(v, false);\n} // null, undefined, or an empty non-string iterable (e.g. [])\n\n\nconst isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;\nclass Collection extends Node {\n  constructor(schema) {\n    super();\n\n    PlainValue._defineProperty(this, \"items\", []);\n\n    this.schema = schema;\n  }\n\n  addIn(path, value) {\n    if (isEmptyPath(path)) this.add(value);else {\n      const [key, ...rest] = path;\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  }\n\n  deleteIn([key, ...rest]) {\n    if (rest.length === 0) return this.delete(key);\n    const node = this.get(key, true);\n    if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n  }\n\n  getIn([key, ...rest], keepScalar) {\n    const node = this.get(key, true);\n    if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;\n  }\n\n  hasAllNullValues() {\n    return this.items.every(node => {\n      if (!node || node.type !== 'PAIR') return false;\n      const n = node.value;\n      return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n    });\n  }\n\n  hasIn([key, ...rest]) {\n    if (rest.length === 0) return this.has(key);\n    const node = this.get(key, true);\n    return node instanceof Collection ? node.hasIn(rest) : false;\n  }\n\n  setIn([key, ...rest], value) {\n    if (rest.length === 0) {\n      this.set(key, value);\n    } else {\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  } // overridden in implementations\n\n  /* istanbul ignore next */\n\n\n  toJSON() {\n    return null;\n  }\n\n  toString(ctx, {\n    blockItem,\n    flowChars,\n    isMap,\n    itemIndent\n  }, onComment, onChompKeep) {\n    const {\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;\n    if (inFlow) itemIndent += indentStep;\n    const allNullValues = isMap && this.hasAllNullValues();\n    ctx = Object.assign({}, ctx, {\n      allNullValues,\n      indent: itemIndent,\n      inFlow,\n      type: null\n    });\n    let chompKeep = false;\n    let hasItemWithNewLine = false;\n    const nodes = this.items.reduce((nodes, item, i) => {\n      let comment;\n\n      if (item) {\n        if (!chompKeep && item.spaceBefore) nodes.push({\n          type: 'comment',\n          str: ''\n        });\n        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => {\n          nodes.push({\n            type: 'comment',\n            str: `#${line}`\n          });\n        });\n        if (item.comment) comment = item.comment;\n        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;\n      }\n\n      chompKeep = false;\n      let str = stringify(item, ctx, () => comment = null, () => chompKeep = true);\n      if (inFlow && !hasItemWithNewLine && str.includes('\\n')) hasItemWithNewLine = true;\n      if (inFlow && i < this.items.length - 1) str += ',';\n      str = addComment(str, itemIndent, comment);\n      if (chompKeep && (comment || inFlow)) chompKeep = false;\n      nodes.push({\n        type: 'item',\n        str\n      });\n      return nodes;\n    }, []);\n    let str;\n\n    if (nodes.length === 0) {\n      str = flowChars.start + flowChars.end;\n    } else if (inFlow) {\n      const {\n        start,\n        end\n      } = flowChars;\n      const strings = nodes.map(n => n.str);\n\n      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {\n        str = start;\n\n        for (const s of strings) {\n          str += s ? `\\n${indentStep}${indent}${s}` : '\\n';\n        }\n\n        str += `\\n${indent}${end}`;\n      } else {\n        str = `${start} ${strings.join(' ')} ${end}`;\n      }\n    } else {\n      const strings = nodes.map(blockItem);\n      str = strings.shift();\n\n      for (const s of strings) str += s ? `\\n${indent}${s}` : '\\n';\n    }\n\n    if (this.comment) {\n      str += '\\n' + this.comment.replace(/^/gm, `${indent}#`);\n      if (onComment) onComment();\n    } else if (chompKeep && onChompKeep) onChompKeep();\n\n    return str;\n  }\n\n}\n\nPlainValue._defineProperty(Collection, \"maxFlowStringSingleLineLength\", 60);\n\nfunction asItemIndex(key) {\n  let idx = key instanceof Scalar ? key.value : key;\n  if (idx && typeof idx === 'string') idx = Number(idx);\n  return Number.isInteger(idx) && idx >= 0 ? idx : null;\n}\n\nclass YAMLSeq extends Collection {\n  add(value) {\n    this.items.push(value);\n  }\n\n  delete(key) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return false;\n    const del = this.items.splice(idx, 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return undefined;\n    const it = this.items[idx];\n    return !keepScalar && it instanceof Scalar ? it.value : it;\n  }\n\n  has(key) {\n    const idx = asItemIndex(key);\n    return typeof idx === 'number' && idx < this.items.length;\n  }\n\n  set(key, value) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);\n    this.items[idx] = value;\n  }\n\n  toJSON(_, ctx) {\n    const seq = [];\n    if (ctx && ctx.onCreate) ctx.onCreate(seq);\n    let i = 0;\n\n    for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));\n\n    return seq;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    return super.toString(ctx, {\n      blockItem: n => n.type === 'comment' ? n.str : `- ${n.str}`,\n      flowChars: {\n        start: '[',\n        end: ']'\n      },\n      isMap: false,\n      itemIndent: (ctx.indent || '') + '  '\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst stringifyKey = (key, jsKey, ctx) => {\n  if (jsKey === null) return '';\n  if (typeof jsKey !== 'object') return String(jsKey);\n  if (key instanceof Node && ctx && ctx.doc) return key.toString({\n    anchors: {},\n    doc: ctx.doc,\n    indent: '',\n    indentStep: ctx.indentStep,\n    inFlow: true,\n    inStringifyKey: true,\n    stringify: ctx.stringify\n  });\n  return JSON.stringify(jsKey);\n};\n\nclass Pair extends Node {\n  constructor(key, value = null) {\n    super();\n    this.key = key;\n    this.value = value;\n    this.type = Pair.Type.PAIR;\n  }\n\n  get commentBefore() {\n    return this.key instanceof Node ? this.key.commentBefore : undefined;\n  }\n\n  set commentBefore(cb) {\n    if (this.key == null) this.key = new Scalar(null);\n    if (this.key instanceof Node) this.key.commentBefore = cb;else {\n      const msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';\n      throw new Error(msg);\n    }\n  }\n\n  addToJSMap(ctx, map) {\n    const key = toJSON(this.key, '', ctx);\n\n    if (map instanceof Map) {\n      const value = toJSON(this.value, key, ctx);\n      map.set(key, value);\n    } else if (map instanceof Set) {\n      map.add(key);\n    } else {\n      const stringKey = stringifyKey(this.key, key, ctx);\n      map[stringKey] = toJSON(this.value, stringKey, ctx);\n    }\n\n    return map;\n  }\n\n  toJSON(_, ctx) {\n    const pair = ctx && ctx.mapAsMap ? new Map() : {};\n    return this.addToJSMap(ctx, pair);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx || !ctx.doc) return JSON.stringify(this);\n    const {\n      indent: indentSize,\n      indentSeq,\n      simpleKeys\n    } = ctx.doc.options;\n    let {\n      key,\n      value\n    } = this;\n    let keyComment = key instanceof Node && key.comment;\n\n    if (simpleKeys) {\n      if (keyComment) {\n        throw new Error('With simple keys, key nodes cannot have comments');\n      }\n\n      if (key instanceof Collection) {\n        const msg = 'With simple keys, collection cannot be used as a key value';\n        throw new Error(msg);\n      }\n    }\n\n    const explicitKey = !simpleKeys && (!key || keyComment || key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL);\n    const {\n      doc,\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    ctx = Object.assign({}, ctx, {\n      implicitKey: !explicitKey,\n      indent: indent + indentStep\n    });\n    let chompKeep = false;\n    let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);\n    str = addComment(str, ctx.indent, keyComment);\n\n    if (ctx.allNullValues && !simpleKeys) {\n      if (this.comment) {\n        str = addComment(str, ctx.indent, this.comment);\n        if (onComment) onComment();\n      } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();\n\n      return ctx.inFlow ? str : `? ${str}`;\n    }\n\n    str = explicitKey ? `? ${str}\\n${indent}:` : `${str}:`;\n\n    if (this.comment) {\n      // expected (but not strictly required) to be a single-line comment\n      str = addComment(str, ctx.indent, this.comment);\n      if (onComment) onComment();\n    }\n\n    let vcb = '';\n    let valueComment = null;\n\n    if (value instanceof Node) {\n      if (value.spaceBefore) vcb = '\\n';\n\n      if (value.commentBefore) {\n        const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);\n        vcb += `\\n${cs}`;\n      }\n\n      valueComment = value.comment;\n    } else if (value && typeof value === 'object') {\n      value = doc.schema.createNode(value, true);\n    }\n\n    ctx.implicitKey = false;\n    if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n\n    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {\n      // If indentSeq === false, consider '- ' as part of indentation where possible\n      ctx.indent = ctx.indent.substr(2);\n    }\n\n    const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);\n    let ws = ' ';\n\n    if (vcb || this.comment) {\n      ws = `${vcb}\\n${ctx.indent}`;\n    } else if (!explicitKey && value instanceof Collection) {\n      const flow = valueStr[0] === '[' || valueStr[0] === '{';\n      if (!flow || valueStr.includes('\\n')) ws = `\\n${ctx.indent}`;\n    }\n\n    if (chompKeep && !valueComment && onChompKeep) onChompKeep();\n    return addComment(str + ws + valueStr, ctx.indent, valueComment);\n  }\n\n}\n\nPlainValue._defineProperty(Pair, \"Type\", {\n  PAIR: 'PAIR',\n  MERGE_PAIR: 'MERGE_PAIR'\n});\n\nconst getAliasCount = (node, anchors) => {\n  if (node instanceof Alias) {\n    const anchor = anchors.get(node.source);\n    return anchor.count * anchor.aliasCount;\n  } else if (node instanceof Collection) {\n    let count = 0;\n\n    for (const item of node.items) {\n      const c = getAliasCount(item, anchors);\n      if (c > count) count = c;\n    }\n\n    return count;\n  } else if (node instanceof Pair) {\n    const kc = getAliasCount(node.key, anchors);\n    const vc = getAliasCount(node.value, anchors);\n    return Math.max(kc, vc);\n  }\n\n  return 1;\n};\n\nclass Alias extends Node {\n  static stringify({\n    range,\n    source\n  }, {\n    anchors,\n    doc,\n    implicitKey,\n    inStringifyKey\n  }) {\n    let anchor = Object.keys(anchors).find(a => anchors[a] === source);\n    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();\n    if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;\n    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';\n    throw new Error(`${msg} [${range}]`);\n  }\n\n  constructor(source) {\n    super();\n    this.source = source;\n    this.type = PlainValue.Type.ALIAS;\n  }\n\n  set tag(t) {\n    throw new Error('Alias nodes cannot have tags');\n  }\n\n  toJSON(arg, ctx) {\n    if (!ctx) return toJSON(this.source, arg, ctx);\n    const {\n      anchors,\n      maxAliasCount\n    } = ctx;\n    const anchor = anchors.get(this.source);\n    /* istanbul ignore if */\n\n    if (!anchor || anchor.res === undefined) {\n      const msg = 'This should not happen: Alias anchor was not resolved?';\n      if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n    }\n\n    if (maxAliasCount >= 0) {\n      anchor.count += 1;\n      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);\n\n      if (anchor.count * anchor.aliasCount > maxAliasCount) {\n        const msg = 'Excessive alias count indicates a resource exhaustion attack';\n        if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n      }\n    }\n\n    return anchor.res;\n  } // Only called when stringifying an alias mapping key while constructing\n  // Object output.\n\n\n  toString(ctx) {\n    return Alias.stringify(this, ctx);\n  }\n\n}\n\nPlainValue._defineProperty(Alias, \"default\", true);\n\nfunction findPair(items, key) {\n  const k = key instanceof Scalar ? key.value : key;\n\n  for (const it of items) {\n    if (it instanceof Pair) {\n      if (it.key === key || it.key === k) return it;\n      if (it.key && it.key.value === k) return it;\n    }\n  }\n\n  return undefined;\n}\nclass YAMLMap extends Collection {\n  add(pair, overwrite) {\n    if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);\n    const prev = findPair(this.items, pair.key);\n    const sortEntries = this.schema && this.schema.sortMapEntries;\n\n    if (prev) {\n      if (overwrite) prev.value = pair.value;else throw new Error(`Key ${pair.key} already set`);\n    } else if (sortEntries) {\n      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);\n      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);\n    } else {\n      this.items.push(pair);\n    }\n  }\n\n  delete(key) {\n    const it = findPair(this.items, key);\n    if (!it) return false;\n    const del = this.items.splice(this.items.indexOf(it), 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const it = findPair(this.items, key);\n    const node = it && it.value;\n    return !keepScalar && node instanceof Scalar ? node.value : node;\n  }\n\n  has(key) {\n    return !!findPair(this.items, key);\n  }\n\n  set(key, value) {\n    this.add(new Pair(key, value), true);\n  }\n  /**\n   * @param {*} arg ignored\n   * @param {*} ctx Conversion context, originally set in Document#toJSON()\n   * @param {Class} Type If set, forces the returned collection type\n   * @returns {*} Instance of Type, Map, or Object\n   */\n\n\n  toJSON(_, ctx, Type) {\n    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const item of this.items) item.addToJSMap(ctx, map);\n\n    return map;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n\n    for (const item of this.items) {\n      if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n    }\n\n    return super.toString(ctx, {\n      blockItem: n => n.str,\n      flowChars: {\n        start: '{',\n        end: '}'\n      },\n      isMap: true,\n      itemIndent: ctx.indent || ''\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst MERGE_KEY = '<<';\nclass Merge extends Pair {\n  constructor(pair) {\n    if (pair instanceof Pair) {\n      let seq = pair.value;\n\n      if (!(seq instanceof YAMLSeq)) {\n        seq = new YAMLSeq();\n        seq.items.push(pair.value);\n        seq.range = pair.value.range;\n      }\n\n      super(pair.key, seq);\n      this.range = pair.range;\n    } else {\n      super(new Scalar(MERGE_KEY), new YAMLSeq());\n    }\n\n    this.type = Pair.Type.MERGE_PAIR;\n  } // If the value associated with a merge key is a single mapping node, each of\n  // its key/value pairs is inserted into the current mapping, unless the key\n  // already exists in it. If the value associated with the merge key is a\n  // sequence, then this sequence is expected to contain mapping nodes and each\n  // of these nodes is merged in turn according to its order in the sequence.\n  // Keys in mapping nodes earlier in the sequence override keys specified in\n  // later mapping nodes. -- http://yaml.org/type/merge.html\n\n\n  addToJSMap(ctx, map) {\n    for (const {\n      source\n    } of this.value.items) {\n      if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');\n      const srcMap = source.toJSON(null, ctx, Map);\n\n      for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n          if (!map.has(key)) map.set(key, value);\n        } else if (map instanceof Set) {\n          map.add(key);\n        } else {\n          if (!Object.prototype.hasOwnProperty.call(map, key)) map[key] = value;\n        }\n      }\n    }\n\n    return map;\n  }\n\n  toString(ctx, onComment) {\n    const seq = this.value;\n    if (seq.items.length > 1) return super.toString(ctx, onComment);\n    this.value = seq.items[0];\n    const str = super.toString(ctx, onComment);\n    this.value = seq;\n    return str;\n  }\n\n}\n\nconst binaryOptions = {\n  defaultType: PlainValue.Type.BLOCK_LITERAL,\n  lineWidth: 76\n};\nconst boolOptions = {\n  trueStr: 'true',\n  falseStr: 'false'\n};\nconst intOptions = {\n  asBigInt: false\n};\nconst nullOptions = {\n  nullStr: 'null'\n};\nconst strOptions = {\n  defaultType: PlainValue.Type.PLAIN,\n  doubleQuoted: {\n    jsonEncoding: false,\n    minMultiLineLength: 40\n  },\n  fold: {\n    lineWidth: 80,\n    minContentWidth: 20\n  }\n};\n\nfunction resolveScalar(str, tags, scalarFallback) {\n  for (const {\n    format,\n    test,\n    resolve\n  } of tags) {\n    if (test) {\n      const match = str.match(test);\n\n      if (match) {\n        let res = resolve.apply(null, match);\n        if (!(res instanceof Scalar)) res = new Scalar(res);\n        if (format) res.format = format;\n        return res;\n      }\n    }\n  }\n\n  if (scalarFallback) str = scalarFallback(str);\n  return new Scalar(str);\n}\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line\n// returns index of last newline in more-indented block\n\nconst consumeMoreIndentedLines = (text, i) => {\n  let ch = text[i + 1];\n\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n\n    ch = text[i + 1];\n  }\n\n  return i;\n};\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n *\n * @param {string} text\n * @param {string} indent\n * @param {string} [mode='flow'] `'block'` prevents more-indented lines\n *   from being folded; `'quoted'` allows for `\\` escapes, including escaped\n *   newlines\n * @param {Object} options\n * @param {number} [options.indentAtStart] Accounts for leading contents on\n *   the first line, defaulting to `indent.length`\n * @param {number} [options.lineWidth=80]\n * @param {number} [options.minContentWidth=20] Allow highly indented lines to\n *   stretch the line width\n * @param {function} options.onFold Called once if the text is folded\n * @param {function} options.onFold Called once if any line of text exceeds\n *   lineWidth characters\n */\n\n\nfunction foldFlowLines(text, indent, mode, {\n  indentAtStart,\n  lineWidth = 80,\n  minContentWidth = 20,\n  onFold,\n  onOverflow\n}) {\n  if (!lineWidth || lineWidth < 0) return text;\n  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  const folds = [];\n  const escapedFolds = {};\n  let end = lineWidth - (typeof indentAtStart === 'number' ? indentAtStart : indent.length);\n  let split = undefined;\n  let prev = undefined;\n  let overflow = false;\n  let i = -1;\n\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n\n  for (let ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n\n        case 'u':\n          i += 5;\n          break;\n\n        case 'U':\n          i += 9;\n          break;\n\n        default:\n          i += 1;\n      }\n    }\n\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        const next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          } // i - 2 accounts for not-dropped last char + newline-escaping \\\n\n\n          folds.push(i - 2);\n          escapedFolds[i - 2] = true;\n          end = i - 2 + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n\n    prev = ch;\n  }\n\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  let res = text.slice(0, folds[0]);\n\n  for (let i = 0; i < folds.length; ++i) {\n    const fold = folds[i];\n    const end = folds[i + 1] || text.length;\n    if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\\\`;\n    res += `\\n${indent}${text.slice(fold + 1, end)}`;\n  }\n\n  return res;\n}\n\nconst getFoldOptions = ({\n  indentAtStart\n}) => indentAtStart ? Object.assign({\n  indentAtStart\n}, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\n\n\nconst containsDocumentMarker = str => /^(%|---|\\.\\.\\.)/m.test(str);\n\nfunction lineLengthOverLimit(str, limit) {\n  const strLen = str.length;\n  if (strLen <= limit) return false;\n\n  for (let i = 0, start = 0; i < strLen; ++i) {\n    if (str[i] === '\\n') {\n      if (i - start > limit) return true;\n      start = i + 1;\n      if (strLen - start <= limit) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction doubleQuotedString(value, ctx) {\n  const {\n    implicitKey\n  } = ctx;\n  const {\n    jsonEncoding,\n    minMultiLineLength\n  } = strOptions.doubleQuoted;\n  const json = JSON.stringify(value);\n  if (jsonEncoding) return json;\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  let str = '';\n  let start = 0;\n\n  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n    if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n      // space before newline needs to be escaped to not be folded\n      str += json.slice(start, i) + '\\\\ ';\n      i += 1;\n      start = i;\n      ch = '\\\\';\n    }\n\n    if (ch === '\\\\') switch (json[i + 1]) {\n      case 'u':\n        {\n          str += json.slice(start, i);\n          const code = json.substr(i + 2, 4);\n\n          switch (code) {\n            case '0000':\n              str += '\\\\0';\n              break;\n\n            case '0007':\n              str += '\\\\a';\n              break;\n\n            case '000b':\n              str += '\\\\v';\n              break;\n\n            case '001b':\n              str += '\\\\e';\n              break;\n\n            case '0085':\n              str += '\\\\N';\n              break;\n\n            case '00a0':\n              str += '\\\\_';\n              break;\n\n            case '2028':\n              str += '\\\\L';\n              break;\n\n            case '2029':\n              str += '\\\\P';\n              break;\n\n            default:\n              if (code.substr(0, 2) === '00') str += '\\\\x' + code.substr(2);else str += json.substr(i, 6);\n          }\n\n          i += 5;\n          start = i + 1;\n        }\n        break;\n\n      case 'n':\n        if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n          i += 1;\n        } else {\n          // folding will eat first newline\n          str += json.slice(start, i) + '\\n\\n';\n\n          while (json[i + 2] === '\\\\' && json[i + 3] === 'n' && json[i + 4] !== '\"') {\n            str += '\\n';\n            i += 2;\n          }\n\n          str += indent; // space after newline needs to be escaped to not be folded\n\n          if (json[i + 2] === ' ') str += '\\\\';\n          i += 1;\n          start = i + 1;\n        }\n\n        break;\n\n      default:\n        i += 1;\n    }\n  }\n\n  str = start ? str + json.slice(start) : json;\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\n\nfunction singleQuotedString(value, ctx) {\n  if (ctx.implicitKey) {\n    if (/\\n/.test(value)) return doubleQuotedString(value, ctx);\n  } else {\n    // single quoted string can't have leading or trailing whitespace around newline\n    if (/[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\n\nfunction blockString({\n  comment,\n  type,\n  value\n}, ctx, onComment, onChompKeep) {\n  // 1. Block can't end in whitespace unless the last line is non-empty.\n  // 2. Strings consisting of only whitespace are best rendered explicitly.\n  if (/\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n  const indentSize = indent ? '2' : '1'; // root is at -1\n\n  const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth - indent.length);\n  let header = literal ? '|' : '>';\n  if (!value) return header + '\\n';\n  let wsStart = '';\n  let wsEnd = '';\n  value = value.replace(/[\\n\\t ]*$/, ws => {\n    const n = ws.indexOf('\\n');\n\n    if (n === -1) {\n      header += '-'; // strip\n    } else if (value === ws || n !== ws.length - 1) {\n      header += '+'; // keep\n\n      if (onChompKeep) onChompKeep();\n    }\n\n    wsEnd = ws.replace(/\\n$/, '');\n    return '';\n  }).replace(/^[\\n ]*/, ws => {\n    if (ws.indexOf(' ') !== -1) header += indentSize;\n    const m = ws.match(/ +$/);\n\n    if (m) {\n      wsStart = ws.slice(0, -m[0].length);\n      return m[0];\n    } else {\n      wsStart = ws;\n      return '';\n    }\n  });\n  if (wsEnd) wsEnd = wsEnd.replace(/\\n+(?!\\n|$)/g, `$&${indent}`);\n  if (wsStart) wsStart = wsStart.replace(/\\n+/g, `$&${indent}`);\n\n  if (comment) {\n    header += ' #' + comment.replace(/ ?[\\r\\n]+/g, ' ');\n    if (onComment) onComment();\n  }\n\n  if (!value) return `${header}${indentSize}\\n${indent}${wsEnd}`;\n\n  if (literal) {\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `${header}\\n${indent}${wsStart}${value}${wsEnd}`;\n  }\n\n  value = value.replace(/\\n+/g, '\\n$&').replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent\n  .replace(/\\n+/g, `$&${indent}`);\n  const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);\n  return `${header}\\n${indent}${body}`;\n}\n\nfunction plainString(item, ctx, onComment, onChompKeep) {\n  const {\n    comment,\n    type,\n    value\n  } = item;\n  const {\n    actualString,\n    implicitKey,\n    indent,\n    inFlow\n  } = ctx;\n\n  if (implicitKey && /[\\n[\\]{},]/.test(value) || inFlow && /[[\\]{},]/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n    // not allowed:\n    // - empty string, '-' or '?'\n    // - start with an indicator character (except [?:-]) or /[?-] /\n    // - '\\n ', ': ' or ' \\n' anywhere\n    // - '#' not preceded by a non-space char\n    // - end with ' ' or ':'\n    return implicitKey || inFlow || value.indexOf('\\n') === -1 ? value.indexOf('\"') !== -1 && value.indexOf(\"'\") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf('\\n') !== -1) {\n    // Where allowed & type not set explicitly, prefer block style for multiline strings\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (indent === '' && containsDocumentMarker(value)) {\n    ctx.forceBlockIndent = true;\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  const str = value.replace(/\\n+/g, `$&\\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and\n  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n  // and others in v1.1.\n\n  if (actualString) {\n    const {\n      tags\n    } = ctx.doc.schema;\n    const resolved = resolveScalar(str, tags, tags.scalarFallback).value;\n    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);\n  }\n\n  const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n\n  if (comment && !inFlow && (body.indexOf('\\n') !== -1 || comment.indexOf('\\n') !== -1)) {\n    if (onComment) onComment();\n    return addCommentBefore(body, indent, comment);\n  }\n\n  return body;\n}\n\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n  const {\n    defaultType\n  } = strOptions;\n  const {\n    implicitKey,\n    inFlow\n  } = ctx;\n  let {\n    type,\n    value\n  } = item;\n\n  if (typeof value !== 'string') {\n    value = String(value);\n    item = Object.assign({}, item, {\n      value\n    });\n  }\n\n  const _stringify = _type => {\n    switch (_type) {\n      case PlainValue.Type.BLOCK_FOLDED:\n      case PlainValue.Type.BLOCK_LITERAL:\n        return blockString(item, ctx, onComment, onChompKeep);\n\n      case PlainValue.Type.QUOTE_DOUBLE:\n        return doubleQuotedString(value, ctx);\n\n      case PlainValue.Type.QUOTE_SINGLE:\n        return singleQuotedString(value, ctx);\n\n      case PlainValue.Type.PLAIN:\n        return plainString(item, ctx, onComment, onChompKeep);\n\n      default:\n        return null;\n    }\n  };\n\n  if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f]/.test(value)) {\n    // force double quotes on control characters\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {\n    // should not happen; blocks are not valid inside flow containers\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  }\n\n  let res = _stringify(type);\n\n  if (res === null) {\n    res = _stringify(defaultType);\n    if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);\n  }\n\n  return res;\n}\n\nfunction stringifyNumber({\n  format,\n  minFractionDigits,\n  tag,\n  value\n}) {\n  if (typeof value === 'bigint') return String(value);\n  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';\n  let n = JSON.stringify(value);\n\n  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\\d/.test(n)) {\n    let i = n.indexOf('.');\n\n    if (i < 0) {\n      i = n.length;\n      n += '.';\n    }\n\n    let d = minFractionDigits - (n.length - i - 1);\n\n    while (d-- > 0) n += '0';\n  }\n\n  return n;\n}\n\nfunction checkFlowCollectionEnd(errors, cst) {\n  let char, name;\n\n  switch (cst.type) {\n    case PlainValue.Type.FLOW_MAP:\n      char = '}';\n      name = 'flow map';\n      break;\n\n    case PlainValue.Type.FLOW_SEQ:\n      char = ']';\n      name = 'flow sequence';\n      break;\n\n    default:\n      errors.push(new PlainValue.YAMLSemanticError(cst, 'Not a flow collection!?'));\n      return;\n  }\n\n  let lastItem;\n\n  for (let i = cst.items.length - 1; i >= 0; --i) {\n    const item = cst.items[i];\n\n    if (!item || item.type !== PlainValue.Type.COMMENT) {\n      lastItem = item;\n      break;\n    }\n  }\n\n  if (lastItem && lastItem.char !== char) {\n    const msg = `Expected ${name} to end with ${char}`;\n    let err;\n\n    if (typeof lastItem.offset === 'number') {\n      err = new PlainValue.YAMLSemanticError(cst, msg);\n      err.offset = lastItem.offset + 1;\n    } else {\n      err = new PlainValue.YAMLSemanticError(lastItem, msg);\n      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;\n    }\n\n    errors.push(err);\n  }\n}\nfunction checkFlowCommentSpace(errors, comment) {\n  const prev = comment.context.src[comment.range.start - 1];\n\n  if (prev !== '\\n' && prev !== '\\t' && prev !== ' ') {\n    const msg = 'Comments must be separated from other tokens by white space characters';\n    errors.push(new PlainValue.YAMLSemanticError(comment, msg));\n  }\n}\nfunction getLongKeyError(source, key) {\n  const sk = String(key);\n  const k = sk.substr(0, 8) + '...' + sk.substr(-8);\n  return new PlainValue.YAMLSemanticError(source, `The \"${k}\" key is too long`);\n}\nfunction resolveComments(collection, comments) {\n  for (const {\n    afterKey,\n    before,\n    comment\n  } of comments) {\n    let item = collection.items[before];\n\n    if (!item) {\n      if (comment !== undefined) {\n        if (collection.comment) collection.comment += '\\n' + comment;else collection.comment = comment;\n      }\n    } else {\n      if (afterKey && item.value) item = item.value;\n\n      if (comment === undefined) {\n        if (afterKey || !item.commentBefore) item.spaceBefore = true;\n      } else {\n        if (item.commentBefore) item.commentBefore += '\\n' + comment;else item.commentBefore = comment;\n      }\n    }\n  }\n}\n\n// on error, will return { str: string, errors: Error[] }\nfunction resolveString(doc, node) {\n  const res = node.strValue;\n  if (!res) return '';\n  if (typeof res === 'string') return res;\n  res.errors.forEach(error => {\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n  });\n  return res.str;\n}\n\nfunction resolveTagHandle(doc, node) {\n  const {\n    handle,\n    suffix\n  } = node.tag;\n  let prefix = doc.tagPrefixes.find(p => p.handle === handle);\n\n  if (!prefix) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    if (dtp) prefix = dtp.find(p => p.handle === handle);\n    if (!prefix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);\n  }\n\n  if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);\n\n  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {\n    if (suffix[0] === '^') {\n      doc.warnings.push(new PlainValue.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));\n      return suffix;\n    }\n\n    if (/[:/]/.test(suffix)) {\n      // word/foo -> tag:word.yaml.org,2002:foo\n      const vocab = suffix.match(/^([a-z0-9-]+)\\/(.*)/i);\n      return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;\n    }\n  }\n\n  return prefix.prefix + decodeURIComponent(suffix);\n}\n\nfunction resolveTagName(doc, node) {\n  const {\n    tag,\n    type\n  } = node;\n  let nonSpecific = false;\n\n  if (tag) {\n    const {\n      handle,\n      suffix,\n      verbatim\n    } = tag;\n\n    if (verbatim) {\n      if (verbatim !== '!' && verbatim !== '!!') return verbatim;\n      const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;\n      doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n    } else if (handle === '!' && !suffix) {\n      nonSpecific = true;\n    } else {\n      try {\n        return resolveTagHandle(doc, node);\n      } catch (error) {\n        doc.errors.push(error);\n      }\n    }\n  }\n\n  switch (type) {\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n    case PlainValue.Type.QUOTE_DOUBLE:\n    case PlainValue.Type.QUOTE_SINGLE:\n      return PlainValue.defaultTags.STR;\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    case PlainValue.Type.PLAIN:\n      return nonSpecific ? PlainValue.defaultTags.STR : null;\n\n    default:\n      return null;\n  }\n}\n\nfunction resolveByTagName(doc, node, tagName) {\n  const {\n    tags\n  } = doc.schema;\n  const matchWithTest = [];\n\n  for (const tag of tags) {\n    if (tag.tag === tagName) {\n      if (tag.test) matchWithTest.push(tag);else {\n        const res = tag.resolve(doc, node);\n        return res instanceof Collection ? res : new Scalar(res);\n      }\n    }\n  }\n\n  const str = resolveString(doc, node);\n  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);\n  return null;\n}\n\nfunction getFallbackTagName({\n  type\n}) {\n  switch (type) {\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    default:\n      return PlainValue.defaultTags.STR;\n  }\n}\n\nfunction resolveTag(doc, node, tagName) {\n  try {\n    const res = resolveByTagName(doc, node, tagName);\n\n    if (res) {\n      if (tagName && node.tag) res.tag = tagName;\n      return res;\n    }\n  } catch (error) {\n    /* istanbul ignore if */\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n    return null;\n  }\n\n  try {\n    const fallback = getFallbackTagName(node);\n    if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);\n    const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(node, msg));\n    const res = resolveByTagName(doc, node, fallback);\n    res.tag = tagName;\n    return res;\n  } catch (error) {\n    const refError = new PlainValue.YAMLReferenceError(node, error.message);\n    refError.stack = error.stack;\n    doc.errors.push(refError);\n    return null;\n  }\n}\n\nconst isCollectionItem = node => {\n  if (!node) return false;\n  const {\n    type\n  } = node;\n  return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;\n};\n\nfunction resolveNodeProps(errors, node) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let hasAnchor = false;\n  let hasTag = false;\n  const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;\n\n  for (const {\n    start,\n    end\n  } of props) {\n    switch (node.context.src[start]) {\n      case PlainValue.Char.COMMENT:\n        {\n          if (!node.commentHasRequiredWhitespace(start)) {\n            const msg = 'Comments must be separated from other tokens by white space characters';\n            errors.push(new PlainValue.YAMLSemanticError(node, msg));\n          }\n\n          const {\n            header,\n            valueRange\n          } = node;\n          const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;\n          cc.push(node.context.src.slice(start + 1, end));\n          break;\n        }\n      // Actual anchor & tag resolution is handled by schema, here we just complain\n\n      case PlainValue.Char.ANCHOR:\n        if (hasAnchor) {\n          const msg = 'A node can have at most one anchor';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasAnchor = true;\n        break;\n\n      case PlainValue.Char.TAG:\n        if (hasTag) {\n          const msg = 'A node can have at most one tag';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasTag = true;\n        break;\n    }\n  }\n\n  return {\n    comments,\n    hasAnchor,\n    hasTag\n  };\n}\n\nfunction resolveNodeValue(doc, node) {\n  const {\n    anchors,\n    errors,\n    schema\n  } = doc;\n\n  if (node.type === PlainValue.Type.ALIAS) {\n    const name = node.rawValue;\n    const src = anchors.getNode(name);\n\n    if (!src) {\n      const msg = `Aliased anchor not found: ${name}`;\n      errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    } // Lazy resolution for circular references\n\n\n    const res = new Alias(src);\n\n    anchors._cstAliases.push(res);\n\n    return res;\n  }\n\n  const tagName = resolveTagName(doc, node);\n  if (tagName) return resolveTag(doc, node, tagName);\n\n  if (node.type !== PlainValue.Type.PLAIN) {\n    const msg = `Failed to resolve ${node.type} node here`;\n    errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n    return null;\n  }\n\n  try {\n    const str = resolveString(doc, node);\n    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);\n  } catch (error) {\n    if (!error.source) error.source = node;\n    errors.push(error);\n    return null;\n  }\n} // sets node.resolved on success\n\n\nfunction resolveNode(doc, node) {\n  if (!node) return null;\n  if (node.error) doc.errors.push(node.error);\n  const {\n    comments,\n    hasAnchor,\n    hasTag\n  } = resolveNodeProps(doc.errors, node);\n\n  if (hasAnchor) {\n    const {\n      anchors\n    } = doc;\n    const name = node.anchor;\n    const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor\n    // name have already been resolved, so it may safely be renamed.\n\n    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as\n    // anchors need to be available during resolution to allow for\n    // circular references.\n\n    anchors.map[name] = node;\n  }\n\n  if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {\n    const msg = 'An alias node must not specify any properties';\n    doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n  }\n\n  const res = resolveNodeValue(doc, node);\n\n  if (res) {\n    res.range = [node.range.start, node.range.end];\n    if (doc.options.keepCstNodes) res.cstNode = node;\n    if (doc.options.keepNodeTypes) res.type = node.type;\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      res.commentBefore = res.commentBefore ? `${res.commentBefore}\\n${cb}` : cb;\n    }\n\n    const ca = comments.after.join('\\n');\n    if (ca) res.comment = res.comment ? `${res.comment}\\n${ca}` : ca;\n  }\n\n  return node.resolved = res;\n}\n\nfunction resolveMap(doc, cst) {\n  if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {\n    const msg = `A ${cst.type} node cannot be resolved as a mapping`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);\n  const map = new YAMLMap();\n  map.items = items;\n  resolveComments(map, comments);\n  let hasCollectionKey = false;\n\n  for (let i = 0; i < items.length; ++i) {\n    const {\n      key: iKey\n    } = items[i];\n    if (iKey instanceof Collection) hasCollectionKey = true;\n\n    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {\n      items[i] = new Merge(items[i]);\n      const sources = items[i].value.items;\n      let error = null;\n      sources.some(node => {\n        if (node instanceof Alias) {\n          // During parsing, alias sources are CST nodes; to account for\n          // circular references their resolved values can't be used here.\n          const {\n            type\n          } = node.source;\n          if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;\n          return error = 'Merge nodes aliases can only point to maps';\n        }\n\n        return error = 'Merge nodes can only have Alias nodes as values';\n      });\n      if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));\n    } else {\n      for (let j = i + 1; j < items.length; ++j) {\n        const {\n          key: jKey\n        } = items[j];\n\n        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {\n          const msg = `Map keys must be unique; \"${iKey}\" is repeated`;\n          doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));\n          break;\n        }\n      }\n    }\n  }\n\n  if (hasCollectionKey && !doc.options.mapAsMap) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = map;\n  return map;\n}\n\nconst valueHasPairComment = ({\n  context: {\n    lineStart,\n    node,\n    src\n  },\n  props\n}) => {\n  if (props.length === 0) return false;\n  const {\n    start\n  } = props[0];\n  if (node && start > node.valueRange.start) return false;\n  if (src[start] !== PlainValue.Char.COMMENT) return false;\n\n  for (let i = lineStart; i < start; ++i) if (src[i] === '\\n') return false;\n\n  return true;\n};\n\nfunction resolvePairComment(item, pair) {\n  if (!valueHasPairComment(item)) return;\n  const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);\n  let found = false;\n  const cb = pair.value.commentBefore;\n\n  if (cb && cb.startsWith(comment)) {\n    pair.value.commentBefore = cb.substr(comment.length + 1);\n    found = true;\n  } else {\n    const cc = pair.value.comment;\n\n    if (!item.node && cc && cc.startsWith(comment)) {\n      pair.value.comment = cc.substr(comment.length + 1);\n      found = true;\n    }\n  }\n\n  if (found) pair.comment = comment;\n}\n\nfunction resolveBlockMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let keyStart = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          afterKey: !!key,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          afterKey: !!key,\n          before: items.length,\n          comment: item.comment\n        });\n        break;\n\n      case PlainValue.Type.MAP_KEY:\n        if (key !== undefined) items.push(new Pair(key));\n        if (item.error) doc.errors.push(item.error);\n        key = resolveNode(doc, item.node);\n        keyStart = null;\n        break;\n\n      case PlainValue.Type.MAP_VALUE:\n        {\n          if (key === undefined) key = null;\n          if (item.error) doc.errors.push(item.error);\n\n          if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {\n            const msg = 'Nested mappings are not allowed in compact mappings';\n            doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));\n          }\n\n          let valueNode = item.node;\n\n          if (!valueNode && item.props.length > 0) {\n            // Comments on an empty mapping value need to be preserved, so we\n            // need to construct a minimal empty node here to use instead of the\n            // missing `item.node`. -- eemeli/yaml#19\n            valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);\n            valueNode.context = {\n              parent: item,\n              src: item.context.src\n            };\n            const pos = item.range.start + 1;\n            valueNode.range = {\n              start: pos,\n              end: pos\n            };\n            valueNode.valueRange = {\n              start: pos,\n              end: pos\n            };\n\n            if (typeof item.range.origStart === 'number') {\n              const origPos = item.range.origStart + 1;\n              valueNode.range.origStart = valueNode.range.origEnd = origPos;\n              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;\n            }\n          }\n\n          const pair = new Pair(key, resolveNode(doc, valueNode));\n          resolvePairComment(item, pair);\n          items.push(pair);\n\n          if (key && typeof keyStart === 'number') {\n            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n          }\n\n          key = undefined;\n          keyStart = null;\n        }\n        break;\n\n      default:\n        if (key !== undefined) items.push(new Pair(key));\n        key = resolveNode(doc, item);\n        keyStart = item.range.start;\n        if (item.error) doc.errors.push(item.error);\n\n        next: for (let j = i + 1;; ++j) {\n          const nextItem = cst.items[j];\n\n          switch (nextItem && nextItem.type) {\n            case PlainValue.Type.BLANK_LINE:\n            case PlainValue.Type.COMMENT:\n              continue next;\n\n            case PlainValue.Type.MAP_VALUE:\n              break next;\n\n            default:\n              {\n                const msg = 'Implicit map keys need to be followed by map values';\n                doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n                break next;\n              }\n          }\n        }\n\n        if (item.valueRangeContainsNewline) {\n          const msg = 'Implicit map keys need to be on a single line';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n    }\n  }\n\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let explicitKey = false;\n  let next = '{';\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char === '?' && key === undefined && !explicitKey) {\n        explicitKey = true;\n        next = ':';\n        continue;\n      }\n\n      if (char === ':') {\n        if (key === undefined) key = null;\n\n        if (next === ':') {\n          next = ',';\n          continue;\n        }\n      } else {\n        if (explicitKey) {\n          if (key === undefined && char !== ',') key = null;\n          explicitKey = false;\n        }\n\n        if (key !== undefined) {\n          items.push(new Pair(key));\n          key = undefined;\n\n          if (char === ',') {\n            next = ':';\n            continue;\n          }\n        }\n      }\n\n      if (char === '}') {\n        if (i === cst.items.length - 1) continue;\n      } else if (char === next) {\n        next = ':';\n        continue;\n      }\n\n      const msg = `Flow map contains an unexpected ${char}`;\n      const err = new PlainValue.YAMLSyntaxError(cst, msg);\n      err.offset = offset;\n      doc.errors.push(err);\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        afterKey: !!key,\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        afterKey: !!key,\n        before: items.length,\n        comment: item.comment\n      });\n    } else if (key === undefined) {\n      if (next === ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Separator , missing in flow map'));\n      key = resolveNode(doc, item);\n    } else {\n      if (next !== ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));\n      items.push(new Pair(key, resolveNode(doc, item)));\n      key = undefined;\n      explicitKey = false;\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveSeq(doc, cst) {\n  if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {\n    const msg = `A ${cst.type} node cannot be resolved as a sequence`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);\n  const seq = new YAMLSeq();\n  seq.items = items;\n  resolveComments(seq, comments);\n\n  if (!doc.options.mapAsMap && items.some(it => it instanceof Pair && it.key instanceof Collection)) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = seq;\n  return seq;\n}\n\nfunction resolveBlockSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          comment: item.comment,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.SEQ_ITEM:\n        if (item.error) doc.errors.push(item.error);\n        items.push(resolveNode(doc, item.node));\n\n        if (item.hasProps) {\n          const msg = 'Sequence items cannot have tags or anchors before the - indicator';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n        break;\n\n      default:\n        if (item.error) doc.errors.push(item.error);\n        doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));\n    }\n  }\n\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let explicitKey = false;\n  let key = undefined;\n  let keyStart = null;\n  let next = '[';\n  let prevItem = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char !== ':' && (explicitKey || key !== undefined)) {\n        if (explicitKey && key === undefined) key = next ? items.pop() : null;\n        items.push(new Pair(key));\n        explicitKey = false;\n        key = undefined;\n        keyStart = null;\n      }\n\n      if (char === next) {\n        next = null;\n      } else if (!next && char === '?') {\n        explicitKey = true;\n      } else if (next !== '[' && char === ':' && key === undefined) {\n        if (next === ',') {\n          key = items.pop();\n\n          if (key instanceof Pair) {\n            const msg = 'Chaining flow sequence pairs is invalid';\n            const err = new PlainValue.YAMLSemanticError(cst, msg);\n            err.offset = offset;\n            doc.errors.push(err);\n          }\n\n          if (!explicitKey && typeof keyStart === 'number') {\n            const keyEnd = item.range ? item.range.start : item.offset;\n            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n            const {\n              src\n            } = prevItem.context;\n\n            for (let i = keyStart; i < keyEnd; ++i) if (src[i] === '\\n') {\n              const msg = 'Implicit keys of flow sequence pairs need to be on a single line';\n              doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));\n              break;\n            }\n          }\n        } else {\n          key = null;\n        }\n\n        keyStart = null;\n        explicitKey = false;\n        next = null;\n      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {\n        const msg = `Flow sequence contains an unexpected ${char}`;\n        const err = new PlainValue.YAMLSyntaxError(cst, msg);\n        err.offset = offset;\n        doc.errors.push(err);\n      }\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        comment: item.comment,\n        before: items.length\n      });\n    } else {\n      if (next) {\n        const msg = `Expected a ${next} in flow sequence`;\n        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n      }\n\n      const value = resolveNode(doc, item);\n\n      if (key === undefined) {\n        items.push(value);\n        prevItem = item;\n      } else {\n        items.push(new Pair(key, value));\n        key = undefined;\n      }\n\n      keyStart = item.range.start;\n      next = ',';\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nexports.Alias = Alias;\nexports.Collection = Collection;\nexports.Merge = Merge;\nexports.Node = Node;\nexports.Pair = Pair;\nexports.Scalar = Scalar;\nexports.YAMLMap = YAMLMap;\nexports.YAMLSeq = YAMLSeq;\nexports.addComment = addComment;\nexports.binaryOptions = binaryOptions;\nexports.boolOptions = boolOptions;\nexports.findPair = findPair;\nexports.intOptions = intOptions;\nexports.isEmptyPath = isEmptyPath;\nexports.nullOptions = nullOptions;\nexports.resolveMap = resolveMap;\nexports.resolveNode = resolveNode;\nexports.resolveSeq = resolveSeq;\nexports.resolveString = resolveString;\nexports.strOptions = strOptions;\nexports.stringifyNumber = stringifyNumber;\nexports.stringifyString = stringifyString;\nexports.toJSON = toJSON;\n","module.exports = require(\"vscode\");","module.exports = require(\"url\");","// tslint:disable-next-line: no-implicit-dependencies\nimport * as VSC from 'vscode'\n\nimport FS = require(\"fs\")\n\nexport default {\n    changeExtension,\n    exists,\n    getBasename,\n    getDirectory,\n    openFileInEditor,\n    openTextDocument,\n    removeExtension,\n    writeTextFile\n}\n\nenum IViewColumn {\n    ACTIVE = -1,\n    BESIDE = -2,\n    ONE = 1,\n    TWO = 2\n}\n\nfunction changeExtension(filename: string, newExtension: string): string {\n    return `${removeExtension(filename)}.${newExtension}`\n}\n\nfunction exists(path: string): boolean {\n    return FS.existsSync(path)\n}\n\nasync function openTextDocument(filename: string):\n    Promise<VSC.TextDocument | null> {\n    return new Promise((resolve, reject) => {\n        if (!exists(filename)) {\n            resolve(null)\n            return\n        }\n        VSC.workspace.openTextDocument(filename).then(\n            resolve,\n            reject\n        )\n    })\n}\n\nasync function openFileInEditor(\n    filename: string,\n    viewColumn: VSC.ViewColumn = VSC.ViewColumn.Active\n): Promise<boolean> {\n    const doc = await openTextDocument(filename)\n    if (!doc) return false\n    VSC.window.showTextDocument(\n        doc,\n        viewColumn.valueOf()\n    )\n    return true\n}\n\nfunction removeExtension(filename: string): string {\n    const idxDot = filename.lastIndexOf(\".\")\n    return filename.substr(0, idxDot)\n}\n\nfunction getBasename(filename: string): string {\n    const idxSlash = filename.lastIndexOf(\"/\")\n    return filename.substring(idxSlash)\n}\n\nfunction getDirectory(filename: string): string {\n    const idxSlash = filename.lastIndexOf(\"/\")\n    return filename.substr(0, idxSlash)\n}\n\nfunction writeTextFile(filename: string, content: string) {\n    FS.writeFileSync(filename, content)\n}\n","module.exports = require(\"http\");","module.exports = require(\"fs\");","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\nvar warnings = require('./warnings-39684f17.js');\n\nfunction createMap(schema, obj, ctx) {\n  const map = new resolveSeq.YAMLMap(schema);\n\n  if (obj instanceof Map) {\n    for (const [key, value] of obj) map.items.push(schema.createPair(key, value, ctx));\n  } else if (obj && typeof obj === 'object') {\n    for (const key of Object.keys(obj)) map.items.push(schema.createPair(key, obj[key], ctx));\n  }\n\n  if (typeof schema.sortMapEntries === 'function') {\n    map.items.sort(schema.sortMapEntries);\n  }\n\n  return map;\n}\n\nconst map = {\n  createNode: createMap,\n  default: true,\n  nodeClass: resolveSeq.YAMLMap,\n  tag: 'tag:yaml.org,2002:map',\n  resolve: resolveSeq.resolveMap\n};\n\nfunction createSeq(schema, obj, ctx) {\n  const seq = new resolveSeq.YAMLSeq(schema);\n\n  if (obj && obj[Symbol.iterator]) {\n    for (const it of obj) {\n      const v = schema.createNode(it, ctx.wrapScalars, null, ctx);\n      seq.items.push(v);\n    }\n  }\n\n  return seq;\n}\n\nconst seq = {\n  createNode: createSeq,\n  default: true,\n  nodeClass: resolveSeq.YAMLSeq,\n  tag: 'tag:yaml.org,2002:seq',\n  resolve: resolveSeq.resolveSeq\n};\n\nconst string = {\n  identify: value => typeof value === 'string',\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveSeq.resolveString,\n\n  stringify(item, ctx, onComment, onChompKeep) {\n    ctx = Object.assign({\n      actualString: true\n    }, ctx);\n    return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);\n  },\n\n  options: resolveSeq.strOptions\n};\n\nconst failsafe = [map, seq, string];\n\n/* global BigInt */\n\nconst intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);\n\nconst intResolve = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);\n\nfunction intStringify(node, radix, prefix) {\n  const {\n    value\n  } = node;\n  if (intIdentify(value) && value >= 0) return prefix + value.toString(radix);\n  return resolveSeq.stringifyNumber(node);\n}\n\nconst nullObj = {\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: () => null,\n  options: resolveSeq.nullOptions,\n  stringify: () => resolveSeq.nullOptions.nullStr\n};\nconst boolObj = {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n  resolve: str => str[0] === 't' || str[0] === 'T',\n  options: resolveSeq.boolOptions,\n  stringify: ({\n    value\n  }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr\n};\nconst octObj = {\n  identify: value => intIdentify(value) && value >= 0,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^0o([0-7]+)$/,\n  resolve: (str, oct) => intResolve(str, oct, 8),\n  options: resolveSeq.intOptions,\n  stringify: node => intStringify(node, 8, '0o')\n};\nconst intObj = {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^[-+]?[0-9]+$/,\n  resolve: str => intResolve(str, str, 10),\n  options: resolveSeq.intOptions,\n  stringify: resolveSeq.stringifyNumber\n};\nconst hexObj = {\n  identify: value => intIdentify(value) && value >= 0,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^0x([0-9a-fA-F]+)$/,\n  resolve: (str, hex) => intResolve(str, hex, 16),\n  options: resolveSeq.intOptions,\n  stringify: node => intStringify(node, 16, '0x')\n};\nconst nanObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,\n  stringify: resolveSeq.stringifyNumber\n};\nconst expObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n  resolve: str => parseFloat(str),\n  stringify: ({\n    value\n  }) => Number(value).toExponential()\n};\nconst floatObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:\\.([0-9]+)|[0-9]+\\.([0-9]*))$/,\n\n  resolve(str, frac1, frac2) {\n    const frac = frac1 || frac2;\n    const node = new resolveSeq.Scalar(parseFloat(str));\n    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;\n    return node;\n  },\n\n  stringify: resolveSeq.stringifyNumber\n};\nconst core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);\n\n/* global BigInt */\n\nconst intIdentify$1 = value => typeof value === 'bigint' || Number.isInteger(value);\n\nconst stringifyJSON = ({\n  value\n}) => JSON.stringify(value);\n\nconst json = [map, seq, {\n  identify: value => typeof value === 'string',\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveSeq.resolveString,\n  stringify: stringifyJSON\n}, {\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^null$/,\n  resolve: () => null,\n  stringify: stringifyJSON\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^true|false$/,\n  resolve: str => str === 'true',\n  stringify: stringifyJSON\n}, {\n  identify: intIdentify$1,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^-?(?:0|[1-9][0-9]*)$/,\n  resolve: str => resolveSeq.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),\n  stringify: ({\n    value\n  }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n  resolve: str => parseFloat(str),\n  stringify: stringifyJSON\n}];\n\njson.scalarFallback = str => {\n  throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n};\n\n/* global BigInt */\n\nconst boolStringify = ({\n  value\n}) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;\n\nconst intIdentify$2 = value => typeof value === 'bigint' || Number.isInteger(value);\n\nfunction intResolve$1(sign, src, radix) {\n  let str = src.replace(/_/g, '');\n\n  if (resolveSeq.intOptions.asBigInt) {\n    switch (radix) {\n      case 2:\n        str = `0b${str}`;\n        break;\n\n      case 8:\n        str = `0o${str}`;\n        break;\n\n      case 16:\n        str = `0x${str}`;\n        break;\n    }\n\n    const n = BigInt(str);\n    return sign === '-' ? BigInt(-1) * n : n;\n  }\n\n  const n = parseInt(str, radix);\n  return sign === '-' ? -1 * n : n;\n}\n\nfunction intStringify$1(node, radix, prefix) {\n  const {\n    value\n  } = node;\n\n  if (intIdentify$2(value)) {\n    const str = value.toString(radix);\n    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n  }\n\n  return resolveSeq.stringifyNumber(node);\n}\n\nconst yaml11 = failsafe.concat([{\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: () => null,\n  options: resolveSeq.nullOptions,\n  stringify: () => resolveSeq.nullOptions.nullStr\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n  resolve: () => true,\n  options: resolveSeq.boolOptions,\n  stringify: boolStringify\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,\n  resolve: () => false,\n  options: resolveSeq.boolOptions,\n  stringify: boolStringify\n}, {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'BIN',\n  test: /^([-+]?)0b([0-1_]+)$/,\n  resolve: (str, sign, bin) => intResolve$1(sign, bin, 2),\n  stringify: node => intStringify$1(node, 2, '0b')\n}, {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^([-+]?)0([0-7_]+)$/,\n  resolve: (str, sign, oct) => intResolve$1(sign, oct, 8),\n  stringify: node => intStringify$1(node, 8, '0')\n}, {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^([-+]?)([0-9][0-9_]*)$/,\n  resolve: (str, sign, abs) => intResolve$1(sign, abs, 10),\n  stringify: resolveSeq.stringifyNumber\n}, {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,\n  resolve: (str, sign, hex) => intResolve$1(sign, hex, 16),\n  stringify: node => intStringify$1(node, 16, '0x')\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,\n  stringify: resolveSeq.stringifyNumber\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?([0-9][0-9_]*)?(\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n  resolve: str => parseFloat(str.replace(/_/g, '')),\n  stringify: ({\n    value\n  }) => Number(value).toExponential()\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:[0-9][0-9_]*)?\\.([0-9_]*)$/,\n\n  resolve(str, frac) {\n    const node = new resolveSeq.Scalar(parseFloat(str.replace(/_/g, '')));\n\n    if (frac) {\n      const f = frac.replace(/_/g, '');\n      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;\n    }\n\n    return node;\n  },\n\n  stringify: resolveSeq.stringifyNumber\n}], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);\n\nconst schemas = {\n  core,\n  failsafe,\n  json,\n  yaml11\n};\nconst tags = {\n  binary: warnings.binary,\n  bool: boolObj,\n  float: floatObj,\n  floatExp: expObj,\n  floatNaN: nanObj,\n  floatTime: warnings.floatTime,\n  int: intObj,\n  intHex: hexObj,\n  intOct: octObj,\n  intTime: warnings.intTime,\n  map,\n  null: nullObj,\n  omap: warnings.omap,\n  pairs: warnings.pairs,\n  seq,\n  set: warnings.set,\n  timestamp: warnings.timestamp\n};\n\nfunction findTagObject(value, tagName, tags) {\n  if (tagName) {\n    const match = tags.filter(t => t.tag === tagName);\n    const tagObj = match.find(t => !t.format) || match[0];\n    if (!tagObj) throw new Error(`Tag ${tagName} not found`);\n    return tagObj;\n  } // TODO: deprecate/remove class check\n\n\n  return tags.find(t => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);\n}\n\nfunction createNode(value, tagName, ctx) {\n  if (value instanceof resolveSeq.Node) return value;\n  const {\n    defaultPrefix,\n    onTagObj,\n    prevObjects,\n    schema,\n    wrapScalars\n  } = ctx;\n  if (tagName && tagName.startsWith('!!')) tagName = defaultPrefix + tagName.slice(2);\n  let tagObj = findTagObject(value, tagName, schema.tags);\n\n  if (!tagObj) {\n    if (typeof value.toJSON === 'function') value = value.toJSON();\n    if (typeof value !== 'object') return wrapScalars ? new resolveSeq.Scalar(value) : value;\n    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;\n  }\n\n  if (onTagObj) {\n    onTagObj(tagObj);\n    delete ctx.onTagObj;\n  } // Detect duplicate references to the same object & use Alias nodes for all\n  // after first. The `obj` wrapper allows for circular references to resolve.\n\n\n  const obj = {};\n\n  if (value && typeof value === 'object' && prevObjects) {\n    const prev = prevObjects.get(value);\n\n    if (prev) {\n      const alias = new resolveSeq.Alias(prev); // leaves source dirty; must be cleaned by caller\n\n      ctx.aliasNodes.push(alias); // defined along with prevObjects\n\n      return alias;\n    }\n\n    obj.value = value;\n    prevObjects.set(value, obj);\n  }\n\n  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;\n  if (tagName && obj.node instanceof resolveSeq.Node) obj.node.tag = tagName;\n  return obj.node;\n}\n\nfunction getSchemaTags(schemas, knownTags, customTags, schemaId) {\n  let tags = schemas[schemaId.replace(/\\W/g, '')]; // 'yaml-1.1' -> 'yaml11'\n\n  if (!tags) {\n    const keys = Object.keys(schemas).map(key => JSON.stringify(key)).join(', ');\n    throw new Error(`Unknown schema \"${schemaId}\"; use one of ${keys}`);\n  }\n\n  if (Array.isArray(customTags)) {\n    for (const tag of customTags) tags = tags.concat(tag);\n  } else if (typeof customTags === 'function') {\n    tags = customTags(tags.slice());\n  }\n\n  for (let i = 0; i < tags.length; ++i) {\n    const tag = tags[i];\n\n    if (typeof tag === 'string') {\n      const tagObj = knownTags[tag];\n\n      if (!tagObj) {\n        const keys = Object.keys(knownTags).map(key => JSON.stringify(key)).join(', ');\n        throw new Error(`Unknown custom tag \"${tag}\"; use one of ${keys}`);\n      }\n\n      tags[i] = tagObj;\n    }\n  }\n\n  return tags;\n}\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\n\nclass Schema {\n  // TODO: remove in v2\n  // TODO: remove in v2\n  constructor({\n    customTags,\n    merge,\n    schema,\n    sortMapEntries,\n    tags: deprecatedCustomTags\n  }) {\n    this.merge = !!merge;\n    this.name = schema;\n    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;\n    if (!customTags && deprecatedCustomTags) warnings.warnOptionDeprecation('tags', 'customTags');\n    this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);\n  }\n\n  createNode(value, wrapScalars, tagName, ctx) {\n    const baseCtx = {\n      defaultPrefix: Schema.defaultPrefix,\n      schema: this,\n      wrapScalars\n    };\n    const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;\n    return createNode(value, tagName, createCtx);\n  }\n\n  createPair(key, value, ctx) {\n    if (!ctx) ctx = {\n      wrapScalars: true\n    };\n    const k = this.createNode(key, ctx.wrapScalars, null, ctx);\n    const v = this.createNode(value, ctx.wrapScalars, null, ctx);\n    return new resolveSeq.Pair(k, v);\n  }\n\n}\n\nPlainValue._defineProperty(Schema, \"defaultPrefix\", PlainValue.defaultTagPrefix);\n\nPlainValue._defineProperty(Schema, \"defaultTags\", PlainValue.defaultTags);\n\nexports.Schema = Schema;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\n\n/* global atob, btoa, Buffer */\nconst binary = {\n  identify: value => value instanceof Uint8Array,\n  // Buffer inherits from Uint8Array\n  default: false,\n  tag: 'tag:yaml.org,2002:binary',\n\n  /**\n   * Returns a Buffer in node and an Uint8Array in browsers\n   *\n   * To use the resulting buffer as an image, you'll want to do something like:\n   *\n   *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n   *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n   */\n  resolve: (doc, node) => {\n    const src = resolveSeq.resolveString(doc, node);\n\n    if (typeof Buffer === 'function') {\n      return Buffer.from(src, 'base64');\n    } else if (typeof atob === 'function') {\n      // On IE 11, atob() can't handle newlines\n      const str = atob(src.replace(/[\\n\\r]/g, ''));\n      const buffer = new Uint8Array(str.length);\n\n      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);\n\n      return buffer;\n    } else {\n      const msg = 'This environment does not support reading binary tags; either Buffer or atob is required';\n      doc.errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    }\n  },\n  options: resolveSeq.binaryOptions,\n  stringify: ({\n    comment,\n    type,\n    value\n  }, ctx, onComment, onChompKeep) => {\n    let src;\n\n    if (typeof Buffer === 'function') {\n      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');\n    } else if (typeof btoa === 'function') {\n      let s = '';\n\n      for (let i = 0; i < value.length; ++i) s += String.fromCharCode(value[i]);\n\n      src = btoa(s);\n    } else {\n      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n    }\n\n    if (!type) type = resolveSeq.binaryOptions.defaultType;\n\n    if (type === PlainValue.Type.QUOTE_DOUBLE) {\n      value = src;\n    } else {\n      const {\n        lineWidth\n      } = resolveSeq.binaryOptions;\n      const n = Math.ceil(src.length / lineWidth);\n      const lines = new Array(n);\n\n      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n        lines[i] = src.substr(o, lineWidth);\n      }\n\n      value = lines.join(type === PlainValue.Type.BLOCK_LITERAL ? '\\n' : ' ');\n    }\n\n    return resolveSeq.stringifyString({\n      comment,\n      type,\n      value\n    }, ctx, onComment, onChompKeep);\n  }\n};\n\nfunction parsePairs(doc, cst) {\n  const seq = resolveSeq.resolveSeq(doc, cst);\n\n  for (let i = 0; i < seq.items.length; ++i) {\n    let item = seq.items[i];\n    if (item instanceof resolveSeq.Pair) continue;else if (item instanceof resolveSeq.YAMLMap) {\n      if (item.items.length > 1) {\n        const msg = 'Each pair must have its own sequence indicator';\n        throw new PlainValue.YAMLSemanticError(cst, msg);\n      }\n\n      const pair = item.items[0] || new resolveSeq.Pair();\n      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? `${item.commentBefore}\\n${pair.commentBefore}` : item.commentBefore;\n      if (item.comment) pair.comment = pair.comment ? `${item.comment}\\n${pair.comment}` : item.comment;\n      item = pair;\n    }\n    seq.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);\n  }\n\n  return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n  const pairs = new resolveSeq.YAMLSeq(schema);\n  pairs.tag = 'tag:yaml.org,2002:pairs';\n\n  for (const it of iterable) {\n    let key, value;\n\n    if (Array.isArray(it)) {\n      if (it.length === 2) {\n        key = it[0];\n        value = it[1];\n      } else throw new TypeError(`Expected [key, value] tuple: ${it}`);\n    } else if (it && it instanceof Object) {\n      const keys = Object.keys(it);\n\n      if (keys.length === 1) {\n        key = keys[0];\n        value = it[key];\n      } else throw new TypeError(`Expected { key: value } tuple: ${it}`);\n    } else {\n      key = it;\n    }\n\n    const pair = schema.createPair(key, value, ctx);\n    pairs.items.push(pair);\n  }\n\n  return pairs;\n}\nconst pairs = {\n  default: false,\n  tag: 'tag:yaml.org,2002:pairs',\n  resolve: parsePairs,\n  createNode: createPairs\n};\n\nclass YAMLOMap extends resolveSeq.YAMLSeq {\n  constructor() {\n    super();\n\n    PlainValue._defineProperty(this, \"add\", resolveSeq.YAMLMap.prototype.add.bind(this));\n\n    PlainValue._defineProperty(this, \"delete\", resolveSeq.YAMLMap.prototype.delete.bind(this));\n\n    PlainValue._defineProperty(this, \"get\", resolveSeq.YAMLMap.prototype.get.bind(this));\n\n    PlainValue._defineProperty(this, \"has\", resolveSeq.YAMLMap.prototype.has.bind(this));\n\n    PlainValue._defineProperty(this, \"set\", resolveSeq.YAMLMap.prototype.set.bind(this));\n\n    this.tag = YAMLOMap.tag;\n  }\n\n  toJSON(_, ctx) {\n    const map = new Map();\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const pair of this.items) {\n      let key, value;\n\n      if (pair instanceof resolveSeq.Pair) {\n        key = resolveSeq.toJSON(pair.key, '', ctx);\n        value = resolveSeq.toJSON(pair.value, key, ctx);\n      } else {\n        key = resolveSeq.toJSON(pair, '', ctx);\n      }\n\n      if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');\n      map.set(key, value);\n    }\n\n    return map;\n  }\n\n}\n\nPlainValue._defineProperty(YAMLOMap, \"tag\", 'tag:yaml.org,2002:omap');\n\nfunction parseOMap(doc, cst) {\n  const pairs = parsePairs(doc, cst);\n  const seenKeys = [];\n\n  for (const {\n    key\n  } of pairs.items) {\n    if (key instanceof resolveSeq.Scalar) {\n      if (seenKeys.includes(key.value)) {\n        const msg = 'Ordered maps must not include duplicate keys';\n        throw new PlainValue.YAMLSemanticError(cst, msg);\n      } else {\n        seenKeys.push(key.value);\n      }\n    }\n  }\n\n  return Object.assign(new YAMLOMap(), pairs);\n}\n\nfunction createOMap(schema, iterable, ctx) {\n  const pairs = createPairs(schema, iterable, ctx);\n  const omap = new YAMLOMap();\n  omap.items = pairs.items;\n  return omap;\n}\n\nconst omap = {\n  identify: value => value instanceof Map,\n  nodeClass: YAMLOMap,\n  default: false,\n  tag: 'tag:yaml.org,2002:omap',\n  resolve: parseOMap,\n  createNode: createOMap\n};\n\nclass YAMLSet extends resolveSeq.YAMLMap {\n  constructor() {\n    super();\n    this.tag = YAMLSet.tag;\n  }\n\n  add(key) {\n    const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);\n    const prev = resolveSeq.findPair(this.items, pair.key);\n    if (!prev) this.items.push(pair);\n  }\n\n  get(key, keepPair) {\n    const pair = resolveSeq.findPair(this.items, key);\n    return !keepPair && pair instanceof resolveSeq.Pair ? pair.key instanceof resolveSeq.Scalar ? pair.key.value : pair.key : pair;\n  }\n\n  set(key, value) {\n    if (typeof value !== 'boolean') throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n    const prev = resolveSeq.findPair(this.items, key);\n\n    if (prev && !value) {\n      this.items.splice(this.items.indexOf(prev), 1);\n    } else if (!prev && value) {\n      this.items.push(new resolveSeq.Pair(key));\n    }\n  }\n\n  toJSON(_, ctx) {\n    return super.toJSON(_, ctx, Set);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');\n  }\n\n}\n\nPlainValue._defineProperty(YAMLSet, \"tag\", 'tag:yaml.org,2002:set');\n\nfunction parseSet(doc, cst) {\n  const map = resolveSeq.resolveMap(doc, cst);\n  if (!map.hasAllNullValues()) throw new PlainValue.YAMLSemanticError(cst, 'Set items must all have null values');\n  return Object.assign(new YAMLSet(), map);\n}\n\nfunction createSet(schema, iterable, ctx) {\n  const set = new YAMLSet();\n\n  for (const value of iterable) set.items.push(schema.createPair(value, null, ctx));\n\n  return set;\n}\n\nconst set = {\n  identify: value => value instanceof Set,\n  nodeClass: YAMLSet,\n  default: false,\n  tag: 'tag:yaml.org,2002:set',\n  resolve: parseSet,\n  createNode: createSet\n};\n\nconst parseSexagesimal = (sign, parts) => {\n  const n = parts.split(':').reduce((n, p) => n * 60 + Number(p), 0);\n  return sign === '-' ? -n : n;\n}; // hhhh:mm:ss.sss\n\n\nconst stringifySexagesimal = ({\n  value\n}) => {\n  if (isNaN(value) || !isFinite(value)) return resolveSeq.stringifyNumber(value);\n  let sign = '';\n\n  if (value < 0) {\n    sign = '-';\n    value = Math.abs(value);\n  }\n\n  const parts = [value % 60]; // seconds, including ms\n\n  if (value < 60) {\n    parts.unshift(0); // at least one : is required\n  } else {\n    value = Math.round((value - parts[0]) / 60);\n    parts.unshift(value % 60); // minutes\n\n    if (value >= 60) {\n      value = Math.round((value - parts[0]) / 60);\n      parts.unshift(value); // hours\n    }\n  }\n\n  return sign + parts.map(n => n < 10 ? '0' + String(n) : String(n)).join(':').replace(/000000\\d*$/, '') // % 60 may introduce error\n  ;\n};\n\nconst intTime = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,\n  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),\n  stringify: stringifySexagesimal\n};\nconst floatTime = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*)$/,\n  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),\n  stringify: stringifySexagesimal\n};\nconst timestamp = {\n  identify: value => value instanceof Date,\n  default: true,\n  tag: 'tag:yaml.org,2002:timestamp',\n  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n  // may be omitted altogether, resulting in a date format. In such a case, the time part is\n  // assumed to be 00:00:00Z (start of day, UTC).\n  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n  '(?:(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n  '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n  ')?' + ')$'),\n  resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {\n    if (millisec) millisec = (millisec + '00').substr(1, 3);\n    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);\n\n    if (tz && tz !== 'Z') {\n      let d = parseSexagesimal(tz[0], tz.slice(1));\n      if (Math.abs(d) < 30) d *= 60;\n      date -= 60000 * d;\n    }\n\n    return new Date(date);\n  },\n  stringify: ({\n    value\n  }) => value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, '')\n};\n\n/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */\nfunction shouldWarn(deprecation) {\n  const env = typeof process !== 'undefined' && process.env || {};\n\n  if (deprecation) {\n    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;\n    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;\n  }\n\n  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;\n  return !env.YAML_SILENCE_WARNINGS;\n}\n\nfunction warn(warning, type) {\n  if (shouldWarn(false)) {\n    const emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to\n    // https://github.com/facebook/jest/issues/2549\n\n    if (emit) emit(warning, type);else {\n      // eslint-disable-next-line no-console\n      console.warn(type ? `${type}: ${warning}` : warning);\n    }\n  }\n}\nfunction warnFileDeprecation(filename) {\n  if (shouldWarn(true)) {\n    const path = filename.replace(/.*yaml[/\\\\]/i, '').replace(/\\.js$/, '').replace(/\\\\/g, '/');\n    warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, 'DeprecationWarning');\n  }\n}\nconst warned = {};\nfunction warnOptionDeprecation(name, alternative) {\n  if (!warned[name] && shouldWarn(true)) {\n    warned[name] = true;\n    let msg = `The option '${name}' will be removed in a future release`;\n    msg += alternative ? `, use '${alternative}' instead.` : '.';\n    warn(msg, 'DeprecationWarning');\n  }\n}\n\nexports.binary = binary;\nexports.floatTime = floatTime;\nexports.intTime = intTime;\nexports.omap = omap;\nexports.pairs = pairs;\nexports.set = set;\nexports.timestamp = timestamp;\nexports.warn = warn;\nexports.warnFileDeprecation = warnFileDeprecation;\nexports.warnOptionDeprecation = warnOptionDeprecation;\n","module.exports = require(\"https\");","// The module 'vscode' contains the VS Code extensibility API\n// tslint:disable-next-line: no-implicit-dependencies\nimport * as VSC from 'vscode'\nimport Util from './util'\nimport Fonts from './fonts'\nimport Translation from './translation'\n\n// this method is called when your extension is activated\nexport function activate(context: VSC.ExtensionContext) {\n    // The command has been defined in the package.json file\n    // Now provide the implementation of the command with registerCommand\n    // The commandId parameter must match the command field in package.json\n    const LEFT = 1\n    const RIGHT = 2\n    const actions: Array<[string, number]> = [\n        [\"css\", RIGHT],\n        [\"js\", LEFT],\n        [\"ts\", LEFT],\n        [\"tsx\", LEFT],\n        [\"json\", RIGHT],\n        [\"yaml\", RIGHT],\n        [\"frag\", LEFT],\n        [\"vert\", LEFT]\n    ]\n    for (const action of actions) {\n        const [extension, viewColumn] = action\n        const id = `toloframework-vscode-extension.switchTo${extension.toUpperCase()}`\n        const disposable = VSC.commands.registerCommand(\n            id,\n            () => switchTo(extension, viewColumn)\n        )\n        context.subscriptions.push(disposable)\n    }\n\n    context.subscriptions.push(\n        VSC.commands.registerCommand(\n            \"toloframework-vscode-extension.compileTranslationYAML\",\n            Translation.compileYAML\n        )\n    )\n\n    context.subscriptions.push(\n        VSC.commands.registerCommand(\n            \"toloframework-vscode-extension.importFont\",\n            Fonts.load\n        )\n    )\n\n    context.subscriptions.push(\n        VSC.commands.registerCommand(\n            'toloframework-vscode-extension.help',\n            () => {\n                const panel = VSC.window.createWebviewPanel(\n                    'help',\n                    'TFW Documentation',\n                    VSC.ViewColumn.Beside,\n                    {\n                        enableScripts: true,\n                        enableCommandUris: true\n                    }\n                )\n                panel.webview.html = `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <style>\n        html, body, iframe {\n            position: absolute;\n            left: 0;\n            top: 0;\n            bottom: 0;\n            right: 0;\n            border: none;\n            margin: 0;\n            padding: 0;\n        }\n    </style>\n</head>\n<body>\n    <iframe src=\"https://tolokoban.github.io/tfw\"></iframe>\n</body>\n</html>`\n            }\n        )\n    )\n}\n\n// this method is called when your extension is deactivated\n// tslint:disable-next-line: no-empty\nexport function deactivate() { }\n\n\nconst EXTENSION_FALLBACKS: { [key: string]: string[] } = {\n    tsx: [\"ts\", \"js\"],\n    ts: [\"tsx\", \"js\"],\n    js: [\"ts\", \"tsx\"],\n    json: [\"jsn\", \"yaml\", \"yml\"],\n    yaml: [\"yml\", \"json\", \"jsn\"]\n}\nasync function switchTo(extension: string, viewColumn: number) {\n    const activeEditor = VSC.window.activeTextEditor\n    if (!activeEditor) {\n        VSC.window.showErrorMessage(\"No active text editor!\")\n        return\n    }\n\n    if (await openFileIfExists(extension, viewColumn, activeEditor)) return\n\n    // File does not exist.\n    // We need to create it.\n    const filename: string = Util.changeExtension(\n        activeEditor.document.fileName,\n        extension\n    )\n    Util.writeTextFile(filename, getInitialContent(extension, activeEditor.document.fileName))\n    const doc = await Util.openTextDocument(filename)\n    if (doc !== null) {\n        VSC.window.showTextDocument(doc, { viewColumn })\n    } else {\n        VSC.window.showErrorMessage(\n            `File not found:  \\n\\`${filename}\\``\n        )\n    }\n}\n\nasync function openFileIfExists(\n    extension: string,\n    viewColumn: number,\n    activeEditor: VSC.TextEditor\n) {\n    const extensions: string[] = [extension]\n    const fallbacks = EXTENSION_FALLBACKS[extension]\n    if (Array.isArray(fallbacks)) {\n        extensions.push(...fallbacks)\n    }\n\n    for (const ext of extensions) {\n        const filename: string = Util.changeExtension(\n            activeEditor.document.fileName,\n            ext\n        )\n        if (!Util.exists(filename)) continue\n\n        const doc = await Util.openTextDocument(filename)\n        if (doc === null) return false\n        VSC.window.showTextDocument(doc, { viewColumn })\n        return true\n    }\n\n    return false\n}\n\nfunction getInitialContent(extension: string, originFileName: string) {\n    switch (extension) {\n        case \"yaml\": return getInitialContentYAML(originFileName)\n    }\n    return \"\"\n}\n\nfunction getInitialContentYAML(originFileName: string) {\n    return \"en:\\n    cancel: Cancel\\n    ok: Ok\\nfr:\\n    cancel: Annuler\\n    ok: Valider\\n\"\n}\n","export { default } from \"./fonts\"","// tslint:disable: await-promise\n// tslint:disable: no-implicit-dependencies\nimport * as X from 'vscode'\nimport * as FS from 'fs'\nimport * as Path from 'path'\nimport fetch from 'node-fetch'\nimport Util from '../util'\nimport Slicer from './slicer'\nimport { SSL_OP_MICROSOFT_SESS_ID_BUG } from 'constants'\n\nexport default {\n    load\n}\n\nasync function load() {\n    try {\n        const fontURL = await X.window.showInputBox({\n            prompt: \"Please enter the URL of the font CSS.\\nYou will find it after the @import directive.\",\n            value: \"https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap\"\n        })\n        if (!fontURL) return\n        const disposableMessage = X.window.setStatusBarMessage(`Fetching ${fontURL}`)\n        const asyncContentLoading = loadContentFromURL(fontURL)\n\n        const fontName = await X.window.showInputBox({\n            prompt: \"Please enter the font family name.\",\n            value: \"noto\",\n            validateInput: isKebabCase\n        })\n        if (!fontName) return\n        const cssContent = await asyncContentLoading\n        disposableMessage.dispose()\n        if (!cssContent) return\n\n        const asyncLoadAll = loadAllFonts(cssContent)\n\n        const defaultUri: X.Uri | undefined = getCurrentURI()\n        const uris = await X.window.showOpenDialog({\n            defaultUri,\n            canSelectFiles: false,\n            canSelectFolders: true,\n            canSelectMany: false,\n            openLabel: \"Select\",\n            title: \"Select a folder for the font\"\n        })\n        if (!uris) return\n        const uri = uris[0]\n        const path = Path.resolve(uri.path, fontName)\n        if (FS.existsSync(path)) {\n            X.window.showErrorMessage(\n                `This directory already exists:\\n${path}`,\n                { modal: true }\n            )\n            return\n        }\n        await X.workspace.fs.createDirectory(X.Uri.file(path))\n        const files = await asyncLoadAll\n        for (const fontFile of files.fonts) {\n            if (!fontFile.data) continue\n\n            FS.writeFileSync(\n                Path.resolve(path, fontFile.filename),\n                new Uint8Array(fontFile.data)\n            )\n        }\n        const cssFilename = Path.resolve(path, `${fontName}.css`)\n        FS.writeFileSync(cssFilename, files.css)\n        await Util.openFileInEditor(cssFilename, X.ViewColumn.Active)\n\n        const fontClassFilename = Path.resolve(path, \"..\", \"font.ts\")\n        if (FS.existsSync(fontClassFilename)) {\n            FS.writeFileSync(\n                Path.resolve(path, \"index.ts\"),\n                `export { default } from '${fontName}'\\n`\n            )\n            const modFilename = Path.resolve(path, `${fontName}.ts`)\n            FS.writeFileSync(\n                modFilename,\n                `import FontClass from '../font'\nimport './${fontName}.css'\n\n// @TODO Check the font name in the CSS file: \"${fontName}.css\"\nexport default new FontClass(\"${fontName}\")\n`\n            )\n            await Util.openFileInEditor(modFilename, X.ViewColumn.Beside)\n        } else {\n            X.window.showInformationMessage(fontClassFilename)\n        }\n    } catch (ex) {\n        X.window.showErrorMessage(\n            `${ex}`,\n            { modal: true }\n        )\n    }\n}\n\nfunction getCurrentURI(): X.Uri | undefined {\n    const editor = X.window.activeTextEditor\n    if (editor) {\n        const path: string = Path.dirname(editor.document.fileName)\n        return X.Uri.file(path)\n    }\n\n    const folders = X.workspace.workspaceFolders\n    if (!folders) return undefined\n    return folders[0].uri\n}\n\nconst RX_KEBAB_CASE = /^[a-z][a-z0-9]+(-[a-z0-9]+)*$/g\n\nfunction isKebabCase(input: string): string {\n    return RX_KEBAB_CASE.test(input) ? \"\" : \"Kebab case name expected! Minimum length is 2. Example: \\\"my-font\\\"\"\n}\n\nasync function loadContentFromURL(url: string): Promise<string> {\n    try {\n        const styleResponse = await fetch(url)\n        const styleContent = await styleResponse.text()\n        console.log(\"styleContent\", styleContent) // @TODO Remove this line written on 2020-09-23 at 12:04\n        return styleContent\n    } catch (ex) {\n        throw `Unable to load from URL \\\"${url}\\\"!\\n\\n${ex}`\n    }\n}\n\ninterface IFont {\n    data: ArrayBuffer | null\n    filename: string\n}\n\ninterface IAllFonts {\n    css: string,\n    fonts: IFont[]\n}\n\nasync function loadAllFonts(cssContent: string): Promise<IAllFonts> {\n    const slices = Slicer.slice(cssContent)\n\n    let disposableMessage = X.window.setStatusBarMessage(`Loading font files...`)\n    for (let i = 0; i < slices.urls.length; i++) {\n        const url = slices.urls[i]\n        try {\n            disposableMessage.dispose()\n            disposableMessage = X.window.setStatusBarMessage(`Loading font ${i + 1} / ${slices.urls.length}`)\n            const response = await fetch(url)\n            if (!response.ok) {\n                throw `Error ${response.status}: ${response.statusText}`\n            }\n            const arrayBuffer = await response.arrayBuffer()\n            slices.data.push(arrayBuffer)\n        } catch (ex) {\n            slices.data.push(null)\n            X.window.showErrorMessage(\n                `Unable to load font ${i + 1} / ${slices.urls.length}:\\n${url}\\n\\n${ex}`\n            )\n        }\n    }\n    disposableMessage.dispose()\n\n    return {\n        css: slices.pieces.map((piece, index) => {\n            if (typeof piece === 'number') {\n                return `./${piece}.${getExtension(slices.urls[piece])}`\n            }\n            return piece\n        }).join(\"\"),\n        fonts: slices.data.map((data, index) => ({\n            data,\n            filename: `${index}.${getExtension(slices.urls[index])}`\n        }))\n    }\n}\n\nfunction getExtension(filename: string): string {\n    const NOT_FOUND = -1\n    const dotIndex = filename.lastIndexOf(\".\")\n    if (dotIndex === NOT_FOUND) return \"\"\n    return filename.substr(dotIndex + 1)\n}","module.exports = require(\"path\");","import Stream from 'stream';\nimport http from 'http';\nimport Url from 'url';\nimport https from 'https';\nimport zlib from 'zlib';\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof Stream) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof Stream) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof Stream)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\t\tif (!res) {\n\t\t\tres = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\t\t\tif (res) {\n\t\t\t\tres.pop(); // drop last quote\n\t\t\t}\n\t\t}\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof Stream && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof Stream) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n\nconst streamDestructionSupported = 'destroy' in Stream.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parse_url(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parse_url(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parse_url(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\nconst resolve_url = Url.resolve;\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\trequest.body.destroy(error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\t\t\tfinalize();\n\t\t});\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tconst locationURL = location === null ? null : resolve_url(request.url, location);\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout,\n\t\t\t\t\t\t\tsize: request.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\nexport default fetch;\nexport { Headers, Request, Response, FetchError };\n","export default {\n    removeComments,\n    slice\n}\n\nconst NOT_FOUND = -1\n\ninterface ISlices {\n    urls: string[]\n    data: Array<ArrayBuffer | null>\n    pieces: Array<string | number>\n}\n\nfunction slice(cssContent: string): ISlices {\n    const urls: string[] = []\n    const pieces: Array<string | number> = []\n    const content = removeComments(cssContent)\n    let cursor = 0\n\n    while (true) {\n        const indexOpen = content.indexOf(\"url(\", cursor)\n        if (indexOpen === NOT_FOUND) {\n            pieces.push(content.substr(cursor))\n            break\n        }\n        pieces.push(content.substring(cursor, indexOpen + \"url(\".length))\n        const indexClose = content.indexOf(\")\", indexOpen + \"url(\".length)\n        if (indexClose === NOT_FOUND) break\n\n        pieces.push(urls.length)\n        const url = content.substring(indexOpen + \"url(\".length, indexClose)\n        urls.push(url)\n        cursor = indexClose\n    }\n\n    return { urls, pieces, data: [] }\n}\n\nfunction removeComments(content: string): string {\n    const pieces: string[] = []\n    let cursor = 0\n\n    while (true) {\n        const indexOpen = content.indexOf(\"/*\", cursor)\n        if (indexOpen === NOT_FOUND) {\n            pieces.push(content.substr(cursor))\n            break\n        }\n        pieces.push(content.substring(cursor, indexOpen))\n        const indexClose = content.indexOf(\"*/\", cursor + \"/*\".length)\n        if (indexClose === NOT_FOUND) break\n        cursor = indexClose + \"*/\".length\n    }\n\n    return pieces.join(\"\")\n}","// tslint:disable-next-line: no-implicit-dependencies\nimport * as VSC from 'vscode'\nimport * as YAML from 'yaml'\nimport { YAMLError, YAMLSemanticError } from 'yaml/util'\nimport Util from './util'\n\nexport default { compileYAML }\n\nconst DEFAULT_INDENTATION = \"    \"\nconst NOT_FOUND = -1\n\ninterface IYamlException {\n    name: string\n    source: string\n    message: string\n    makePretty(): string\n}\n\nfunction isYamlException(ex: any): ex is IYamlException {\n    if (!ex) return false\n    if (typeof ex !== 'object') return false\n    if (typeof (ex as { [key: string]: any }).makePretty !== 'function') return false\n    return true\n}\n\nasync function compileYAML() {\n    const activeEditor = VSC.window.activeTextEditor\n    if (!activeEditor) {\n        VSC.window.showErrorMessage(\"No active text editor!\")\n        return\n    }\n    const filename = activeEditor.document.fileName\n    if (!filename.endsWith(\".yaml\") && !filename.endsWith(\".yml\")) {\n        VSC.window.showErrorMessage(\"This is not a YAML file!\")\n        return\n    }\n\n    const content = activeEditor.document.getText().replace(\"\\t\", \"    \")\n    let value: any = null\n    try {\n        value = YAML.parse(\n            content, {\n            indent: 4,\n            prettyErrors: true\n        }\n        )\n    }\n    catch (ex) {\n        console.error(\"================================================================================\")\n        console.error(ex) // @TODO Remove this line written on 2020-09-18 at 12:05\n        let errorMessage = `Invalid YAML file!\\n${ex}`\n        if (ex instanceof YAMLSemanticError) {\n            errorMessage = `YAML Semantic Error at line ${ex.linePos?.start.line\n                }!\\n${ex.message\n                }\\n`\n        }\n        else if (ex instanceof YAMLError) {\n            errorMessage = `YAML Error!\\n${ex.message}\\n`\n        }\n        if (errorMessage.indexOf(\"cannot start with a tab character\") !== NOT_FOUND) {\n            errorMessage += \"\\nTry to execute the following command from the palette:\\n\"\n            errorMessage += '\"Convert indentation to spaces\"'\n        }\n        VSC.window.showErrorMessage(\n            errorMessage,\n            { modal: true }\n        )\n        return\n    }\n    const destination = Util.changeExtension(filename, \"json\")\n    Util.writeTextFile(\n        destination,\n        JSON.stringify(value, null, DEFAULT_INDENTATION)\n    )\n    await Util.openFileInEditor(destination)\n}\n","module.exports = require('./dist').YAML\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar parseCst = require('./parse-cst.js');\nrequire('./resolveSeq-4a68b39b.js');\nvar Document$1 = require('./Document-2cf6b08c.js');\nvar Schema = require('./Schema-42e9705c.js');\nvar warnings = require('./warnings-39684f17.js');\n\nfunction createNode(value, wrapScalars = true, tag) {\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  const options = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);\n  const schema = new Schema.Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nclass Document extends Document$1.Document {\n  constructor(options) {\n    super(Object.assign({}, Document$1.defaultOptions, options));\n  }\n\n}\n\nfunction parseAllDocuments(src, options) {\n  const stream = [];\n  let prev;\n\n  for (const cstDoc of parseCst.parse(src)) {\n    const doc = new Document(options);\n    doc.parse(cstDoc, prev);\n    stream.push(doc);\n    prev = doc;\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  const cst = parseCst.parse(src);\n  const doc = new Document(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    const errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  const doc = parseDocument(src, options);\n  doc.warnings.forEach(warning => warnings.warn(warning));\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify(value, options) {\n  const doc = new Document(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nconst YAML = {\n  createNode,\n  defaultOptions: Document$1.defaultOptions,\n  Document,\n  parse,\n  parseAllDocuments,\n  parseCST: parseCst.parse,\n  parseDocument,\n  scalarOptions: Document$1.scalarOptions,\n  stringify\n};\n\nexports.YAML = YAML;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nclass BlankLine extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  get includesTrailingLines() {\n    // This is never called from anywhere, but if it were,\n    // this is the value it should return.\n    return true;\n  }\n  /**\n   * Parses a blank line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first \\n character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    this.range = new PlainValue.Range(start, start + 1);\n    return start + 1;\n  }\n\n}\n\nclass CollectionItem extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.node = null;\n  }\n\n  get includesTrailingLines() {\n    return !!this.node && this.node.includesTrailingLines;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      atLineStart,\n      lineStart\n    } = context;\n    if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM) this.error = new PlainValue.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n    const indent = atLineStart ? start - lineStart : context.indent;\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    let ch = src[offset];\n    const inlineComment = ch === '#';\n    const comments = [];\n    let blankLine = null;\n\n    while (ch === '\\n' || ch === '#') {\n      if (ch === '#') {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        comments.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        atLineStart = true;\n        lineStart = offset + 1;\n        const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n        if (src[wsEnd] === '\\n' && comments.length === 0) {\n          blankLine = new BlankLine();\n          lineStart = blankLine.parse({\n            src\n          }, lineStart);\n        }\n\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n      }\n\n      ch = src[offset];\n    }\n\n    if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {\n      this.node = parseNode({\n        atLineStart,\n        inCollection: false,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n    } else if (ch && lineStart > start + 1) {\n      offset = lineStart - 1;\n    }\n\n    if (this.node) {\n      if (blankLine) {\n        // Only blank lines preceding non-empty nodes are captured. Note that\n        // this means that collection item range start indices do not always\n        // increase monotonically. -- eemeli/yaml#126\n        const items = context.parent.items || context.parent.contents;\n        if (items) items.push(blankLine);\n      }\n\n      if (comments.length) Array.prototype.push.apply(this.props, comments);\n      offset = this.node.range.end;\n    } else {\n      if (inlineComment) {\n        const c = comments[0];\n        this.props.push(c);\n        offset = c.end;\n      } else {\n        offset = PlainValue.Node.endOfLine(src, start + 1);\n      }\n    }\n\n    const end = this.node ? this.node.valueRange.end : offset;\n    this.valueRange = new PlainValue.Range(start, end);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      node,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Comment extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const offset = this.parseComment(start);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nfunction grabCollectionEndComments(node) {\n  let cnode = node;\n\n  while (cnode instanceof CollectionItem) cnode = cnode.node;\n\n  if (!(cnode instanceof Collection)) return null;\n  const len = cnode.items.length;\n  let ci = -1;\n\n  for (let i = len - 1; i >= 0; --i) {\n    const n = cnode.items[i];\n\n    if (n.type === PlainValue.Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      const {\n        indent,\n        lineStart\n      } = n.context;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === PlainValue.Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  const ca = cnode.items.splice(ci, len - ci);\n  const prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\nclass Collection extends PlainValue.Node {\n  static nextContentHasIndent(src, offset, indent) {\n    const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;\n    offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n    const ch = src[offset];\n    if (!ch) return false;\n    if (offset >= lineStart + indent) return true;\n    if (ch !== '#' && ch !== '\\n') return false;\n    return Collection.nextContentHasIndent(src, offset, indent);\n  }\n\n  constructor(firstItem) {\n    super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);\n\n    for (let i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        const itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    this.items = [firstItem];\n    const ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(this.items, ec);\n  }\n\n  get includesTrailingLines() {\n    return this.items.length > 0;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context; // It's easier to recalculate lineStart here rather than tracking down the\n    // last context from which to read it -- eemeli/yaml#2\n\n    let lineStart = PlainValue.Node.startOfLine(src, start);\n    const firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n    // -- eemeli/yaml#17\n\n    firstItem.context.parent = this;\n    this.valueRange = PlainValue.Range.copy(firstItem.valueRange);\n    const indent = firstItem.range.start - firstItem.context.lineStart;\n    let offset = start;\n    offset = PlainValue.Node.normalizeOffset(src, offset);\n    let ch = src[offset];\n    let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;\n    let prevIncludesTrailingLines = false;\n\n    while (ch) {\n      while (ch === '\\n' || ch === '#') {\n        if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n          const blankLine = new BlankLine();\n          offset = blankLine.parse({\n            src\n          }, offset);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n\n          this.items.push(blankLine);\n          offset -= 1; // blankLine.parse() consumes terminal newline\n        } else if (ch === '#') {\n          if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n            return offset;\n          }\n\n          const comment = new Comment();\n          offset = comment.parse({\n            indent,\n            lineStart,\n            src\n          }, offset);\n          this.items.push(comment);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n        }\n\n        lineStart = offset + 1;\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n        if (PlainValue.Node.atBlank(src, offset)) {\n          const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);\n          const next = src[wsEnd];\n\n          if (!next || next === '\\n' || next === '#') {\n            offset = wsEnd;\n          }\n        }\n\n        ch = src[offset];\n        atLineStart = true;\n      }\n\n      if (!ch) {\n        break;\n      }\n\n      if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n        if (offset < lineStart + indent) {\n          if (lineStart > start) offset = lineStart;\n          break;\n        } else if (!this.error) {\n          const msg = 'All collection items must start at the same column';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      if (firstItem.type === PlainValue.Type.SEQ_ITEM) {\n        if (ch !== '-') {\n          if (lineStart > start) offset = lineStart;\n          break;\n        }\n      } else if (ch === '-' && !this.error) {\n        // map key may start with -, as long as it's followed by a non-whitespace char\n        const next = src[offset + 1];\n\n        if (!next || next === '\\n' || next === '\\t' || next === ' ') {\n          const msg = 'A collection cannot be both a mapping and a sequence';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      const node = parseNode({\n        atLineStart,\n        inCollection: true,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n      if (!node) return offset; // at next document start\n\n      this.items.push(node);\n      this.valueRange.end = node.valueRange.end;\n      offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n      ch = src[offset];\n      atLineStart = false;\n      prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n      // has advanced to check the current line's indentation level\n      // -- eemeli/yaml#10 & eemeli/yaml#38\n\n      if (ch) {\n        let ls = offset - 1;\n        let prev = src[ls];\n\n        while (prev === ' ' || prev === '\\t') prev = src[--ls];\n\n        if (prev === '\\n') {\n          lineStart = ls + 1;\n          atLineStart = true;\n        }\n      }\n\n      const ec = grabCollectionEndComments(node);\n      if (ec) Array.prototype.push.apply(this.items, ec);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n    for (let i = 1; i < items.length; ++i) {\n      const item = items[i];\n      const {\n        atLineStart,\n        indent\n      } = item.context;\n      if (atLineStart) for (let i = 0; i < indent; ++i) str += ' ';\n      str += String(item);\n    }\n\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Directive extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.DIRECTIVE);\n    this.name = null;\n  }\n\n  get parameters() {\n    const raw = this.rawValue;\n    return raw ? raw.trim().split(/[ \\t]+/) : [];\n  }\n\n  parseName(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') ch = src[offset += 1];\n\n    this.name = src.slice(start, offset);\n    return offset;\n  }\n\n  parseParameters(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '#') ch = src[offset += 1];\n\n    this.valueRange = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n  parse(context, start) {\n    this.context = context;\n    let offset = this.parseName(start + 1);\n    offset = this.parseParameters(offset);\n    offset = this.parseComment(offset);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nclass Document extends PlainValue.Node {\n  static startCommentOrEndBlankLine(src, start) {\n    const offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    const ch = src[offset];\n    return ch === '#' || ch === '\\n' ? offset : start;\n  }\n\n  constructor() {\n    super(PlainValue.Type.DOCUMENT);\n    this.directives = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.documentEndMarker = null;\n  }\n\n  parseDirectives(start) {\n    const {\n      src\n    } = this.context;\n    this.directives = [];\n    let atLineStart = true;\n    let hasDirectives = false;\n    let offset = start;\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.directives.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.directives.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        case '%':\n          {\n            const directive = new Directive();\n            offset = directive.parse({\n              parent: this,\n              src\n            }, offset);\n            this.directives.push(directive);\n            hasDirectives = true;\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          if (hasDirectives) {\n            this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n          } else if (this.directives.length > 0) {\n            this.contents = this.directives;\n            this.directives = [];\n          }\n\n          return offset;\n      }\n    }\n\n    if (src[offset]) {\n      this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);\n      return offset + 3;\n    }\n\n    if (hasDirectives) {\n      this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n    } else if (this.directives.length > 0) {\n      this.contents = this.directives;\n      this.directives = [];\n    }\n\n    return offset;\n  }\n\n  parseContents(start) {\n    const {\n      parseNode,\n      src\n    } = this.context;\n    if (!this.contents) this.contents = [];\n    let lineStart = start;\n\n    while (src[lineStart - 1] === '-') lineStart -= 1;\n\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    let atLineStart = lineStart === start;\n    this.valueRange = new PlainValue.Range(offset);\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.contents.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          lineStart = offset;\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.contents.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          {\n            const iEnd = PlainValue.Node.endOfIndent(src, offset);\n            const context = {\n              atLineStart,\n              indent: -1,\n              inFlow: false,\n              inCollection: false,\n              lineStart,\n              parent: this\n            };\n            const node = parseNode(context, iEnd);\n            if (!node) return this.valueRange.end = iEnd; // at next document start\n\n            this.contents.push(node);\n            offset = node.range.end;\n            atLineStart = false;\n            const ec = grabCollectionEndComments(node);\n            if (ec) Array.prototype.push.apply(this.contents, ec);\n          }\n      }\n\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n    }\n\n    this.valueRange.end = offset;\n\n    if (src[offset]) {\n      this.documentEndMarker = new PlainValue.Range(offset, offset + 3);\n      offset += 3;\n\n      if (src[offset]) {\n        offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n\n        if (src[offset] === '#') {\n          const comment = new Comment();\n          offset = comment.parse({\n            src\n          }, offset);\n          this.contents.push(comment);\n        }\n\n        switch (src[offset]) {\n          case '\\n':\n            offset += 1;\n            break;\n\n          case undefined:\n            break;\n\n          default:\n            this.error = new PlainValue.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n        }\n      }\n    }\n\n    return offset;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    context.root = this;\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n    offset = this.parseDirectives(offset);\n    offset = this.parseContents(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.directives.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n    this.contents.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n    return offset;\n  }\n\n  toString() {\n    const {\n      contents,\n      directives,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = directives.join('');\n\n    if (contents.length > 0) {\n      if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT) str += '---\\n';\n      str += contents.join('');\n    }\n\n    if (str[str.length - 1] !== '\\n') str += '\\n';\n    return str;\n  }\n\n}\n\nclass Alias extends PlainValue.Node {\n  /**\n   * Parses an *alias from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = PlainValue.Node.endOfIdentifier(src, start + 1);\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nconst Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\nclass BlockValue extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.blockIndent = null;\n    this.chomping = Chomp.CLIP;\n    this.header = null;\n  }\n\n  get includesTrailingLines() {\n    return this.chomping === Chomp.KEEP;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (this.valueRange.isEmpty()) return '';\n    let lastNewLine = null;\n    let ch = src[end - 1];\n\n    while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n      end -= 1;\n\n      if (end <= start) {\n        if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n      }\n\n      if (ch === '\\n') lastNewLine = end;\n      ch = src[end - 1];\n    }\n\n    let keepStart = end + 1;\n\n    if (lastNewLine) {\n      if (this.chomping === Chomp.KEEP) {\n        keepStart = lastNewLine;\n        end = this.valueRange.end;\n      } else {\n        end = lastNewLine;\n      }\n    }\n\n    const bi = indent + this.blockIndent;\n    const folded = this.type === PlainValue.Type.BLOCK_FOLDED;\n    let atStart = true;\n    let str = '';\n    let sep = '';\n    let prevMoreIndented = false;\n\n    for (let i = start; i < end; ++i) {\n      for (let j = 0; j < bi; ++j) {\n        if (src[i] !== ' ') break;\n        i += 1;\n      }\n\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (sep === '\\n') str += '\\n';else sep = '\\n';\n      } else {\n        const lineEnd = PlainValue.Node.endOfLine(src, i);\n        const line = src.slice(i, lineEnd);\n        i = lineEnd;\n\n        if (folded && (ch === ' ' || ch === '\\t') && i < keepStart) {\n          if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n          str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n          sep = lineEnd < end && src[lineEnd] || '';\n          prevMoreIndented = true;\n        } else {\n          str += sep + line;\n          sep = folded && i < keepStart ? ' ' : '\\n';\n          prevMoreIndented = false;\n        }\n\n        if (atStart && line !== '') atStart = false;\n      }\n    }\n\n    return this.chomping === Chomp.STRIP ? str : str + '\\n';\n  }\n\n  parseBlockHeader(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start + 1;\n    let bi = '';\n\n    while (true) {\n      const ch = src[offset];\n\n      switch (ch) {\n        case '-':\n          this.chomping = Chomp.STRIP;\n          break;\n\n        case '+':\n          this.chomping = Chomp.KEEP;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          bi += ch;\n          break;\n\n        default:\n          this.blockIndent = Number(bi) || null;\n          this.header = new PlainValue.Range(start, offset);\n          return offset;\n      }\n\n      offset += 1;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      src\n    } = this.context;\n    const explicit = !!this.blockIndent;\n    let offset = start;\n    let valueEnd = start;\n    let minBlockIndent = 1;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      offset += 1;\n      if (PlainValue.Node.atDocumentBoundary(src, offset)) break;\n      const end = PlainValue.Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n      if (end === null) break;\n      const ch = src[end];\n      const lineIndent = end - (offset + indent);\n\n      if (!this.blockIndent) {\n        // no explicit block indent, none yet detected\n        if (src[end] !== '\\n') {\n          // first line with non-whitespace content\n          if (lineIndent < minBlockIndent) {\n            const msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n            this.error = new PlainValue.YAMLSemanticError(this, msg);\n          }\n\n          this.blockIndent = lineIndent;\n        } else if (lineIndent > minBlockIndent) {\n          // empty line with more whitespace\n          minBlockIndent = lineIndent;\n        }\n      } else if (ch && ch !== '\\n' && lineIndent < this.blockIndent) {\n        if (src[end] === '#') break;\n\n        if (!this.error) {\n          const src = explicit ? 'explicit indentation indicator' : 'first line';\n          const msg = `Block scalars must not be less indented than their ${src}`;\n          this.error = new PlainValue.YAMLSemanticError(this, msg);\n        }\n      }\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        offset = valueEnd = PlainValue.Node.endOfLine(src, end);\n      }\n    }\n\n    if (this.chomping !== Chomp.KEEP) {\n      offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n    }\n\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    return offset;\n  }\n  /**\n   * Parses a block value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * BS\n   * block\n   * lines\n   *\n   * BS #comment\n   * block\n   * lines\n   * ```\n   * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n   * are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this block\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = this.parseBlockHeader(start);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    offset = this.parseBlockValue(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.header ? this.header.setOrigRange(cr, offset) : offset;\n  }\n\n}\n\nclass FlowCollection extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.items = null;\n  }\n\n  prevNodeIsJsonLike(idx = this.items.length) {\n    const node = this.items[idx - 1];\n    return !!node && (node.jsonLike || node.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      indent,\n      lineStart\n    } = context;\n    let char = src[start]; // { or [\n\n    this.items = [{\n      char,\n      offset: start\n    }];\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    char = src[offset];\n\n    while (char && char !== ']' && char !== '}') {\n      switch (char) {\n        case '\\n':\n          {\n            lineStart = offset + 1;\n            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n            if (src[wsEnd] === '\\n') {\n              const blankLine = new BlankLine();\n              lineStart = blankLine.parse({\n                src\n              }, lineStart);\n              this.items.push(blankLine);\n            }\n\n            offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n            if (offset <= lineStart + indent) {\n              char = src[offset];\n\n              if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                const msg = 'Insufficient indentation in flow collection';\n                this.error = new PlainValue.YAMLSemanticError(this, msg);\n              }\n            }\n          }\n          break;\n\n        case ',':\n          {\n            this.items.push({\n              char,\n              offset\n            });\n            offset += 1;\n          }\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.items.push(comment);\n          }\n          break;\n\n        case '?':\n        case ':':\n          {\n            const next = src[offset + 1];\n\n            if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n            char === ':' && this.prevNodeIsJsonLike()) {\n              this.items.push({\n                char,\n                offset\n              });\n              offset += 1;\n              break;\n            }\n          }\n        // fallthrough\n\n        default:\n          {\n            const node = parseNode({\n              atLineStart: false,\n              inCollection: false,\n              inFlow: true,\n              indent: -1,\n              lineStart,\n              parent: this\n            }, offset);\n\n            if (!node) {\n              // at next document start\n              this.valueRange = new PlainValue.Range(start, offset);\n              return offset;\n            }\n\n            this.items.push(node);\n            offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n          }\n      }\n\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n      char = src[offset];\n    }\n\n    this.valueRange = new PlainValue.Range(start, offset + 1);\n\n    if (char) {\n      this.items.push({\n        char,\n        offset\n      });\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);\n      offset = this.parseComment(offset);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      if (node instanceof PlainValue.Node) {\n        offset = node.setOrigRanges(cr, offset);\n      } else if (cr.length === 0) {\n        node.origOffset = node.offset;\n      } else {\n        let i = offset;\n\n        while (i < cr.length) {\n          if (cr[i] > node.offset) break;else ++i;\n        }\n\n        node.origOffset = node.offset + i;\n        offset = i;\n      }\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const nodes = items.filter(item => item instanceof PlainValue.Node);\n    let str = '';\n    let prevEnd = range.start;\n    nodes.forEach(node => {\n      const prefix = src.slice(prevEnd, node.range.start);\n      prevEnd = node.range.end;\n      str += prefix + String(node);\n\n      if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n        // Comment range does not include the terminal newline, but its\n        // stringified value does. Without this fix, newlines at comment ends\n        // get duplicated.\n        prevEnd += 1;\n      }\n    });\n    str += src.slice(prevEnd, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass QuoteDouble extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\"') {\n      offset += ch === '\\\\' ? 2 : 1;\n      ch = src[offset];\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== '\"') errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n    // escaped backslashes; also, this should be faster.\n\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n      } else if (ch === '\\\\') {\n        i += 1;\n\n        switch (src[i]) {\n          case '0':\n            str += '\\0';\n            break;\n          // null character\n\n          case 'a':\n            str += '\\x07';\n            break;\n          // bell character\n\n          case 'b':\n            str += '\\b';\n            break;\n          // backspace\n\n          case 'e':\n            str += '\\x1b';\n            break;\n          // escape character\n\n          case 'f':\n            str += '\\f';\n            break;\n          // form feed\n\n          case 'n':\n            str += '\\n';\n            break;\n          // line feed\n\n          case 'r':\n            str += '\\r';\n            break;\n          // carriage return\n\n          case 't':\n            str += '\\t';\n            break;\n          // horizontal tab\n\n          case 'v':\n            str += '\\v';\n            break;\n          // vertical tab\n\n          case 'N':\n            str += '\\u0085';\n            break;\n          // Unicode next line\n\n          case '_':\n            str += '\\u00a0';\n            break;\n          // Unicode non-breaking space\n\n          case 'L':\n            str += '\\u2028';\n            break;\n          // Unicode line separator\n\n          case 'P':\n            str += '\\u2029';\n            break;\n          // Unicode paragraph separator\n\n          case ' ':\n            str += ' ';\n            break;\n\n          case '\"':\n            str += '\"';\n            break;\n\n          case '/':\n            str += '/';\n            break;\n\n          case '\\\\':\n            str += '\\\\';\n            break;\n\n          case '\\t':\n            str += '\\t';\n            break;\n\n          case 'x':\n            str += this.parseCharCode(i + 1, 2, errors);\n            i += 2;\n            break;\n\n          case 'u':\n            str += this.parseCharCode(i + 1, 4, errors);\n            i += 4;\n            break;\n\n          case 'U':\n            str += this.parseCharCode(i + 1, 8, errors);\n            i += 8;\n            break;\n\n          case '\\n':\n            // skip escaped newlines, but still trim the following line\n            while (src[i + 1] === ' ' || src[i + 1] === '\\t') i += 1;\n\n            break;\n\n          default:\n            errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));\n            str += '\\\\' + src[i];\n        }\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n\n  parseCharCode(offset, length, errors) {\n    const {\n      src\n    } = this.context;\n    const cc = src.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n\n    if (isNaN(code)) {\n      errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));\n      return src.substr(offset - 2, length + 2);\n    }\n\n    return String.fromCodePoint(code);\n  }\n  /**\n   * Parses a \"double quoted\" value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteDouble.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nclass QuoteSingle extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch) {\n      if (ch === \"'\") {\n        if (src[offset + 1] !== \"'\") break;\n        ch = src[offset += 2];\n      } else {\n        ch = src[offset += 1];\n      }\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, \"Missing closing 'quote\"));\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n      } else if (ch === \"'\") {\n        str += ch;\n        i += 1;\n        if (src[i] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n  /**\n   * Parses a 'single quoted' value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteSingle.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case PlainValue.Type.ALIAS:\n      return new Alias(type, props);\n\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case PlainValue.Type.MAP_KEY:\n    case PlainValue.Type.MAP_VALUE:\n    case PlainValue.Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case PlainValue.Type.COMMENT:\n    case PlainValue.Type.PLAIN:\n      return new PlainValue.PlainValue(type, props);\n\n    case PlainValue.Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case PlainValue.Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nclass ParseContext {\n  static parseType(src, offset, inFlow) {\n    switch (src[offset]) {\n      case '*':\n        return PlainValue.Type.ALIAS;\n\n      case '>':\n        return PlainValue.Type.BLOCK_FOLDED;\n\n      case '|':\n        return PlainValue.Type.BLOCK_LITERAL;\n\n      case '{':\n        return PlainValue.Type.FLOW_MAP;\n\n      case '[':\n        return PlainValue.Type.FLOW_SEQ;\n\n      case '?':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;\n\n      case ':':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;\n\n      case '-':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;\n\n      case '\"':\n        return PlainValue.Type.QUOTE_DOUBLE;\n\n      case \"'\":\n        return PlainValue.Type.QUOTE_SINGLE;\n\n      default:\n        return PlainValue.Type.PLAIN;\n    }\n  }\n\n  constructor(orig = {}, {\n    atLineStart,\n    inCollection,\n    inFlow,\n    indent,\n    lineStart,\n    parent\n  } = {}) {\n    PlainValue._defineProperty(this, \"parseNode\", (overlay, start) => {\n      if (PlainValue.Node.atDocumentBoundary(this.src, start)) return null;\n      const context = new ParseContext(this, overlay);\n      const {\n        props,\n        type,\n        valueStart\n      } = context.parseProps(start);\n      const node = createNewNode(type, props);\n      let offset = node.parse(context, valueStart);\n      node.range = new PlainValue.Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(`Node#parse consumed no characters`);\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {\n          node.error = new PlainValue.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        const collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new PlainValue.Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  nodeStartsCollection(node) {\n    const {\n      inCollection,\n      inFlow,\n      src\n    } = this;\n    if (inCollection || inFlow) return false;\n    if (node instanceof CollectionItem) return true; // check for implicit key\n\n    let offset = node.range.end;\n    if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    return src[offset] === ':';\n  } // Anchor and tag are before type, which determines the node implementation\n  // class; hence this intermediate step.\n\n\n  parseProps(offset) {\n    const {\n      inFlow,\n      parent,\n      src\n    } = this;\n    const props = [];\n    let lineHasProps = false;\n    offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);\n    let ch = src[offset];\n\n    while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === '\\n') {\n      if (ch === '\\n') {\n        const lineStart = offset + 1;\n        const inEnd = PlainValue.Node.endOfIndent(src, lineStart);\n        const indentDiff = inEnd - (lineStart + this.indent);\n        const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;\n        if (!PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n        this.atLineStart = true;\n        this.lineStart = lineStart;\n        lineHasProps = false;\n        offset = inEnd;\n      } else if (ch === PlainValue.Char.COMMENT) {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        props.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        let end = PlainValue.Node.endOfIdentifier(src, offset + 1);\n\n        if (ch === PlainValue.Char.TAG && src[end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, end + 13))) {\n          // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n          // than an empty but 'foo.bar' private-tagged node in a flow collection\n          // followed without whitespace by a plain string starting with a year\n          // or date divided by something.\n          end = PlainValue.Node.endOfIdentifier(src, end + 5);\n        }\n\n        props.push(new PlainValue.Range(offset, end));\n        lineHasProps = true;\n        offset = PlainValue.Node.endOfWhiteSpace(src, end);\n      }\n\n      ch = src[offset];\n    } // '- &a : b' has an anchor on an empty node\n\n\n    if (lineHasProps && ch === ':' && PlainValue.Node.atBlank(src, offset + 1, true)) offset -= 1;\n    const type = ParseContext.parseType(src, offset, inFlow);\n    return {\n      props,\n      type,\n      valueStart: offset\n    };\n  }\n  /**\n   * Parses a node from the source\n   * @param {ParseContext} overlay\n   * @param {number} start - Index of first non-whitespace character for the node\n   * @returns {?Node} - null if at a document boundary\n   */\n\n\n}\n\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n  const cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, (match, offset) => {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  const documents = [];\n  let offset = 0;\n\n  do {\n    const doc = new Document();\n    const context = new ParseContext({\n      src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = () => {\n    if (cr.length === 0) return false;\n\n    for (let i = 1; i < cr.length; ++i) cr[i] -= i;\n\n    let crOffset = 0;\n\n    for (let i = 0; i < documents.length; ++i) {\n      crOffset = documents[i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = () => documents.join('...\\n');\n\n  return documents;\n}\n\nexports.parse = parse;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\nvar Schema = require('./Schema-42e9705c.js');\n\nconst defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nconst scalarOptions = {\n  get binary() {\n    return resolveSeq.binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(resolveSeq.binaryOptions, opt);\n  },\n\n  get bool() {\n    return resolveSeq.boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(resolveSeq.boolOptions, opt);\n  },\n\n  get int() {\n    return resolveSeq.intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(resolveSeq.intOptions, opt);\n  },\n\n  get null() {\n    return resolveSeq.nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(resolveSeq.nullOptions, opt);\n  },\n\n  get str() {\n    return resolveSeq.strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(resolveSeq.strOptions, opt);\n  }\n\n};\nconst documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: PlainValue.defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  '1.1': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  },\n  '1.2': {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    const priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`;\n  }\n\n  let p = doc.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);\n\n  if (!p) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);\n  }\n\n  if (!p) return tag[0] === '!' ? tag : `!<${tag}>`;\n  const suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, ch => ({\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n  })[ch]);\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;\n\n  if (item.tag) {\n    const match = tags.filter(t => t.tag === item.tag);\n    if (match.length > 0) return match.find(t => t.format === item.format) || match[0];\n  }\n\n  let tagObj, obj;\n\n  if (item instanceof resolveSeq.Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    const match = tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);\n    tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);\n  } else {\n    obj = item;\n    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n  }\n\n  if (!tagObj) {\n    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;\n    throw new Error(`Tag not resolved for ${name} value`);\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, {\n  anchors,\n  doc\n}) {\n  const props = [];\n  const anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(`&${anchor}`);\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify(item, ctx, onComment, onChompKeep) {\n  const {\n    anchors,\n    schema\n  } = ctx.doc;\n  let tagObj;\n\n  if (!(item instanceof resolveSeq.Node)) {\n    const createCtx = {\n      aliasNodes: [],\n      onTagObj: o => tagObj = o,\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    for (const alias of createCtx.aliasNodes) {\n      alias.source = alias.source.node;\n      let name = anchors.getName(alias.source);\n\n      if (!name) {\n        name = anchors.newName();\n        anchors.map[name] = alias.source;\n      }\n    }\n  }\n\n  if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  const props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof resolveSeq.Scalar || str[0] === '{' || str[0] === '[' ? `${props} ${str}` : `${props}\\n${ctx.indent}${str}`;\n}\n\nclass Anchors {\n  static validAnchorNode(node) {\n    return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;\n  }\n\n  constructor(prefix) {\n    PlainValue._defineProperty(this, \"map\", {});\n\n    this.prefix = prefix;\n  }\n\n  createAlias(node, name) {\n    this.setAnchor(node, name);\n    return new resolveSeq.Alias(node);\n  }\n\n  createMergePair(...sources) {\n    const merge = new resolveSeq.Merge();\n    merge.value.items = sources.map(s => {\n      if (s instanceof resolveSeq.Alias) {\n        if (s.source instanceof resolveSeq.YAMLMap) return s;\n      } else if (s instanceof resolveSeq.YAMLMap) {\n        return this.createAlias(s);\n      }\n\n      throw new Error('Merge sources must be Map nodes or their Aliases');\n    });\n    return merge;\n  }\n\n  getName(node) {\n    const {\n      map\n    } = this;\n    return Object.keys(map).find(a => map[a] === node);\n  }\n\n  getNames() {\n    return Object.keys(this.map);\n  }\n\n  getNode(name) {\n    return this.map[name];\n  }\n\n  newName(prefix) {\n    if (!prefix) prefix = this.prefix;\n    const names = Object.keys(this.map);\n\n    for (let i = 1; true; ++i) {\n      const name = `${prefix}${i}`;\n      if (!names.includes(name)) return name;\n    }\n  } // During parsing, map & aliases contain CST nodes\n\n\n  resolveNodes() {\n    const {\n      map,\n      _cstAliases\n    } = this;\n    Object.keys(map).forEach(a => {\n      map[a] = map[a].resolved;\n    });\n\n    _cstAliases.forEach(a => {\n      a.source = a.source.resolved;\n    });\n\n    delete this._cstAliases;\n  }\n\n  setAnchor(node, name) {\n    if (node != null && !Anchors.validAnchorNode(node)) {\n      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n    }\n\n    if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n      throw new Error('Anchor names must not contain whitespace or control characters');\n    }\n\n    const {\n      map\n    } = this;\n    const prev = node && Object.keys(map).find(a => map[a] === node);\n\n    if (prev) {\n      if (!name) {\n        return prev;\n      } else if (prev !== name) {\n        delete map[prev];\n        map[name] = node;\n      }\n    } else {\n      if (!name) {\n        if (!node) return null;\n        name = this.newName();\n      }\n\n      map[name] = node;\n    }\n\n    return name;\n  }\n\n}\n\nconst visit = (node, tags) => {\n  if (node && typeof node === 'object') {\n    const {\n      tag\n    } = node;\n\n    if (node instanceof resolveSeq.Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(n => visit(n, tags));\n    } else if (node instanceof resolveSeq.Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof resolveSeq.Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nconst listTagNames = node => Object.keys(visit(node, {}));\n\nfunction parseContents(doc, contents) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let body = undefined;\n  let spaceBefore = false;\n\n  for (const node of contents) {\n    if (node.valueRange) {\n      if (body !== undefined) {\n        const msg = 'Document contains trailing content not separated by a ... or --- line';\n        doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n        break;\n      }\n\n      const res = resolveSeq.resolveNode(doc, node);\n\n      if (spaceBefore) {\n        res.spaceBefore = true;\n        spaceBefore = false;\n      }\n\n      body = res;\n    } else if (node.comment !== null) {\n      const cc = body === undefined ? comments.before : comments.after;\n      cc.push(node.comment);\n    } else if (node.type === PlainValue.Type.BLANK_LINE) {\n      spaceBefore = true;\n\n      if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n        // space-separated comments at start are parsed as document comments\n        doc.commentBefore = comments.before.join('\\n');\n        comments.before = [];\n      }\n    }\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? `${cb}\\n${cbNode.commentBefore}` : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective({\n  tagPrefixes\n}, directive) {\n  const [handle, prefix] = directive.parameters;\n\n  if (!handle || !prefix) {\n    const msg = 'Insufficient parameters given for %TAG directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(p => p.handle === handle)) {\n    const msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  return {\n    handle,\n    prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  let [version] = directive.parameters;\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    const msg = 'Insufficient parameters given for %YAML directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    const v0 = doc.version || doc.options.version;\n    const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  const directiveComments = [];\n  let hasDirectives = false;\n\n  for (const directive of directives) {\n    const {\n      comment,\n      name\n    } = directive;\n\n    switch (name) {\n      case 'TAG':\n        try {\n          doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      case 'YAML':\n      case 'YAML:1.0':\n        if (doc.version) {\n          const msg = 'The %YAML directive must only be given at most once per document.';\n          doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));\n        }\n\n        try {\n          doc.version = resolveYamlDirective(doc, directive);\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      default:\n        if (name) {\n          const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;\n          doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n        }\n\n    }\n\n    if (comment) directiveComments.push(comment);\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    const copyTagPrefix = ({\n      handle,\n      prefix\n    }) => ({\n      handle,\n      prefix\n    });\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof resolveSeq.Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nclass Document {\n  constructor(options) {\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  add(value) {\n    assertCollection(this.contents);\n    return this.contents.add(value);\n  }\n\n  addIn(path, value) {\n    assertCollection(this.contents);\n    this.contents.addIn(path, value);\n  }\n\n  delete(key) {\n    assertCollection(this.contents);\n    return this.contents.delete(key);\n  }\n\n  deleteIn(path) {\n    if (resolveSeq.isEmptyPath(path)) {\n      if (this.contents == null) return false;\n      this.contents = null;\n      return true;\n    }\n\n    assertCollection(this.contents);\n    return this.contents.deleteIn(path);\n  }\n\n  getDefaults() {\n    return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n  }\n\n  get(key, keepScalar) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : undefined;\n  }\n\n  getIn(path, keepScalar) {\n    if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : undefined;\n  }\n\n  has(key) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;\n  }\n\n  hasIn(path) {\n    if (resolveSeq.isEmptyPath(path)) return this.contents !== undefined;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;\n  }\n\n  set(key, value) {\n    assertCollection(this.contents);\n    this.contents.set(key, value);\n  }\n\n  setIn(path, value) {\n    if (resolveSeq.isEmptyPath(path)) this.contents = value;else {\n      assertCollection(this.contents);\n      this.contents.setIn(path, value);\n    }\n  }\n\n  setSchema(id, customTags) {\n    if (!id && !customTags && this.schema) return;\n    if (typeof id === 'number') id = id.toFixed(1);\n\n    if (id === '1.0' || id === '1.1' || id === '1.2') {\n      if (this.version) this.version = id;else this.options.version = id;\n      delete this.options.schema;\n    } else if (id && typeof id === 'string') {\n      this.options.schema = id;\n    }\n\n    if (Array.isArray(customTags)) this.options.customTags = customTags;\n    const opt = Object.assign({}, this.getDefaults(), this.options);\n    this.schema = new Schema.Schema(opt);\n  }\n\n  parse(node, prevDoc) {\n    if (this.options.keepCstNodes) this.cstNode = node;\n    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n    const {\n      directives = [],\n      contents = [],\n      directivesEndMarker,\n      error,\n      valueRange\n    } = node;\n\n    if (error) {\n      if (!error.source) error.source = this;\n      this.errors.push(error);\n    }\n\n    parseDirectives(this, directives, prevDoc);\n    if (directivesEndMarker) this.directivesEndMarker = true;\n    this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n    this.setSchema();\n    this.anchors._cstAliases = [];\n    parseContents(this, contents);\n    this.anchors.resolveNodes();\n\n    if (this.options.prettyErrors) {\n      for (const error of this.errors) if (error instanceof PlainValue.YAMLError) error.makePretty();\n\n      for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();\n    }\n\n    return this;\n  }\n\n  listNonDefaultTags() {\n    return listTagNames(this.contents).filter(t => t.indexOf(Schema.Schema.defaultPrefix) !== 0);\n  }\n\n  setTagPrefix(handle, prefix) {\n    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n    if (prefix) {\n      const prev = this.tagPrefixes.find(p => p.handle === handle);\n      if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n        handle,\n        prefix\n      });\n    } else {\n      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);\n    }\n  }\n\n  toJSON(arg, onAnchor) {\n    const {\n      keepBlobsInJSON,\n      mapAsMap,\n      maxAliasCount\n    } = this.options;\n    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof resolveSeq.Scalar));\n    const ctx = {\n      doc: this,\n      indentStep: '  ',\n      keep,\n      mapAsMap: keep && !!mapAsMap,\n      maxAliasCount,\n      stringify // Requiring directly in Pair would create circular dependencies\n\n    };\n    const anchorNames = Object.keys(this.anchors.map);\n    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], {\n      alias: [],\n      aliasCount: 0,\n      count: 1\n    }]));\n    const res = resolveSeq.toJSON(this.contents, arg, ctx);\n    if (typeof onAnchor === 'function' && ctx.anchors) for (const {\n      count,\n      res\n    } of ctx.anchors.values()) onAnchor(res, count);\n    return res;\n  }\n\n  toString() {\n    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n    const indentSize = this.options.indent;\n\n    if (!Number.isInteger(indentSize) || indentSize <= 0) {\n      const s = JSON.stringify(indentSize);\n      throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n    }\n\n    this.setSchema();\n    const lines = [];\n    let hasDirectives = false;\n\n    if (this.version) {\n      let vd = '%YAML 1.2';\n\n      if (this.schema.name === 'yaml-1.1') {\n        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n      }\n\n      lines.push(vd);\n      hasDirectives = true;\n    }\n\n    const tagNames = this.listNonDefaultTags();\n    this.tagPrefixes.forEach(({\n      handle,\n      prefix\n    }) => {\n      if (tagNames.some(t => t.indexOf(prefix) === 0)) {\n        lines.push(`%TAG ${handle} ${prefix}`);\n        hasDirectives = true;\n      }\n    });\n    if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n    if (this.commentBefore) {\n      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n      lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n    }\n\n    const ctx = {\n      anchors: {},\n      doc: this,\n      indent: '',\n      indentStep: ' '.repeat(indentSize),\n      stringify // Requiring directly in nodes would create circular dependencies\n\n    };\n    let chompKeep = false;\n    let contentComment = null;\n\n    if (this.contents) {\n      if (this.contents instanceof resolveSeq.Node) {\n        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n        ctx.forceBlockIndent = !!this.comment;\n        contentComment = this.contents.comment;\n      }\n\n      const onChompKeep = contentComment ? null : () => chompKeep = true;\n      const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);\n      lines.push(resolveSeq.addComment(body, '', contentComment));\n    } else if (this.contents !== undefined) {\n      lines.push(stringify(this.contents, ctx));\n    }\n\n    if (this.comment) {\n      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n      lines.push(this.comment.replace(/^/gm, '#'));\n    }\n\n    return lines.join('\\n') + '\\n';\n  }\n\n}\n\nPlainValue._defineProperty(Document, \"defaults\", documentOptions);\n\nexports.Document = Document;\nexports.defaultOptions = defaultOptions;\nexports.scalarOptions = scalarOptions;\n","const util = require('./dist/util')\n\nexports.findPair = util.findPair\nexports.toJSON = util.toJSON\nexports.parseMap = util.parseMap\nexports.parseSeq = util.parseSeq\n\nexports.stringifyNumber = util.stringifyNumber\nexports.stringifyString = util.stringifyString\nexports.Type = util.Type\n\nexports.YAMLError = util.YAMLError\nexports.YAMLReferenceError = util.YAMLReferenceError\nexports.YAMLSemanticError = util.YAMLSemanticError\nexports.YAMLSyntaxError = util.YAMLSyntaxError\nexports.YAMLWarning = util.YAMLWarning\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\n\n\n\nexports.Type = PlainValue.Type;\nexports.YAMLError = PlainValue.YAMLError;\nexports.YAMLReferenceError = PlainValue.YAMLReferenceError;\nexports.YAMLSemanticError = PlainValue.YAMLSemanticError;\nexports.YAMLSyntaxError = PlainValue.YAMLSyntaxError;\nexports.YAMLWarning = PlainValue.YAMLWarning;\nexports.findPair = resolveSeq.findPair;\nexports.parseMap = resolveSeq.resolveMap;\nexports.parseSeq = resolveSeq.resolveSeq;\nexports.stringifyNumber = resolveSeq.stringifyNumber;\nexports.stringifyString = resolveSeq.stringifyString;\nexports.toJSON = resolveSeq.toJSON;\n"],"sourceRoot":""}