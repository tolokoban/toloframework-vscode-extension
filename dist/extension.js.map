{"version":3,"sources":["../webpack/bootstrap","../external \"stream\"",".././src/util.ts","../external \"zlib\"","../external \"vscode\"",".././node_modules/yaml/dist/PlainValue-ec8e588e.js","../external \"fs\"","../external \"path\"",".././node_modules/yaml/dist/resolveSeq-4a68b39b.js","../external \"url\"",".././src/inputs/index.ts","../external \"http\"",".././node_modules/yaml/dist/Schema-42e9705c.js",".././node_modules/yaml/dist/warnings-39684f17.js","../external \"https\"",".././src/extension.ts",".././src/view/index.ts",".././src/view/view.ts",".././src/inputs/inputs.ts",".././src/view/tpl/view.ts",".././src/view/tpl/style.ts",".././src/view/tpl/tester.ts",".././src/view/tpl/container.ts",".././src/fonts/index.ts",".././src/fonts/fonts.ts",".././node_modules/node-fetch/lib/index.mjs",".././src/fonts/slicer.ts",".././src/module/index.ts",".././src/module/module.ts",".././src/template/index.ts",".././src/template/template.ts",".././src/translation.ts",".././node_modules/yaml/index.js",".././node_modules/yaml/dist/index.js",".././node_modules/yaml/dist/parse-cst.js",".././node_modules/yaml/dist/Document-2cf6b08c.js",".././node_modules/yaml/util.js",".././node_modules/yaml/dist/util.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","IViewColumn","exists","path","FS","existsSync","openTextDocument","filename","Promise","resolve","reject","X","workspace","then","removeExtension","idxDot","lastIndexOf","substr","getBasename","idxSlash","substring","findFilenameInAncestors","startingPath","oldPath","currentFilename","Path","getSourceFolder","editor","window","activeTextEditor","document","fileName","dirname","packagePath","sourcePath","getSourceFolderFromActiveTextEditor","changeExtension","newExtension","fileNameToModuleName","kebabCaseToPascalCase","getDirectory","isKebabCase","input","RX_KEBAB_CASE","lastIndex","test","kebabCaseToLowerPascalCase","pascal","charAt","toLowerCase","makeRelativeToSource","relative","openFileInEditor","viewColumn","ViewColumn","Active","doc","showTextDocument","valueOf","writeTextFile","content","writeFileSync","split","map","x","toUpperCase","join","Char","ANCHOR","COMMENT","TAG","DIRECTIVES_END","DOCUMENT_END","Type","ALIAS","BLANK_LINE","BLOCK_FOLDED","BLOCK_LITERAL","DIRECTIVE","DOCUMENT","FLOW_MAP","FLOW_SEQ","MAP","MAP_KEY","MAP_VALUE","PLAIN","QUOTE_DOUBLE","QUOTE_SINGLE","SEQ","SEQ_ITEM","findLineStarts","src","ls","offset","indexOf","push","getSrcInfo","cst","lineStarts","Array","isArray","context","getLinePos","length","start","line","col","getPrettyContext","end","maxWidth","slice","getLine","halfWidth","Math","round","errLen","errEnd","min","repeat","Range","orig","this","cr","origStart","origEnd","nextOffset","Node","str","next","endOfWhiteSpace","sep","ch0","prev","ch1","ch2","ch3","ch","isVerbatim","notOk","indent","lineStart","inEnd","endOfIndent","wsEnd","endAsBlank","indentDiff","indicatorAsIndent","inCount","error","fold","type","props","writable","range","valueRange","idx","skipKey","prop","anchor","getPropValue","comments","comment","header","atBlank","root","tag","verbatim","_","handle","suffix","match","endOfLine","commentRange","setOrigRange","forEach","addStringTerminator","YAMLError","Error","source","message","super","nodeType","linePos","rangeAsLinePos","ctx","YAMLSemanticError","PlainValue","inFlow","foldNewline","wsStart","errors","valueEnd","atDocumentBoundary","endOfBlockIndent","isEmpty","parseComment","hasComment","parseBlockValue","YAMLReferenceError","YAMLSyntaxError","YAMLWarning","_defineProperty","obj","configurable","defaultTagPrefix","defaultTags","STR","addComment","replace","toJSON","arg","v","String","anchors","onCreate","res","keep","Number","Scalar","collectionFromPath","schema","k","isInteger","createNode","isEmptyPath","iterator","done","Collection","add","rest","node","addIn","undefined","set","delete","deleteIn","keepScalar","getIn","items","every","commentBefore","has","hasIn","setIn","blockItem","flowChars","isMap","itemIndent","onComment","onChompKeep","indentStep","stringify","allNullValues","hasAllNullValues","assign","chompKeep","hasItemWithNewLine","nodes","reduce","item","spaceBefore","includes","strings","sum","maxFlowStringSingleLineLength","shift","asItemIndex","YAMLSeq","splice","it","seq","toString","JSON","Pair","PAIR","cb","Map","Set","stringKey","jsKey","inStringifyKey","stringifyKey","pair","mapAsMap","addToJSMap","indentSize","indentSeq","simpleKeys","options","keyComment","explicitKey","implicitKey","vcb","valueComment","indentAtStart","getName","valueStr","ws","MERGE_PAIR","getAliasCount","Alias","count","aliasCount","kc","vc","max","keys","find","a","newName","msg","maxAliasCount","cstNode","ReferenceError","findPair","YAMLMap","overwrite","sortEntries","sortMapEntries","findIndex","Merge","srcMap","binaryOptions","defaultType","lineWidth","strOptions","doubleQuoted","jsonEncoding","minMultiLineLength","minContentWidth","resolveScalar","tags","scalarFallback","format","apply","consumeMoreIndentedLines","text","foldFlowLines","onFold","onOverflow","endStep","folds","escapedFolds","overflow","getFoldOptions","containsDocumentMarker","doubleQuotedString","json","code","singleQuotedString","blockString","forceBlockIndent","literal","limit","strLen","lineLengthOverLimit","body","checkFlowCollectionEnd","char","lastItem","err","checkFlowCommentSpace","getLongKeyError","sk","resolveComments","collection","afterKey","before","resolveString","strValue","resolveTagName","nonSpecific","prefix","tagPrefixes","dtp","getDefaults","version","warnings","vocab","decodeURIComponent","resolveTagHandle","resolveByTagName","tagName","matchWithTest","resolveTag","fallback","getFallbackTagName","refError","stack","resolveNodeProps","after","hasAnchor","hasTag","isCollectionItem","parent","concat","commentHasRequiredWhitespace","resolveNode","getNode","rawValue","_cstAliases","resolveNodeValue","keepCstNodes","keepNodeTypes","ca","resolved","resolvePairComment","valueHasPairComment","found","startsWith","cc","boolOptions","trueStr","falseStr","intOptions","asBigInt","nullOptions","nullStr","resolveMap","resolveFlowMapItems","keyStart","atLineStart","valueNode","pos","origPos","j","nextItem","valueRangeContainsNewline","resolveBlockMapItems","hasCollectionKey","iKey","merge","sources","some","jKey","warn","resolveSeq","prevItem","pop","keyEnd","resolveFlowSeqItems","hasProps","resolveBlockSeqItems","stringifyNumber","minFractionDigits","isFinite","isNaN","stringifyString","_stringify","_type","actualString","addCommentBefore","plainString","default","createPair","sort","nodeClass","wrapScalars","string","identify","failsafe","intIdentify","intResolve","part","radix","BigInt","parseInt","intStringify","nullObj","boolObj","octObj","oct","intObj","hexObj","hex","nanObj","nan","NaN","NEGATIVE_INFINITY","POSITIVE_INFINITY","expObj","parseFloat","toExponential","floatObj","frac1","frac2","frac","core","intIdentify$1","stringifyJSON","SyntaxError","boolStringify","intIdentify$2","intResolve$1","sign","intStringify$1","yaml11","bin","abs","f","binary","omap","pairs","intTime","floatTime","timestamp","schemas","bool","float","floatExp","floatNaN","int","intHex","intOct","null","defaultPrefix","onTagObj","prevObjects","tagObj","filter","class","findTagObject","alias","aliasNodes","sortMapEntriesByKey","b","Schema","customTags","deprecatedCustomTags","warnOptionDeprecation","knownTags","schemaId","getSchemaTags","baseCtx","Uint8Array","Buffer","from","atob","buffer","charCodeAt","btoa","fromCharCode","ceil","lines","parsePairs","createPairs","iterable","TypeError","YAMLOMap","seenKeys","YAMLSet","keepPair","parseSexagesimal","parts","stringifySexagesimal","unshift","Date","RegExp","year","month","day","hour","minute","second","millisec","tz","date","UTC","toISOString","shouldWarn","deprecation","env","process","YAML_SILENCE_DEPRECATION_WARNINGS","YAML_SILENCE_WARNINGS","warning","emit","emitWarning","console","warned","warnFileDeprecation","alternative","actions","action","extension","id","disposable","VSC","commands","registerCommand","switchTo","subscriptions","compileYAML","load","exec","createWebviewPanel","Beside","enableScripts","enableCommandUris","webview","html","EXTENSION_FALLBACKS","js","yaml","log","activeEditor","showErrorMessage","extensions","moduleExtensions","modExt","fallbacks","getExtensionsToCheck","ext","openFileIfExists","preferedExtension","originFileName","endsWith","viewname","folder","getInitialContentTestView","modName","getInitialContentTest","getInitialContentVERT","getInitialContent","writeFile","ex","selectFolder","relativeFolder","folderName","basename","viewName","promptForName","destinationFolder","modal","fs","createDirectory","Uri","file","moduleSuffix","showInputBox","prompt","validateInput","trim","save","fileToOpen","title","sourceFolder","selectedFolder","folders","recursiveSearchForFolders","currentFolder","dirs","readdirSync","withFileTypes","dir","isDirectory","label","picker","createQuickPick","onDidAccept","dispose","onDidChangeActive","activeItems","show","getExtension","dotIndex","fontURL","disposableMessage","setStatusBarMessage","asyncContentLoading","url","styleResponse","loadContentFromURL","fontName","cssContent","asyncLoadAll","slices","urls","response","ok","status","statusText","arrayBuffer","data","css","pieces","piece","index","fonts","loadAllFonts","destination","showInformationMessage","files","fontFile","cssFilename","fontClassFilename","modFilename","Readable","BUFFER","TYPE","Blob","blobParts","arguments","buffers","size","element","ArrayBuffer","isView","byteOffset","byteLength","buf","ab","readable","_read","relativeStart","relativeEnd","span","slicedBuffer","blob","FetchError","systemError","errno","captureStackTrace","constructor","convert","defineProperties","e","INTERNALS","PassThrough","Body","_this","_ref","_ref$size","_ref$timeout","timeout","isURLSearchParams","isBlob","isBuffer","disturbed","on","consumeBody","_this4","alloc","stream","accum","accumBytes","abort","resTimeout","setTimeout","chunk","clearTimeout","append","getAll","clone","instance","p1","p2","bodyUsed","getBoundary","pipe","extractContentType","getTotalBytes","getLengthSync","_lengthRetrievers","hasKnownLength","ct","headers","_this2","parse","_this3","charset","convertBody","mixIn","proto","getOwnPropertyNames","desc","getOwnPropertyDescriptor","global","invalidTokenRegex","invalidHeaderCharRegex","validateName","validateValue","Headers","init","rawHeaders","raw","headerNames","headerName","method","callback","thisArg","getHeaders","_pairs$i","createHeadersIterator","kind","entries","values","INTERNAL","target","HeadersIteratorPrototype","setPrototypeOf","getPrototypeOf","_INTERNAL","exportNodeCompatibleHeaders","__proto__","hostHeaderKey","INTERNALS$1","STATUS_CODES","Response","opts","contentType","counter","redirected","INTERNALS$2","parse_url","format_url","streamDestructionSupported","isRequest","Request","parsedURL","href","inputBody","signal","isAbortSignal","redirect","follow","compress","agent","AbortError","PassThrough$1","resolve_url","fetch","request","protocol","hostname","contentLengthValue","totalBytes","getNodeRequestOptions","send","destroy","aborted","abortAndFinalize","finalize","req","reqTimeout","removeEventListener","addEventListener","once","socket","val","createHeadersLenient","isRedirect","statusCode","location","locationURL","requestOpts","response_options","statusMessage","codings","zlibOptions","flush","Z_SYNC_FLUSH","finishFlush","createGunzip","createBrotliDecompress","createInflate","createInflateRaw","dest","write","writeToStream","removeComments","cursor","indexOpen","indexClose","moduleName","getTestContent","getText","YAML","prettyErrors","errorMessage","parseCst","Document$1","Document","defaultOptions","parseDocument","errMsg","defaults","parseAllDocuments","cstDoc","parseCST","scalarOptions","contents","BlankLine","CollectionItem","includesTrailingLines","parseNode","inlineComment","blankLine","nextNodeIsIndented","inCollection","setOrigRanges","Comment","grabCollectionEndComments","cnode","len","ci","prevEnd","nextContentHasIndent","firstItem","itemRange","ec","startOfLine","copy","normalizeOffset","prevIncludesTrailingLines","Directive","parseName","parseParameters","directives","directivesEndMarker","documentEndMarker","hasDirectives","startCommentOrEndBlankLine","directive","iEnd","parseDirectives","parseContents","endOfIdentifier","Chomp","BlockValue","blockIndent","chomping","lastNewLine","keepStart","bi","folded","atStart","prevMoreIndented","lineEnd","explicit","minBlockIndent","lineIndent","parseBlockHeader","FlowCollection","jsonLike","prevNodeIsJsonLike","origOffset","QuoteDouble","parseCharCode","fromCodePoint","endOfQuote","QuoteSingle","ParseContext","overlay","valueStart","parseProps","createNewNode","parseEnd","nodeStartsCollection","lineHasProps","noIndicatorAsIndent","parseType","documents","crOffset","opt","documentOptions","stringifyTag","priv","createCtx","getTagObject","stringifyProps","Anchors","setAnchor","createAlias","names","validAnchorNode","visit","resolveTagDirective","parameters","resolveYamlDirective","assertCollection","anchorPrefix","toFixed","prevDoc","directiveComments","copyTagPrefix","setSchema","cbNode","resolveNodes","makePretty","onAnchor","keepBlobsInJSON","anchorNames","vd","tagNames","listNonDefaultTags","contentComment","util","parseMap","parseSeq"],"mappings":"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","file":"extension.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 14);\n","module.exports = require(\"stream\");","// tslint:disable-next-line: no-implicit-dependencies\nimport * as X from 'vscode'\nimport FS = require(\"fs\")\nimport Path = require(\"path\")\n\nexport default {\n    changeExtension,\n    exists,\n    fileNameToModuleName,\n    findFilenameInAncestors,\n    getBasename,\n    getDirectory,\n    getSourceFolder,\n    isKebabCase,\n    kebabCaseToLowerPascalCase,\n    kebabCaseToPascalCase,\n    makeRelativeToSource,\n    openFileInEditor,\n    openTextDocument,\n    removeExtension,\n    writeTextFile\n}\n\nenum IViewColumn {\n    ACTIVE = -1,\n    BESIDE = -2,\n    ONE = 1,\n    TWO = 2\n}\n\nfunction changeExtension(filename: string, newExtension: string): string {\n    return `${removeExtension(filename)}.${newExtension}`\n}\n\nfunction exists(path: string): boolean {\n    return FS.existsSync(path)\n}\n\nfunction fileNameToModuleName(filename: string): string {\n    return kebabCaseToPascalCase(removeExtension(getBasename(filename)))\n}\n\nasync function openTextDocument(filename: string):\n    Promise<X.TextDocument | null> {\n    return new Promise((resolve, reject) => {\n        if (!exists(filename)) {\n            resolve(null)\n            return\n        }\n        X.workspace.openTextDocument(filename).then(\n            resolve,\n            reject\n        )\n    })\n}\n\nasync function openFileInEditor(\n    filename: string,\n    viewColumn: X.ViewColumn = X.ViewColumn.Active\n): Promise<boolean> {\n    const doc = await openTextDocument(filename)\n    if (!doc) return false\n    X.window.showTextDocument(\n        doc,\n        viewColumn.valueOf()\n    )\n    return true\n}\n\nfunction removeExtension(filename: string): string {\n    const idxDot = filename.lastIndexOf(\".\")\n    return filename.substr(0, idxDot)\n}\n\nfunction getBasename(filename: string): string {\n    const idxSlash = filename.lastIndexOf(\"/\")\n    return filename.substring(idxSlash + 1)\n}\n\nfunction getDirectory(filename: string): string {\n    const idxSlash = filename.lastIndexOf(\"/\")\n    return filename.substr(0, idxSlash)\n}\n\nfunction writeTextFile(filename: string, content: string) {\n    FS.writeFileSync(filename, content)\n}\n\n/**\n * Find a `filename` in the `startingPath`.\n * If not found, try in the parent directory.\n * When found, return its path.\n * If not found, return `null`.\n *\n * @param filename - Name of the file to search without any path.\n * @param startingPath - Path from where to start the search.\n */\nfunction findFilenameInAncestors(\n    filename: string,\n    startingPath: string\n): string | null {\n    let path = startingPath\n    let oldPath = \"\"\n\n    while (oldPath !== path) {\n        oldPath = path\n        const currentFilename = Path.resolve(path, filename)\n        if (FS.existsSync(currentFilename)) return currentFilename\n        // Go to parent.\n        path = Path.resolve(path, \"..\")\n    }\n\n    return null\n}\n\n/**\n * Look for the nearest \"package.json\" file in the parents\n * of the current opened file, on in the children of the current\n * workspace.\n * Then, return the \"src\" folder that lies in the same directory\n * tham \"package.json\".\n */\nfunction getSourceFolder(): string | null {\n    const editor = X.window.activeTextEditor\n    if (editor) return getSourceFolderFromActiveTextEditor(editor)\n    return null\n}\n\nfunction getSourceFolderFromActiveTextEditor(editor: X.TextEditor): string | null {\n    const path = editor.document.fileName\n    const filename = \"package.json\"\n    const startingPath = Path.dirname(path)\n    const packagePath = findFilenameInAncestors(filename, startingPath)\n    if (!packagePath) return null\n\n    const sourcePath = Path.resolve(\n        Path.dirname(packagePath),\n        \"src\"\n    )\n    if (exists(sourcePath)) return sourcePath\n    return Path.dirname(packagePath)\n}\n\n/**\n * Return a path relative to \"src/\".\n * @param path Absolute path\n */\nfunction makeRelativeToSource(path: string): string {\n    return Path.relative(getSourceFolder() ?? '/', path)\n}\n\nconst RX_KEBAB_CASE = /^[a-z][a-z0-9]+(-[a-z0-9]+)*$/g\n\nfunction isKebabCase(input: string): string {\n    RX_KEBAB_CASE.lastIndex = -1\n    return RX_KEBAB_CASE.test(input) ? \"\" : \"Kebab case name expected (ex.: \\\"wonder-woman\\\")! Minimum length is 2.\"\n}\n\nfunction kebabCaseToPascalCase(name: string): string {\n    return name.split(\"-\")\n        .map(x => `${x.charAt(0).toUpperCase()}${x.substr(1).toLowerCase()}`)\n        .join(\"\")\n}\n\nfunction kebabCaseToLowerPascalCase(name: string): string {\n    const pascal = kebabCaseToPascalCase(name)\n    return pascal.charAt(0).toLowerCase() + pascal.substr(1)\n}\n","module.exports = require(\"zlib\");","module.exports = require(\"vscode\");","'use strict';\n\nconst Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nconst Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nconst defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  const ls = [0];\n  let offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  let lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts,\n    src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (let i = 0; i < lineStarts.length; ++i) {\n    const start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  const line = lineStarts.length;\n  return {\n    line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\nfunction getLine(line, cst) {\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  const start = lineStarts[line - 1];\n  let end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') --end;\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\nfunction getPrettyContext({\n  start,\n  end\n}, cst, maxWidth = 80) {\n  let src = getLine(start.line, cst);\n  if (!src) return null;\n  let {\n    col\n  } = start;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '';\n    } else {\n      const halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '';\n      col -= src.length - maxWidth;\n      src = '' + src.substr(1 - maxWidth);\n    }\n  }\n\n  let errLen = 1;\n  let errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '';\n    }\n  }\n\n  const offset = col > 1 ? ' '.repeat(col - 1) : '';\n  const err = '^'.repeat(errLen);\n  return `${src}\\n${offset}${err}${errEnd}`;\n}\n\nclass Range {\n  static copy(orig) {\n    return new Range(orig.start, orig.end);\n  }\n\n  constructor(start, end) {\n    this.start = start;\n    this.end = end || start;\n  }\n\n  isEmpty() {\n    return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n  }\n  /**\n   * Set `origStart` and `origEnd` to point to the original source range for\n   * this node, which may differ due to dropped CR characters.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRange(cr, offset) {\n    const {\n      start,\n      end\n    } = this;\n\n    if (cr.length === 0 || end <= cr[0]) {\n      this.origStart = start;\n      this.origEnd = end;\n      return offset;\n    }\n\n    let i = offset;\n\n    while (i < cr.length) {\n      if (cr[i] > start) break;else ++i;\n    }\n\n    this.origStart = start + i;\n    const nextOffset = i;\n\n    while (i < cr.length) {\n      // if end was at \\n, it should now be at \\r\n      if (cr[i] >= end) break;else ++i;\n    }\n\n    this.origEnd = end + i;\n    return nextOffset;\n  }\n\n}\n\n/** Root class of all nodes */\n\nclass Node {\n  static addStringTerminator(src, offset, str) {\n    if (str[str.length - 1] === '\\n') return str;\n    const next = Node.endOfWhiteSpace(src, offset);\n    return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n  } // ^(---|...)\n\n\n  static atDocumentBoundary(src, offset, sep) {\n    const ch0 = src[offset];\n    if (!ch0) return true;\n    const prev = src[offset - 1];\n    if (prev && prev !== '\\n') return false;\n\n    if (sep) {\n      if (ch0 !== sep) return false;\n    } else {\n      if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n    }\n\n    const ch1 = src[offset + 1];\n    const ch2 = src[offset + 2];\n    if (ch1 !== ch0 || ch2 !== ch0) return false;\n    const ch3 = src[offset + 3];\n    return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n  }\n\n  static endOfIdentifier(src, offset) {\n    let ch = src[offset];\n    const isVerbatim = ch === '<';\n    const notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n    while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];\n\n    if (isVerbatim && ch === '>') offset += 1;\n    return offset;\n  }\n\n  static endOfIndent(src, offset) {\n    let ch = src[offset];\n\n    while (ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfLine(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfWhiteSpace(src, offset) {\n    let ch = src[offset];\n\n    while (ch === '\\t' || ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static startOfLine(src, offset) {\n    let ch = src[offset - 1];\n    if (ch === '\\n') return offset;\n\n    while (ch && ch !== '\\n') ch = src[offset -= 1];\n\n    return offset + 1;\n  }\n  /**\n   * End of indentation, or null if the line's indent level is not more\n   * than `indent`\n   *\n   * @param {string} src\n   * @param {number} indent\n   * @param {number} lineStart\n   * @returns {?number}\n   */\n\n\n  static endOfBlockIndent(src, indent, lineStart) {\n    const inEnd = Node.endOfIndent(src, lineStart);\n\n    if (inEnd > lineStart + indent) {\n      return inEnd;\n    } else {\n      const wsEnd = Node.endOfWhiteSpace(src, inEnd);\n      const ch = src[wsEnd];\n      if (!ch || ch === '\\n') return wsEnd;\n    }\n\n    return null;\n  }\n\n  static atBlank(src, offset, endAsBlank) {\n    const ch = src[offset];\n    return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n  }\n\n  static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n    if (!ch || indentDiff < 0) return false;\n    if (indentDiff > 0) return true;\n    return indicatorAsIndent && ch === '-';\n  } // should be at line or string end, or at next non-whitespace char\n\n\n  static normalizeOffset(src, offset) {\n    const ch = src[offset];\n    return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n  } // fold single newline into space, multiple newlines to N - 1 newlines\n  // presumes src[offset] === '\\n'\n\n\n  static foldNewline(src, offset, indent) {\n    let inCount = 0;\n    let error = false;\n    let fold = '';\n    let ch = src[offset + 1];\n\n    while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n      switch (ch) {\n        case '\\n':\n          inCount = 0;\n          offset += 1;\n          fold += '\\n';\n          break;\n\n        case '\\t':\n          if (inCount <= indent) error = true;\n          offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n          break;\n\n        case ' ':\n          inCount += 1;\n          offset += 1;\n          break;\n      }\n\n      ch = src[offset + 1];\n    }\n\n    if (!fold) fold = ' ';\n    if (ch && inCount <= indent) error = true;\n    return {\n      fold,\n      offset,\n      error\n    };\n  }\n\n  constructor(type, props, context) {\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  getPropValue(idx, key, skipKey) {\n    if (!this.context) return null;\n    const {\n      src\n    } = this.context;\n    const prop = this.props[idx];\n    return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n  }\n\n  get anchor() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const anchor = this.getPropValue(i, Char.ANCHOR, true);\n      if (anchor != null) return anchor;\n    }\n\n    return null;\n  }\n\n  get comment() {\n    const comments = [];\n\n    for (let i = 0; i < this.props.length; ++i) {\n      const comment = this.getPropValue(i, Char.COMMENT, true);\n      if (comment != null) comments.push(comment);\n    }\n\n    return comments.length > 0 ? comments.join('\\n') : null;\n  }\n\n  commentHasRequiredWhitespace(start) {\n    const {\n      src\n    } = this.context;\n    if (this.header && start === this.header.end) return false;\n    if (!this.valueRange) return false;\n    const {\n      end\n    } = this.valueRange;\n    return start !== end || Node.atBlank(src, end - 1);\n  }\n\n  get hasComment() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] === Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get hasProps() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] !== Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get includesTrailingLines() {\n    return false;\n  }\n\n  get jsonLike() {\n    const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n    return jsonLikeTypes.indexOf(this.type) !== -1;\n  }\n\n  get rangeAsLinePos() {\n    if (!this.range || !this.context) return undefined;\n    const start = getLinePos(this.range.start, this.context.root);\n    if (!start) return undefined;\n    const end = getLinePos(this.range.end, this.context.root);\n    return {\n      start,\n      end\n    };\n  }\n\n  get rawValue() {\n    if (!this.valueRange || !this.context) return null;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    return this.context.src.slice(start, end);\n  }\n\n  get tag() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const tag = this.getPropValue(i, Char.TAG, false);\n\n      if (tag != null) {\n        if (tag[1] === '<') {\n          return {\n            verbatim: tag.slice(2, -1)\n          };\n        } else {\n          // eslint-disable-next-line no-unused-vars\n          const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);\n          return {\n            handle,\n            suffix\n          };\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get valueRangeContainsNewline() {\n    if (!this.valueRange || !this.context) return false;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n\n    for (let i = start; i < end; ++i) {\n      if (src[i] === '\\n') return true;\n    }\n\n    return false;\n  }\n\n  parseComment(start) {\n    const {\n      src\n    } = this.context;\n\n    if (src[start] === Char.COMMENT) {\n      const end = Node.endOfLine(src, start + 1);\n      const commentRange = new Range(start, end);\n      this.props.push(commentRange);\n      return end;\n    }\n\n    return start;\n  }\n  /**\n   * Populates the `origStart` and `origEnd` values of all ranges for this\n   * node. Extended by child classes to handle descendant nodes.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRanges(cr, offset) {\n    if (this.range) offset = this.range.setOrigRange(cr, offset);\n    if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n    this.props.forEach(prop => prop.setOrigRange(cr, offset));\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = src.slice(range.start, range.end);\n    return Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass YAMLError extends Error {\n  constructor(name, source, message) {\n    if (!message || !(source instanceof Node)) throw new Error(`Invalid arguments for new ${name}`);\n    super();\n    this.name = name;\n    this.message = message;\n    this.source = source;\n  }\n\n  makePretty() {\n    if (!this.source) return;\n    this.nodeType = this.source.type;\n    const cst = this.source.context && this.source.context.root;\n\n    if (typeof this.offset === 'number') {\n      this.range = new Range(this.offset, this.offset + 1);\n      const start = cst && getLinePos(this.offset, cst);\n\n      if (start) {\n        const end = {\n          line: start.line,\n          col: start.col + 1\n        };\n        this.linePos = {\n          start,\n          end\n        };\n      }\n\n      delete this.offset;\n    } else {\n      this.range = this.source.range;\n      this.linePos = this.source.rangeAsLinePos;\n    }\n\n    if (this.linePos) {\n      const {\n        line,\n        col\n      } = this.linePos.start;\n      this.message += ` at line ${line}, column ${col}`;\n      const ctx = cst && getPrettyContext(this.linePos, cst);\n      if (ctx) this.message += `:\\n\\n${ctx}\\n`;\n    }\n\n    delete this.source;\n  }\n\n}\nclass YAMLReferenceError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLReferenceError', source, message);\n  }\n\n}\nclass YAMLSemanticError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSemanticError', source, message);\n  }\n\n}\nclass YAMLSyntaxError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSyntaxError', source, message);\n  }\n\n}\nclass YAMLWarning extends YAMLError {\n  constructor(source, message) {\n    super('YAMLWarning', source, message);\n  }\n\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass PlainValue extends Node {\n  static endOfLine(src, start, inFlow) {\n    let ch = src[start];\n    let offset = start;\n\n    while (ch && ch !== '\\n') {\n      if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n      const next = src[offset + 1];\n      if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n      if ((ch === ' ' || ch === '\\t') && next === '#') break;\n      offset += 1;\n      ch = next;\n    }\n\n    return offset;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n    let ch = src[end - 1];\n\n    while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) ch = src[--end - 1];\n\n    let str = '';\n\n    for (let i = start; i < end; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        const {\n          fold,\n          offset\n        } = Node.foldNewline(src, i, -1);\n        str += fold;\n        i = offset;\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (i < end && (next === ' ' || next === '\\t')) {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    const ch0 = src[start];\n\n    switch (ch0) {\n      case '\\t':\n        {\n          const msg = 'Plain value cannot start with a tab character';\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      case '@':\n      case '`':\n        {\n          const msg = `Plain value cannot start with reserved character ${ch0}`;\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      default:\n        return str;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      inFlow,\n      src\n    } = this.context;\n    let offset = start;\n    let valueEnd = start;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      if (Node.atDocumentBoundary(src, offset + 1)) break;\n      const end = Node.endOfBlockIndent(src, indent, offset + 1);\n      if (end === null || src[end] === '#') break;\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        valueEnd = PlainValue.endOfLine(src, end, inFlow);\n        offset = valueEnd;\n      }\n    }\n\n    if (this.valueRange.isEmpty()) this.valueRange.start = start;\n    this.valueRange.end = valueEnd;\n    return valueEnd;\n  }\n  /**\n   * Parses a plain value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * #comment\n   *\n   * first line\n   *\n   * first line #comment\n   *\n   * first line\n   * block\n   * lines\n   *\n   * #comment\n   * block\n   * lines\n   * ```\n   * where block lines are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar, may be `\\n`\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      inFlow,\n      src\n    } = context;\n    let offset = start;\n    const ch = src[offset];\n\n    if (ch && ch !== '#' && ch !== '\\n') {\n      offset = PlainValue.endOfLine(src, start, inFlow);\n    }\n\n    this.valueRange = new Range(start, offset);\n    offset = Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n\n    if (!this.hasComment || this.valueRange.isEmpty()) {\n      offset = this.parseBlockValue(offset);\n    }\n\n    return offset;\n  }\n\n}\n\nexports.Char = Char;\nexports.Node = Node;\nexports.PlainValue = PlainValue;\nexports.Range = Range;\nexports.Type = Type;\nexports.YAMLError = YAMLError;\nexports.YAMLReferenceError = YAMLReferenceError;\nexports.YAMLSemanticError = YAMLSemanticError;\nexports.YAMLSyntaxError = YAMLSyntaxError;\nexports.YAMLWarning = YAMLWarning;\nexports._defineProperty = _defineProperty;\nexports.defaultTagPrefix = defaultTagPrefix;\nexports.defaultTags = defaultTags;\n","module.exports = require(\"fs\");","module.exports = require(\"path\");","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nfunction addCommentBefore(str, indent, comment) {\n  if (!comment) return str;\n  const cc = comment.replace(/[\\s\\S]^/gm, `$&${indent}#`);\n  return `#${cc}\\n${indent}${str}`;\n}\nfunction addComment(str, indent, comment) {\n  return !comment ? str : comment.indexOf('\\n') === -1 ? `${str} #${comment}` : `${str}\\n` + comment.replace(/^/gm, `${indent || ''}#`);\n}\n\nclass Node {}\n\nfunction toJSON(value, arg, ctx) {\n  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));\n\n  if (value && typeof value.toJSON === 'function') {\n    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);\n    if (anchor) ctx.onCreate = res => {\n      anchor.res = res;\n      delete ctx.onCreate;\n    };\n    const res = value.toJSON(arg, ctx);\n    if (anchor && ctx.onCreate) ctx.onCreate(res);\n    return res;\n  }\n\n  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);\n  return value;\n}\n\nclass Scalar extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n  toJSON(arg, ctx) {\n    return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);\n  }\n\n  toString() {\n    return String(this.value);\n  }\n\n}\n\nfunction collectionFromPath(schema, path, value) {\n  let v = value;\n\n  for (let i = path.length - 1; i >= 0; --i) {\n    const k = path[i];\n    const o = Number.isInteger(k) && k >= 0 ? [] : {};\n    o[k] = v;\n    v = o;\n  }\n\n  return schema.createNode(v, false);\n} // null, undefined, or an empty non-string iterable (e.g. [])\n\n\nconst isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;\nclass Collection extends Node {\n  constructor(schema) {\n    super();\n\n    PlainValue._defineProperty(this, \"items\", []);\n\n    this.schema = schema;\n  }\n\n  addIn(path, value) {\n    if (isEmptyPath(path)) this.add(value);else {\n      const [key, ...rest] = path;\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  }\n\n  deleteIn([key, ...rest]) {\n    if (rest.length === 0) return this.delete(key);\n    const node = this.get(key, true);\n    if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n  }\n\n  getIn([key, ...rest], keepScalar) {\n    const node = this.get(key, true);\n    if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;\n  }\n\n  hasAllNullValues() {\n    return this.items.every(node => {\n      if (!node || node.type !== 'PAIR') return false;\n      const n = node.value;\n      return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n    });\n  }\n\n  hasIn([key, ...rest]) {\n    if (rest.length === 0) return this.has(key);\n    const node = this.get(key, true);\n    return node instanceof Collection ? node.hasIn(rest) : false;\n  }\n\n  setIn([key, ...rest], value) {\n    if (rest.length === 0) {\n      this.set(key, value);\n    } else {\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  } // overridden in implementations\n\n  /* istanbul ignore next */\n\n\n  toJSON() {\n    return null;\n  }\n\n  toString(ctx, {\n    blockItem,\n    flowChars,\n    isMap,\n    itemIndent\n  }, onComment, onChompKeep) {\n    const {\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;\n    if (inFlow) itemIndent += indentStep;\n    const allNullValues = isMap && this.hasAllNullValues();\n    ctx = Object.assign({}, ctx, {\n      allNullValues,\n      indent: itemIndent,\n      inFlow,\n      type: null\n    });\n    let chompKeep = false;\n    let hasItemWithNewLine = false;\n    const nodes = this.items.reduce((nodes, item, i) => {\n      let comment;\n\n      if (item) {\n        if (!chompKeep && item.spaceBefore) nodes.push({\n          type: 'comment',\n          str: ''\n        });\n        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => {\n          nodes.push({\n            type: 'comment',\n            str: `#${line}`\n          });\n        });\n        if (item.comment) comment = item.comment;\n        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;\n      }\n\n      chompKeep = false;\n      let str = stringify(item, ctx, () => comment = null, () => chompKeep = true);\n      if (inFlow && !hasItemWithNewLine && str.includes('\\n')) hasItemWithNewLine = true;\n      if (inFlow && i < this.items.length - 1) str += ',';\n      str = addComment(str, itemIndent, comment);\n      if (chompKeep && (comment || inFlow)) chompKeep = false;\n      nodes.push({\n        type: 'item',\n        str\n      });\n      return nodes;\n    }, []);\n    let str;\n\n    if (nodes.length === 0) {\n      str = flowChars.start + flowChars.end;\n    } else if (inFlow) {\n      const {\n        start,\n        end\n      } = flowChars;\n      const strings = nodes.map(n => n.str);\n\n      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {\n        str = start;\n\n        for (const s of strings) {\n          str += s ? `\\n${indentStep}${indent}${s}` : '\\n';\n        }\n\n        str += `\\n${indent}${end}`;\n      } else {\n        str = `${start} ${strings.join(' ')} ${end}`;\n      }\n    } else {\n      const strings = nodes.map(blockItem);\n      str = strings.shift();\n\n      for (const s of strings) str += s ? `\\n${indent}${s}` : '\\n';\n    }\n\n    if (this.comment) {\n      str += '\\n' + this.comment.replace(/^/gm, `${indent}#`);\n      if (onComment) onComment();\n    } else if (chompKeep && onChompKeep) onChompKeep();\n\n    return str;\n  }\n\n}\n\nPlainValue._defineProperty(Collection, \"maxFlowStringSingleLineLength\", 60);\n\nfunction asItemIndex(key) {\n  let idx = key instanceof Scalar ? key.value : key;\n  if (idx && typeof idx === 'string') idx = Number(idx);\n  return Number.isInteger(idx) && idx >= 0 ? idx : null;\n}\n\nclass YAMLSeq extends Collection {\n  add(value) {\n    this.items.push(value);\n  }\n\n  delete(key) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return false;\n    const del = this.items.splice(idx, 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return undefined;\n    const it = this.items[idx];\n    return !keepScalar && it instanceof Scalar ? it.value : it;\n  }\n\n  has(key) {\n    const idx = asItemIndex(key);\n    return typeof idx === 'number' && idx < this.items.length;\n  }\n\n  set(key, value) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);\n    this.items[idx] = value;\n  }\n\n  toJSON(_, ctx) {\n    const seq = [];\n    if (ctx && ctx.onCreate) ctx.onCreate(seq);\n    let i = 0;\n\n    for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));\n\n    return seq;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    return super.toString(ctx, {\n      blockItem: n => n.type === 'comment' ? n.str : `- ${n.str}`,\n      flowChars: {\n        start: '[',\n        end: ']'\n      },\n      isMap: false,\n      itemIndent: (ctx.indent || '') + '  '\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst stringifyKey = (key, jsKey, ctx) => {\n  if (jsKey === null) return '';\n  if (typeof jsKey !== 'object') return String(jsKey);\n  if (key instanceof Node && ctx && ctx.doc) return key.toString({\n    anchors: {},\n    doc: ctx.doc,\n    indent: '',\n    indentStep: ctx.indentStep,\n    inFlow: true,\n    inStringifyKey: true,\n    stringify: ctx.stringify\n  });\n  return JSON.stringify(jsKey);\n};\n\nclass Pair extends Node {\n  constructor(key, value = null) {\n    super();\n    this.key = key;\n    this.value = value;\n    this.type = Pair.Type.PAIR;\n  }\n\n  get commentBefore() {\n    return this.key instanceof Node ? this.key.commentBefore : undefined;\n  }\n\n  set commentBefore(cb) {\n    if (this.key == null) this.key = new Scalar(null);\n    if (this.key instanceof Node) this.key.commentBefore = cb;else {\n      const msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';\n      throw new Error(msg);\n    }\n  }\n\n  addToJSMap(ctx, map) {\n    const key = toJSON(this.key, '', ctx);\n\n    if (map instanceof Map) {\n      const value = toJSON(this.value, key, ctx);\n      map.set(key, value);\n    } else if (map instanceof Set) {\n      map.add(key);\n    } else {\n      const stringKey = stringifyKey(this.key, key, ctx);\n      map[stringKey] = toJSON(this.value, stringKey, ctx);\n    }\n\n    return map;\n  }\n\n  toJSON(_, ctx) {\n    const pair = ctx && ctx.mapAsMap ? new Map() : {};\n    return this.addToJSMap(ctx, pair);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx || !ctx.doc) return JSON.stringify(this);\n    const {\n      indent: indentSize,\n      indentSeq,\n      simpleKeys\n    } = ctx.doc.options;\n    let {\n      key,\n      value\n    } = this;\n    let keyComment = key instanceof Node && key.comment;\n\n    if (simpleKeys) {\n      if (keyComment) {\n        throw new Error('With simple keys, key nodes cannot have comments');\n      }\n\n      if (key instanceof Collection) {\n        const msg = 'With simple keys, collection cannot be used as a key value';\n        throw new Error(msg);\n      }\n    }\n\n    const explicitKey = !simpleKeys && (!key || keyComment || key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL);\n    const {\n      doc,\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    ctx = Object.assign({}, ctx, {\n      implicitKey: !explicitKey,\n      indent: indent + indentStep\n    });\n    let chompKeep = false;\n    let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);\n    str = addComment(str, ctx.indent, keyComment);\n\n    if (ctx.allNullValues && !simpleKeys) {\n      if (this.comment) {\n        str = addComment(str, ctx.indent, this.comment);\n        if (onComment) onComment();\n      } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();\n\n      return ctx.inFlow ? str : `? ${str}`;\n    }\n\n    str = explicitKey ? `? ${str}\\n${indent}:` : `${str}:`;\n\n    if (this.comment) {\n      // expected (but not strictly required) to be a single-line comment\n      str = addComment(str, ctx.indent, this.comment);\n      if (onComment) onComment();\n    }\n\n    let vcb = '';\n    let valueComment = null;\n\n    if (value instanceof Node) {\n      if (value.spaceBefore) vcb = '\\n';\n\n      if (value.commentBefore) {\n        const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);\n        vcb += `\\n${cs}`;\n      }\n\n      valueComment = value.comment;\n    } else if (value && typeof value === 'object') {\n      value = doc.schema.createNode(value, true);\n    }\n\n    ctx.implicitKey = false;\n    if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n\n    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {\n      // If indentSeq === false, consider '- ' as part of indentation where possible\n      ctx.indent = ctx.indent.substr(2);\n    }\n\n    const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);\n    let ws = ' ';\n\n    if (vcb || this.comment) {\n      ws = `${vcb}\\n${ctx.indent}`;\n    } else if (!explicitKey && value instanceof Collection) {\n      const flow = valueStr[0] === '[' || valueStr[0] === '{';\n      if (!flow || valueStr.includes('\\n')) ws = `\\n${ctx.indent}`;\n    }\n\n    if (chompKeep && !valueComment && onChompKeep) onChompKeep();\n    return addComment(str + ws + valueStr, ctx.indent, valueComment);\n  }\n\n}\n\nPlainValue._defineProperty(Pair, \"Type\", {\n  PAIR: 'PAIR',\n  MERGE_PAIR: 'MERGE_PAIR'\n});\n\nconst getAliasCount = (node, anchors) => {\n  if (node instanceof Alias) {\n    const anchor = anchors.get(node.source);\n    return anchor.count * anchor.aliasCount;\n  } else if (node instanceof Collection) {\n    let count = 0;\n\n    for (const item of node.items) {\n      const c = getAliasCount(item, anchors);\n      if (c > count) count = c;\n    }\n\n    return count;\n  } else if (node instanceof Pair) {\n    const kc = getAliasCount(node.key, anchors);\n    const vc = getAliasCount(node.value, anchors);\n    return Math.max(kc, vc);\n  }\n\n  return 1;\n};\n\nclass Alias extends Node {\n  static stringify({\n    range,\n    source\n  }, {\n    anchors,\n    doc,\n    implicitKey,\n    inStringifyKey\n  }) {\n    let anchor = Object.keys(anchors).find(a => anchors[a] === source);\n    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();\n    if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;\n    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';\n    throw new Error(`${msg} [${range}]`);\n  }\n\n  constructor(source) {\n    super();\n    this.source = source;\n    this.type = PlainValue.Type.ALIAS;\n  }\n\n  set tag(t) {\n    throw new Error('Alias nodes cannot have tags');\n  }\n\n  toJSON(arg, ctx) {\n    if (!ctx) return toJSON(this.source, arg, ctx);\n    const {\n      anchors,\n      maxAliasCount\n    } = ctx;\n    const anchor = anchors.get(this.source);\n    /* istanbul ignore if */\n\n    if (!anchor || anchor.res === undefined) {\n      const msg = 'This should not happen: Alias anchor was not resolved?';\n      if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n    }\n\n    if (maxAliasCount >= 0) {\n      anchor.count += 1;\n      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);\n\n      if (anchor.count * anchor.aliasCount > maxAliasCount) {\n        const msg = 'Excessive alias count indicates a resource exhaustion attack';\n        if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n      }\n    }\n\n    return anchor.res;\n  } // Only called when stringifying an alias mapping key while constructing\n  // Object output.\n\n\n  toString(ctx) {\n    return Alias.stringify(this, ctx);\n  }\n\n}\n\nPlainValue._defineProperty(Alias, \"default\", true);\n\nfunction findPair(items, key) {\n  const k = key instanceof Scalar ? key.value : key;\n\n  for (const it of items) {\n    if (it instanceof Pair) {\n      if (it.key === key || it.key === k) return it;\n      if (it.key && it.key.value === k) return it;\n    }\n  }\n\n  return undefined;\n}\nclass YAMLMap extends Collection {\n  add(pair, overwrite) {\n    if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);\n    const prev = findPair(this.items, pair.key);\n    const sortEntries = this.schema && this.schema.sortMapEntries;\n\n    if (prev) {\n      if (overwrite) prev.value = pair.value;else throw new Error(`Key ${pair.key} already set`);\n    } else if (sortEntries) {\n      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);\n      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);\n    } else {\n      this.items.push(pair);\n    }\n  }\n\n  delete(key) {\n    const it = findPair(this.items, key);\n    if (!it) return false;\n    const del = this.items.splice(this.items.indexOf(it), 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const it = findPair(this.items, key);\n    const node = it && it.value;\n    return !keepScalar && node instanceof Scalar ? node.value : node;\n  }\n\n  has(key) {\n    return !!findPair(this.items, key);\n  }\n\n  set(key, value) {\n    this.add(new Pair(key, value), true);\n  }\n  /**\n   * @param {*} arg ignored\n   * @param {*} ctx Conversion context, originally set in Document#toJSON()\n   * @param {Class} Type If set, forces the returned collection type\n   * @returns {*} Instance of Type, Map, or Object\n   */\n\n\n  toJSON(_, ctx, Type) {\n    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const item of this.items) item.addToJSMap(ctx, map);\n\n    return map;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n\n    for (const item of this.items) {\n      if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n    }\n\n    return super.toString(ctx, {\n      blockItem: n => n.str,\n      flowChars: {\n        start: '{',\n        end: '}'\n      },\n      isMap: true,\n      itemIndent: ctx.indent || ''\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst MERGE_KEY = '<<';\nclass Merge extends Pair {\n  constructor(pair) {\n    if (pair instanceof Pair) {\n      let seq = pair.value;\n\n      if (!(seq instanceof YAMLSeq)) {\n        seq = new YAMLSeq();\n        seq.items.push(pair.value);\n        seq.range = pair.value.range;\n      }\n\n      super(pair.key, seq);\n      this.range = pair.range;\n    } else {\n      super(new Scalar(MERGE_KEY), new YAMLSeq());\n    }\n\n    this.type = Pair.Type.MERGE_PAIR;\n  } // If the value associated with a merge key is a single mapping node, each of\n  // its key/value pairs is inserted into the current mapping, unless the key\n  // already exists in it. If the value associated with the merge key is a\n  // sequence, then this sequence is expected to contain mapping nodes and each\n  // of these nodes is merged in turn according to its order in the sequence.\n  // Keys in mapping nodes earlier in the sequence override keys specified in\n  // later mapping nodes. -- http://yaml.org/type/merge.html\n\n\n  addToJSMap(ctx, map) {\n    for (const {\n      source\n    } of this.value.items) {\n      if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');\n      const srcMap = source.toJSON(null, ctx, Map);\n\n      for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n          if (!map.has(key)) map.set(key, value);\n        } else if (map instanceof Set) {\n          map.add(key);\n        } else {\n          if (!Object.prototype.hasOwnProperty.call(map, key)) map[key] = value;\n        }\n      }\n    }\n\n    return map;\n  }\n\n  toString(ctx, onComment) {\n    const seq = this.value;\n    if (seq.items.length > 1) return super.toString(ctx, onComment);\n    this.value = seq.items[0];\n    const str = super.toString(ctx, onComment);\n    this.value = seq;\n    return str;\n  }\n\n}\n\nconst binaryOptions = {\n  defaultType: PlainValue.Type.BLOCK_LITERAL,\n  lineWidth: 76\n};\nconst boolOptions = {\n  trueStr: 'true',\n  falseStr: 'false'\n};\nconst intOptions = {\n  asBigInt: false\n};\nconst nullOptions = {\n  nullStr: 'null'\n};\nconst strOptions = {\n  defaultType: PlainValue.Type.PLAIN,\n  doubleQuoted: {\n    jsonEncoding: false,\n    minMultiLineLength: 40\n  },\n  fold: {\n    lineWidth: 80,\n    minContentWidth: 20\n  }\n};\n\nfunction resolveScalar(str, tags, scalarFallback) {\n  for (const {\n    format,\n    test,\n    resolve\n  } of tags) {\n    if (test) {\n      const match = str.match(test);\n\n      if (match) {\n        let res = resolve.apply(null, match);\n        if (!(res instanceof Scalar)) res = new Scalar(res);\n        if (format) res.format = format;\n        return res;\n      }\n    }\n  }\n\n  if (scalarFallback) str = scalarFallback(str);\n  return new Scalar(str);\n}\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line\n// returns index of last newline in more-indented block\n\nconst consumeMoreIndentedLines = (text, i) => {\n  let ch = text[i + 1];\n\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n\n    ch = text[i + 1];\n  }\n\n  return i;\n};\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n *\n * @param {string} text\n * @param {string} indent\n * @param {string} [mode='flow'] `'block'` prevents more-indented lines\n *   from being folded; `'quoted'` allows for `\\` escapes, including escaped\n *   newlines\n * @param {Object} options\n * @param {number} [options.indentAtStart] Accounts for leading contents on\n *   the first line, defaulting to `indent.length`\n * @param {number} [options.lineWidth=80]\n * @param {number} [options.minContentWidth=20] Allow highly indented lines to\n *   stretch the line width\n * @param {function} options.onFold Called once if the text is folded\n * @param {function} options.onFold Called once if any line of text exceeds\n *   lineWidth characters\n */\n\n\nfunction foldFlowLines(text, indent, mode, {\n  indentAtStart,\n  lineWidth = 80,\n  minContentWidth = 20,\n  onFold,\n  onOverflow\n}) {\n  if (!lineWidth || lineWidth < 0) return text;\n  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  const folds = [];\n  const escapedFolds = {};\n  let end = lineWidth - (typeof indentAtStart === 'number' ? indentAtStart : indent.length);\n  let split = undefined;\n  let prev = undefined;\n  let overflow = false;\n  let i = -1;\n\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n\n  for (let ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n\n        case 'u':\n          i += 5;\n          break;\n\n        case 'U':\n          i += 9;\n          break;\n\n        default:\n          i += 1;\n      }\n    }\n\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        const next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          } // i - 2 accounts for not-dropped last char + newline-escaping \\\n\n\n          folds.push(i - 2);\n          escapedFolds[i - 2] = true;\n          end = i - 2 + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n\n    prev = ch;\n  }\n\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  let res = text.slice(0, folds[0]);\n\n  for (let i = 0; i < folds.length; ++i) {\n    const fold = folds[i];\n    const end = folds[i + 1] || text.length;\n    if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\\\`;\n    res += `\\n${indent}${text.slice(fold + 1, end)}`;\n  }\n\n  return res;\n}\n\nconst getFoldOptions = ({\n  indentAtStart\n}) => indentAtStart ? Object.assign({\n  indentAtStart\n}, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\n\n\nconst containsDocumentMarker = str => /^(%|---|\\.\\.\\.)/m.test(str);\n\nfunction lineLengthOverLimit(str, limit) {\n  const strLen = str.length;\n  if (strLen <= limit) return false;\n\n  for (let i = 0, start = 0; i < strLen; ++i) {\n    if (str[i] === '\\n') {\n      if (i - start > limit) return true;\n      start = i + 1;\n      if (strLen - start <= limit) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction doubleQuotedString(value, ctx) {\n  const {\n    implicitKey\n  } = ctx;\n  const {\n    jsonEncoding,\n    minMultiLineLength\n  } = strOptions.doubleQuoted;\n  const json = JSON.stringify(value);\n  if (jsonEncoding) return json;\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  let str = '';\n  let start = 0;\n\n  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n    if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n      // space before newline needs to be escaped to not be folded\n      str += json.slice(start, i) + '\\\\ ';\n      i += 1;\n      start = i;\n      ch = '\\\\';\n    }\n\n    if (ch === '\\\\') switch (json[i + 1]) {\n      case 'u':\n        {\n          str += json.slice(start, i);\n          const code = json.substr(i + 2, 4);\n\n          switch (code) {\n            case '0000':\n              str += '\\\\0';\n              break;\n\n            case '0007':\n              str += '\\\\a';\n              break;\n\n            case '000b':\n              str += '\\\\v';\n              break;\n\n            case '001b':\n              str += '\\\\e';\n              break;\n\n            case '0085':\n              str += '\\\\N';\n              break;\n\n            case '00a0':\n              str += '\\\\_';\n              break;\n\n            case '2028':\n              str += '\\\\L';\n              break;\n\n            case '2029':\n              str += '\\\\P';\n              break;\n\n            default:\n              if (code.substr(0, 2) === '00') str += '\\\\x' + code.substr(2);else str += json.substr(i, 6);\n          }\n\n          i += 5;\n          start = i + 1;\n        }\n        break;\n\n      case 'n':\n        if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n          i += 1;\n        } else {\n          // folding will eat first newline\n          str += json.slice(start, i) + '\\n\\n';\n\n          while (json[i + 2] === '\\\\' && json[i + 3] === 'n' && json[i + 4] !== '\"') {\n            str += '\\n';\n            i += 2;\n          }\n\n          str += indent; // space after newline needs to be escaped to not be folded\n\n          if (json[i + 2] === ' ') str += '\\\\';\n          i += 1;\n          start = i + 1;\n        }\n\n        break;\n\n      default:\n        i += 1;\n    }\n  }\n\n  str = start ? str + json.slice(start) : json;\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\n\nfunction singleQuotedString(value, ctx) {\n  if (ctx.implicitKey) {\n    if (/\\n/.test(value)) return doubleQuotedString(value, ctx);\n  } else {\n    // single quoted string can't have leading or trailing whitespace around newline\n    if (/[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\n\nfunction blockString({\n  comment,\n  type,\n  value\n}, ctx, onComment, onChompKeep) {\n  // 1. Block can't end in whitespace unless the last line is non-empty.\n  // 2. Strings consisting of only whitespace are best rendered explicitly.\n  if (/\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n  const indentSize = indent ? '2' : '1'; // root is at -1\n\n  const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth - indent.length);\n  let header = literal ? '|' : '>';\n  if (!value) return header + '\\n';\n  let wsStart = '';\n  let wsEnd = '';\n  value = value.replace(/[\\n\\t ]*$/, ws => {\n    const n = ws.indexOf('\\n');\n\n    if (n === -1) {\n      header += '-'; // strip\n    } else if (value === ws || n !== ws.length - 1) {\n      header += '+'; // keep\n\n      if (onChompKeep) onChompKeep();\n    }\n\n    wsEnd = ws.replace(/\\n$/, '');\n    return '';\n  }).replace(/^[\\n ]*/, ws => {\n    if (ws.indexOf(' ') !== -1) header += indentSize;\n    const m = ws.match(/ +$/);\n\n    if (m) {\n      wsStart = ws.slice(0, -m[0].length);\n      return m[0];\n    } else {\n      wsStart = ws;\n      return '';\n    }\n  });\n  if (wsEnd) wsEnd = wsEnd.replace(/\\n+(?!\\n|$)/g, `$&${indent}`);\n  if (wsStart) wsStart = wsStart.replace(/\\n+/g, `$&${indent}`);\n\n  if (comment) {\n    header += ' #' + comment.replace(/ ?[\\r\\n]+/g, ' ');\n    if (onComment) onComment();\n  }\n\n  if (!value) return `${header}${indentSize}\\n${indent}${wsEnd}`;\n\n  if (literal) {\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `${header}\\n${indent}${wsStart}${value}${wsEnd}`;\n  }\n\n  value = value.replace(/\\n+/g, '\\n$&').replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent\n  .replace(/\\n+/g, `$&${indent}`);\n  const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);\n  return `${header}\\n${indent}${body}`;\n}\n\nfunction plainString(item, ctx, onComment, onChompKeep) {\n  const {\n    comment,\n    type,\n    value\n  } = item;\n  const {\n    actualString,\n    implicitKey,\n    indent,\n    inFlow\n  } = ctx;\n\n  if (implicitKey && /[\\n[\\]{},]/.test(value) || inFlow && /[[\\]{},]/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n    // not allowed:\n    // - empty string, '-' or '?'\n    // - start with an indicator character (except [?:-]) or /[?-] /\n    // - '\\n ', ': ' or ' \\n' anywhere\n    // - '#' not preceded by a non-space char\n    // - end with ' ' or ':'\n    return implicitKey || inFlow || value.indexOf('\\n') === -1 ? value.indexOf('\"') !== -1 && value.indexOf(\"'\") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf('\\n') !== -1) {\n    // Where allowed & type not set explicitly, prefer block style for multiline strings\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (indent === '' && containsDocumentMarker(value)) {\n    ctx.forceBlockIndent = true;\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  const str = value.replace(/\\n+/g, `$&\\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and\n  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n  // and others in v1.1.\n\n  if (actualString) {\n    const {\n      tags\n    } = ctx.doc.schema;\n    const resolved = resolveScalar(str, tags, tags.scalarFallback).value;\n    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);\n  }\n\n  const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n\n  if (comment && !inFlow && (body.indexOf('\\n') !== -1 || comment.indexOf('\\n') !== -1)) {\n    if (onComment) onComment();\n    return addCommentBefore(body, indent, comment);\n  }\n\n  return body;\n}\n\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n  const {\n    defaultType\n  } = strOptions;\n  const {\n    implicitKey,\n    inFlow\n  } = ctx;\n  let {\n    type,\n    value\n  } = item;\n\n  if (typeof value !== 'string') {\n    value = String(value);\n    item = Object.assign({}, item, {\n      value\n    });\n  }\n\n  const _stringify = _type => {\n    switch (_type) {\n      case PlainValue.Type.BLOCK_FOLDED:\n      case PlainValue.Type.BLOCK_LITERAL:\n        return blockString(item, ctx, onComment, onChompKeep);\n\n      case PlainValue.Type.QUOTE_DOUBLE:\n        return doubleQuotedString(value, ctx);\n\n      case PlainValue.Type.QUOTE_SINGLE:\n        return singleQuotedString(value, ctx);\n\n      case PlainValue.Type.PLAIN:\n        return plainString(item, ctx, onComment, onChompKeep);\n\n      default:\n        return null;\n    }\n  };\n\n  if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f]/.test(value)) {\n    // force double quotes on control characters\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {\n    // should not happen; blocks are not valid inside flow containers\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  }\n\n  let res = _stringify(type);\n\n  if (res === null) {\n    res = _stringify(defaultType);\n    if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);\n  }\n\n  return res;\n}\n\nfunction stringifyNumber({\n  format,\n  minFractionDigits,\n  tag,\n  value\n}) {\n  if (typeof value === 'bigint') return String(value);\n  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';\n  let n = JSON.stringify(value);\n\n  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\\d/.test(n)) {\n    let i = n.indexOf('.');\n\n    if (i < 0) {\n      i = n.length;\n      n += '.';\n    }\n\n    let d = minFractionDigits - (n.length - i - 1);\n\n    while (d-- > 0) n += '0';\n  }\n\n  return n;\n}\n\nfunction checkFlowCollectionEnd(errors, cst) {\n  let char, name;\n\n  switch (cst.type) {\n    case PlainValue.Type.FLOW_MAP:\n      char = '}';\n      name = 'flow map';\n      break;\n\n    case PlainValue.Type.FLOW_SEQ:\n      char = ']';\n      name = 'flow sequence';\n      break;\n\n    default:\n      errors.push(new PlainValue.YAMLSemanticError(cst, 'Not a flow collection!?'));\n      return;\n  }\n\n  let lastItem;\n\n  for (let i = cst.items.length - 1; i >= 0; --i) {\n    const item = cst.items[i];\n\n    if (!item || item.type !== PlainValue.Type.COMMENT) {\n      lastItem = item;\n      break;\n    }\n  }\n\n  if (lastItem && lastItem.char !== char) {\n    const msg = `Expected ${name} to end with ${char}`;\n    let err;\n\n    if (typeof lastItem.offset === 'number') {\n      err = new PlainValue.YAMLSemanticError(cst, msg);\n      err.offset = lastItem.offset + 1;\n    } else {\n      err = new PlainValue.YAMLSemanticError(lastItem, msg);\n      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;\n    }\n\n    errors.push(err);\n  }\n}\nfunction checkFlowCommentSpace(errors, comment) {\n  const prev = comment.context.src[comment.range.start - 1];\n\n  if (prev !== '\\n' && prev !== '\\t' && prev !== ' ') {\n    const msg = 'Comments must be separated from other tokens by white space characters';\n    errors.push(new PlainValue.YAMLSemanticError(comment, msg));\n  }\n}\nfunction getLongKeyError(source, key) {\n  const sk = String(key);\n  const k = sk.substr(0, 8) + '...' + sk.substr(-8);\n  return new PlainValue.YAMLSemanticError(source, `The \"${k}\" key is too long`);\n}\nfunction resolveComments(collection, comments) {\n  for (const {\n    afterKey,\n    before,\n    comment\n  } of comments) {\n    let item = collection.items[before];\n\n    if (!item) {\n      if (comment !== undefined) {\n        if (collection.comment) collection.comment += '\\n' + comment;else collection.comment = comment;\n      }\n    } else {\n      if (afterKey && item.value) item = item.value;\n\n      if (comment === undefined) {\n        if (afterKey || !item.commentBefore) item.spaceBefore = true;\n      } else {\n        if (item.commentBefore) item.commentBefore += '\\n' + comment;else item.commentBefore = comment;\n      }\n    }\n  }\n}\n\n// on error, will return { str: string, errors: Error[] }\nfunction resolveString(doc, node) {\n  const res = node.strValue;\n  if (!res) return '';\n  if (typeof res === 'string') return res;\n  res.errors.forEach(error => {\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n  });\n  return res.str;\n}\n\nfunction resolveTagHandle(doc, node) {\n  const {\n    handle,\n    suffix\n  } = node.tag;\n  let prefix = doc.tagPrefixes.find(p => p.handle === handle);\n\n  if (!prefix) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    if (dtp) prefix = dtp.find(p => p.handle === handle);\n    if (!prefix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);\n  }\n\n  if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);\n\n  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {\n    if (suffix[0] === '^') {\n      doc.warnings.push(new PlainValue.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));\n      return suffix;\n    }\n\n    if (/[:/]/.test(suffix)) {\n      // word/foo -> tag:word.yaml.org,2002:foo\n      const vocab = suffix.match(/^([a-z0-9-]+)\\/(.*)/i);\n      return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;\n    }\n  }\n\n  return prefix.prefix + decodeURIComponent(suffix);\n}\n\nfunction resolveTagName(doc, node) {\n  const {\n    tag,\n    type\n  } = node;\n  let nonSpecific = false;\n\n  if (tag) {\n    const {\n      handle,\n      suffix,\n      verbatim\n    } = tag;\n\n    if (verbatim) {\n      if (verbatim !== '!' && verbatim !== '!!') return verbatim;\n      const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;\n      doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n    } else if (handle === '!' && !suffix) {\n      nonSpecific = true;\n    } else {\n      try {\n        return resolveTagHandle(doc, node);\n      } catch (error) {\n        doc.errors.push(error);\n      }\n    }\n  }\n\n  switch (type) {\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n    case PlainValue.Type.QUOTE_DOUBLE:\n    case PlainValue.Type.QUOTE_SINGLE:\n      return PlainValue.defaultTags.STR;\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    case PlainValue.Type.PLAIN:\n      return nonSpecific ? PlainValue.defaultTags.STR : null;\n\n    default:\n      return null;\n  }\n}\n\nfunction resolveByTagName(doc, node, tagName) {\n  const {\n    tags\n  } = doc.schema;\n  const matchWithTest = [];\n\n  for (const tag of tags) {\n    if (tag.tag === tagName) {\n      if (tag.test) matchWithTest.push(tag);else {\n        const res = tag.resolve(doc, node);\n        return res instanceof Collection ? res : new Scalar(res);\n      }\n    }\n  }\n\n  const str = resolveString(doc, node);\n  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);\n  return null;\n}\n\nfunction getFallbackTagName({\n  type\n}) {\n  switch (type) {\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    default:\n      return PlainValue.defaultTags.STR;\n  }\n}\n\nfunction resolveTag(doc, node, tagName) {\n  try {\n    const res = resolveByTagName(doc, node, tagName);\n\n    if (res) {\n      if (tagName && node.tag) res.tag = tagName;\n      return res;\n    }\n  } catch (error) {\n    /* istanbul ignore if */\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n    return null;\n  }\n\n  try {\n    const fallback = getFallbackTagName(node);\n    if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);\n    const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(node, msg));\n    const res = resolveByTagName(doc, node, fallback);\n    res.tag = tagName;\n    return res;\n  } catch (error) {\n    const refError = new PlainValue.YAMLReferenceError(node, error.message);\n    refError.stack = error.stack;\n    doc.errors.push(refError);\n    return null;\n  }\n}\n\nconst isCollectionItem = node => {\n  if (!node) return false;\n  const {\n    type\n  } = node;\n  return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;\n};\n\nfunction resolveNodeProps(errors, node) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let hasAnchor = false;\n  let hasTag = false;\n  const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;\n\n  for (const {\n    start,\n    end\n  } of props) {\n    switch (node.context.src[start]) {\n      case PlainValue.Char.COMMENT:\n        {\n          if (!node.commentHasRequiredWhitespace(start)) {\n            const msg = 'Comments must be separated from other tokens by white space characters';\n            errors.push(new PlainValue.YAMLSemanticError(node, msg));\n          }\n\n          const {\n            header,\n            valueRange\n          } = node;\n          const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;\n          cc.push(node.context.src.slice(start + 1, end));\n          break;\n        }\n      // Actual anchor & tag resolution is handled by schema, here we just complain\n\n      case PlainValue.Char.ANCHOR:\n        if (hasAnchor) {\n          const msg = 'A node can have at most one anchor';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasAnchor = true;\n        break;\n\n      case PlainValue.Char.TAG:\n        if (hasTag) {\n          const msg = 'A node can have at most one tag';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasTag = true;\n        break;\n    }\n  }\n\n  return {\n    comments,\n    hasAnchor,\n    hasTag\n  };\n}\n\nfunction resolveNodeValue(doc, node) {\n  const {\n    anchors,\n    errors,\n    schema\n  } = doc;\n\n  if (node.type === PlainValue.Type.ALIAS) {\n    const name = node.rawValue;\n    const src = anchors.getNode(name);\n\n    if (!src) {\n      const msg = `Aliased anchor not found: ${name}`;\n      errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    } // Lazy resolution for circular references\n\n\n    const res = new Alias(src);\n\n    anchors._cstAliases.push(res);\n\n    return res;\n  }\n\n  const tagName = resolveTagName(doc, node);\n  if (tagName) return resolveTag(doc, node, tagName);\n\n  if (node.type !== PlainValue.Type.PLAIN) {\n    const msg = `Failed to resolve ${node.type} node here`;\n    errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n    return null;\n  }\n\n  try {\n    const str = resolveString(doc, node);\n    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);\n  } catch (error) {\n    if (!error.source) error.source = node;\n    errors.push(error);\n    return null;\n  }\n} // sets node.resolved on success\n\n\nfunction resolveNode(doc, node) {\n  if (!node) return null;\n  if (node.error) doc.errors.push(node.error);\n  const {\n    comments,\n    hasAnchor,\n    hasTag\n  } = resolveNodeProps(doc.errors, node);\n\n  if (hasAnchor) {\n    const {\n      anchors\n    } = doc;\n    const name = node.anchor;\n    const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor\n    // name have already been resolved, so it may safely be renamed.\n\n    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as\n    // anchors need to be available during resolution to allow for\n    // circular references.\n\n    anchors.map[name] = node;\n  }\n\n  if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {\n    const msg = 'An alias node must not specify any properties';\n    doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n  }\n\n  const res = resolveNodeValue(doc, node);\n\n  if (res) {\n    res.range = [node.range.start, node.range.end];\n    if (doc.options.keepCstNodes) res.cstNode = node;\n    if (doc.options.keepNodeTypes) res.type = node.type;\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      res.commentBefore = res.commentBefore ? `${res.commentBefore}\\n${cb}` : cb;\n    }\n\n    const ca = comments.after.join('\\n');\n    if (ca) res.comment = res.comment ? `${res.comment}\\n${ca}` : ca;\n  }\n\n  return node.resolved = res;\n}\n\nfunction resolveMap(doc, cst) {\n  if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {\n    const msg = `A ${cst.type} node cannot be resolved as a mapping`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);\n  const map = new YAMLMap();\n  map.items = items;\n  resolveComments(map, comments);\n  let hasCollectionKey = false;\n\n  for (let i = 0; i < items.length; ++i) {\n    const {\n      key: iKey\n    } = items[i];\n    if (iKey instanceof Collection) hasCollectionKey = true;\n\n    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {\n      items[i] = new Merge(items[i]);\n      const sources = items[i].value.items;\n      let error = null;\n      sources.some(node => {\n        if (node instanceof Alias) {\n          // During parsing, alias sources are CST nodes; to account for\n          // circular references their resolved values can't be used here.\n          const {\n            type\n          } = node.source;\n          if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;\n          return error = 'Merge nodes aliases can only point to maps';\n        }\n\n        return error = 'Merge nodes can only have Alias nodes as values';\n      });\n      if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));\n    } else {\n      for (let j = i + 1; j < items.length; ++j) {\n        const {\n          key: jKey\n        } = items[j];\n\n        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {\n          const msg = `Map keys must be unique; \"${iKey}\" is repeated`;\n          doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));\n          break;\n        }\n      }\n    }\n  }\n\n  if (hasCollectionKey && !doc.options.mapAsMap) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = map;\n  return map;\n}\n\nconst valueHasPairComment = ({\n  context: {\n    lineStart,\n    node,\n    src\n  },\n  props\n}) => {\n  if (props.length === 0) return false;\n  const {\n    start\n  } = props[0];\n  if (node && start > node.valueRange.start) return false;\n  if (src[start] !== PlainValue.Char.COMMENT) return false;\n\n  for (let i = lineStart; i < start; ++i) if (src[i] === '\\n') return false;\n\n  return true;\n};\n\nfunction resolvePairComment(item, pair) {\n  if (!valueHasPairComment(item)) return;\n  const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);\n  let found = false;\n  const cb = pair.value.commentBefore;\n\n  if (cb && cb.startsWith(comment)) {\n    pair.value.commentBefore = cb.substr(comment.length + 1);\n    found = true;\n  } else {\n    const cc = pair.value.comment;\n\n    if (!item.node && cc && cc.startsWith(comment)) {\n      pair.value.comment = cc.substr(comment.length + 1);\n      found = true;\n    }\n  }\n\n  if (found) pair.comment = comment;\n}\n\nfunction resolveBlockMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let keyStart = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          afterKey: !!key,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          afterKey: !!key,\n          before: items.length,\n          comment: item.comment\n        });\n        break;\n\n      case PlainValue.Type.MAP_KEY:\n        if (key !== undefined) items.push(new Pair(key));\n        if (item.error) doc.errors.push(item.error);\n        key = resolveNode(doc, item.node);\n        keyStart = null;\n        break;\n\n      case PlainValue.Type.MAP_VALUE:\n        {\n          if (key === undefined) key = null;\n          if (item.error) doc.errors.push(item.error);\n\n          if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {\n            const msg = 'Nested mappings are not allowed in compact mappings';\n            doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));\n          }\n\n          let valueNode = item.node;\n\n          if (!valueNode && item.props.length > 0) {\n            // Comments on an empty mapping value need to be preserved, so we\n            // need to construct a minimal empty node here to use instead of the\n            // missing `item.node`. -- eemeli/yaml#19\n            valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);\n            valueNode.context = {\n              parent: item,\n              src: item.context.src\n            };\n            const pos = item.range.start + 1;\n            valueNode.range = {\n              start: pos,\n              end: pos\n            };\n            valueNode.valueRange = {\n              start: pos,\n              end: pos\n            };\n\n            if (typeof item.range.origStart === 'number') {\n              const origPos = item.range.origStart + 1;\n              valueNode.range.origStart = valueNode.range.origEnd = origPos;\n              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;\n            }\n          }\n\n          const pair = new Pair(key, resolveNode(doc, valueNode));\n          resolvePairComment(item, pair);\n          items.push(pair);\n\n          if (key && typeof keyStart === 'number') {\n            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n          }\n\n          key = undefined;\n          keyStart = null;\n        }\n        break;\n\n      default:\n        if (key !== undefined) items.push(new Pair(key));\n        key = resolveNode(doc, item);\n        keyStart = item.range.start;\n        if (item.error) doc.errors.push(item.error);\n\n        next: for (let j = i + 1;; ++j) {\n          const nextItem = cst.items[j];\n\n          switch (nextItem && nextItem.type) {\n            case PlainValue.Type.BLANK_LINE:\n            case PlainValue.Type.COMMENT:\n              continue next;\n\n            case PlainValue.Type.MAP_VALUE:\n              break next;\n\n            default:\n              {\n                const msg = 'Implicit map keys need to be followed by map values';\n                doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n                break next;\n              }\n          }\n        }\n\n        if (item.valueRangeContainsNewline) {\n          const msg = 'Implicit map keys need to be on a single line';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n    }\n  }\n\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let explicitKey = false;\n  let next = '{';\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char === '?' && key === undefined && !explicitKey) {\n        explicitKey = true;\n        next = ':';\n        continue;\n      }\n\n      if (char === ':') {\n        if (key === undefined) key = null;\n\n        if (next === ':') {\n          next = ',';\n          continue;\n        }\n      } else {\n        if (explicitKey) {\n          if (key === undefined && char !== ',') key = null;\n          explicitKey = false;\n        }\n\n        if (key !== undefined) {\n          items.push(new Pair(key));\n          key = undefined;\n\n          if (char === ',') {\n            next = ':';\n            continue;\n          }\n        }\n      }\n\n      if (char === '}') {\n        if (i === cst.items.length - 1) continue;\n      } else if (char === next) {\n        next = ':';\n        continue;\n      }\n\n      const msg = `Flow map contains an unexpected ${char}`;\n      const err = new PlainValue.YAMLSyntaxError(cst, msg);\n      err.offset = offset;\n      doc.errors.push(err);\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        afterKey: !!key,\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        afterKey: !!key,\n        before: items.length,\n        comment: item.comment\n      });\n    } else if (key === undefined) {\n      if (next === ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Separator , missing in flow map'));\n      key = resolveNode(doc, item);\n    } else {\n      if (next !== ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));\n      items.push(new Pair(key, resolveNode(doc, item)));\n      key = undefined;\n      explicitKey = false;\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveSeq(doc, cst) {\n  if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {\n    const msg = `A ${cst.type} node cannot be resolved as a sequence`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);\n  const seq = new YAMLSeq();\n  seq.items = items;\n  resolveComments(seq, comments);\n\n  if (!doc.options.mapAsMap && items.some(it => it instanceof Pair && it.key instanceof Collection)) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = seq;\n  return seq;\n}\n\nfunction resolveBlockSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          comment: item.comment,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.SEQ_ITEM:\n        if (item.error) doc.errors.push(item.error);\n        items.push(resolveNode(doc, item.node));\n\n        if (item.hasProps) {\n          const msg = 'Sequence items cannot have tags or anchors before the - indicator';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n        break;\n\n      default:\n        if (item.error) doc.errors.push(item.error);\n        doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));\n    }\n  }\n\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let explicitKey = false;\n  let key = undefined;\n  let keyStart = null;\n  let next = '[';\n  let prevItem = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char !== ':' && (explicitKey || key !== undefined)) {\n        if (explicitKey && key === undefined) key = next ? items.pop() : null;\n        items.push(new Pair(key));\n        explicitKey = false;\n        key = undefined;\n        keyStart = null;\n      }\n\n      if (char === next) {\n        next = null;\n      } else if (!next && char === '?') {\n        explicitKey = true;\n      } else if (next !== '[' && char === ':' && key === undefined) {\n        if (next === ',') {\n          key = items.pop();\n\n          if (key instanceof Pair) {\n            const msg = 'Chaining flow sequence pairs is invalid';\n            const err = new PlainValue.YAMLSemanticError(cst, msg);\n            err.offset = offset;\n            doc.errors.push(err);\n          }\n\n          if (!explicitKey && typeof keyStart === 'number') {\n            const keyEnd = item.range ? item.range.start : item.offset;\n            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n            const {\n              src\n            } = prevItem.context;\n\n            for (let i = keyStart; i < keyEnd; ++i) if (src[i] === '\\n') {\n              const msg = 'Implicit keys of flow sequence pairs need to be on a single line';\n              doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));\n              break;\n            }\n          }\n        } else {\n          key = null;\n        }\n\n        keyStart = null;\n        explicitKey = false;\n        next = null;\n      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {\n        const msg = `Flow sequence contains an unexpected ${char}`;\n        const err = new PlainValue.YAMLSyntaxError(cst, msg);\n        err.offset = offset;\n        doc.errors.push(err);\n      }\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        comment: item.comment,\n        before: items.length\n      });\n    } else {\n      if (next) {\n        const msg = `Expected a ${next} in flow sequence`;\n        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n      }\n\n      const value = resolveNode(doc, item);\n\n      if (key === undefined) {\n        items.push(value);\n        prevItem = item;\n      } else {\n        items.push(new Pair(key, value));\n        key = undefined;\n      }\n\n      keyStart = item.range.start;\n      next = ',';\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nexports.Alias = Alias;\nexports.Collection = Collection;\nexports.Merge = Merge;\nexports.Node = Node;\nexports.Pair = Pair;\nexports.Scalar = Scalar;\nexports.YAMLMap = YAMLMap;\nexports.YAMLSeq = YAMLSeq;\nexports.addComment = addComment;\nexports.binaryOptions = binaryOptions;\nexports.boolOptions = boolOptions;\nexports.findPair = findPair;\nexports.intOptions = intOptions;\nexports.isEmptyPath = isEmptyPath;\nexports.nullOptions = nullOptions;\nexports.resolveMap = resolveMap;\nexports.resolveNode = resolveNode;\nexports.resolveSeq = resolveSeq;\nexports.resolveString = resolveString;\nexports.strOptions = strOptions;\nexports.stringifyNumber = stringifyNumber;\nexports.stringifyString = stringifyString;\nexports.toJSON = toJSON;\n","module.exports = require(\"url\");","export { default } from \"./inputs\"\n","module.exports = require(\"http\");","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\nvar warnings = require('./warnings-39684f17.js');\n\nfunction createMap(schema, obj, ctx) {\n  const map = new resolveSeq.YAMLMap(schema);\n\n  if (obj instanceof Map) {\n    for (const [key, value] of obj) map.items.push(schema.createPair(key, value, ctx));\n  } else if (obj && typeof obj === 'object') {\n    for (const key of Object.keys(obj)) map.items.push(schema.createPair(key, obj[key], ctx));\n  }\n\n  if (typeof schema.sortMapEntries === 'function') {\n    map.items.sort(schema.sortMapEntries);\n  }\n\n  return map;\n}\n\nconst map = {\n  createNode: createMap,\n  default: true,\n  nodeClass: resolveSeq.YAMLMap,\n  tag: 'tag:yaml.org,2002:map',\n  resolve: resolveSeq.resolveMap\n};\n\nfunction createSeq(schema, obj, ctx) {\n  const seq = new resolveSeq.YAMLSeq(schema);\n\n  if (obj && obj[Symbol.iterator]) {\n    for (const it of obj) {\n      const v = schema.createNode(it, ctx.wrapScalars, null, ctx);\n      seq.items.push(v);\n    }\n  }\n\n  return seq;\n}\n\nconst seq = {\n  createNode: createSeq,\n  default: true,\n  nodeClass: resolveSeq.YAMLSeq,\n  tag: 'tag:yaml.org,2002:seq',\n  resolve: resolveSeq.resolveSeq\n};\n\nconst string = {\n  identify: value => typeof value === 'string',\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveSeq.resolveString,\n\n  stringify(item, ctx, onComment, onChompKeep) {\n    ctx = Object.assign({\n      actualString: true\n    }, ctx);\n    return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);\n  },\n\n  options: resolveSeq.strOptions\n};\n\nconst failsafe = [map, seq, string];\n\n/* global BigInt */\n\nconst intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);\n\nconst intResolve = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);\n\nfunction intStringify(node, radix, prefix) {\n  const {\n    value\n  } = node;\n  if (intIdentify(value) && value >= 0) return prefix + value.toString(radix);\n  return resolveSeq.stringifyNumber(node);\n}\n\nconst nullObj = {\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: () => null,\n  options: resolveSeq.nullOptions,\n  stringify: () => resolveSeq.nullOptions.nullStr\n};\nconst boolObj = {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n  resolve: str => str[0] === 't' || str[0] === 'T',\n  options: resolveSeq.boolOptions,\n  stringify: ({\n    value\n  }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr\n};\nconst octObj = {\n  identify: value => intIdentify(value) && value >= 0,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^0o([0-7]+)$/,\n  resolve: (str, oct) => intResolve(str, oct, 8),\n  options: resolveSeq.intOptions,\n  stringify: node => intStringify(node, 8, '0o')\n};\nconst intObj = {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^[-+]?[0-9]+$/,\n  resolve: str => intResolve(str, str, 10),\n  options: resolveSeq.intOptions,\n  stringify: resolveSeq.stringifyNumber\n};\nconst hexObj = {\n  identify: value => intIdentify(value) && value >= 0,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^0x([0-9a-fA-F]+)$/,\n  resolve: (str, hex) => intResolve(str, hex, 16),\n  options: resolveSeq.intOptions,\n  stringify: node => intStringify(node, 16, '0x')\n};\nconst nanObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,\n  stringify: resolveSeq.stringifyNumber\n};\nconst expObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n  resolve: str => parseFloat(str),\n  stringify: ({\n    value\n  }) => Number(value).toExponential()\n};\nconst floatObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:\\.([0-9]+)|[0-9]+\\.([0-9]*))$/,\n\n  resolve(str, frac1, frac2) {\n    const frac = frac1 || frac2;\n    const node = new resolveSeq.Scalar(parseFloat(str));\n    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;\n    return node;\n  },\n\n  stringify: resolveSeq.stringifyNumber\n};\nconst core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);\n\n/* global BigInt */\n\nconst intIdentify$1 = value => typeof value === 'bigint' || Number.isInteger(value);\n\nconst stringifyJSON = ({\n  value\n}) => JSON.stringify(value);\n\nconst json = [map, seq, {\n  identify: value => typeof value === 'string',\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveSeq.resolveString,\n  stringify: stringifyJSON\n}, {\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^null$/,\n  resolve: () => null,\n  stringify: stringifyJSON\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^true|false$/,\n  resolve: str => str === 'true',\n  stringify: stringifyJSON\n}, {\n  identify: intIdentify$1,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^-?(?:0|[1-9][0-9]*)$/,\n  resolve: str => resolveSeq.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),\n  stringify: ({\n    value\n  }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n  resolve: str => parseFloat(str),\n  stringify: stringifyJSON\n}];\n\njson.scalarFallback = str => {\n  throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n};\n\n/* global BigInt */\n\nconst boolStringify = ({\n  value\n}) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;\n\nconst intIdentify$2 = value => typeof value === 'bigint' || Number.isInteger(value);\n\nfunction intResolve$1(sign, src, radix) {\n  let str = src.replace(/_/g, '');\n\n  if (resolveSeq.intOptions.asBigInt) {\n    switch (radix) {\n      case 2:\n        str = `0b${str}`;\n        break;\n\n      case 8:\n        str = `0o${str}`;\n        break;\n\n      case 16:\n        str = `0x${str}`;\n        break;\n    }\n\n    const n = BigInt(str);\n    return sign === '-' ? BigInt(-1) * n : n;\n  }\n\n  const n = parseInt(str, radix);\n  return sign === '-' ? -1 * n : n;\n}\n\nfunction intStringify$1(node, radix, prefix) {\n  const {\n    value\n  } = node;\n\n  if (intIdentify$2(value)) {\n    const str = value.toString(radix);\n    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n  }\n\n  return resolveSeq.stringifyNumber(node);\n}\n\nconst yaml11 = failsafe.concat([{\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: () => null,\n  options: resolveSeq.nullOptions,\n  stringify: () => resolveSeq.nullOptions.nullStr\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n  resolve: () => true,\n  options: resolveSeq.boolOptions,\n  stringify: boolStringify\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,\n  resolve: () => false,\n  options: resolveSeq.boolOptions,\n  stringify: boolStringify\n}, {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'BIN',\n  test: /^([-+]?)0b([0-1_]+)$/,\n  resolve: (str, sign, bin) => intResolve$1(sign, bin, 2),\n  stringify: node => intStringify$1(node, 2, '0b')\n}, {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^([-+]?)0([0-7_]+)$/,\n  resolve: (str, sign, oct) => intResolve$1(sign, oct, 8),\n  stringify: node => intStringify$1(node, 8, '0')\n}, {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^([-+]?)([0-9][0-9_]*)$/,\n  resolve: (str, sign, abs) => intResolve$1(sign, abs, 10),\n  stringify: resolveSeq.stringifyNumber\n}, {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,\n  resolve: (str, sign, hex) => intResolve$1(sign, hex, 16),\n  stringify: node => intStringify$1(node, 16, '0x')\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,\n  stringify: resolveSeq.stringifyNumber\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?([0-9][0-9_]*)?(\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n  resolve: str => parseFloat(str.replace(/_/g, '')),\n  stringify: ({\n    value\n  }) => Number(value).toExponential()\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:[0-9][0-9_]*)?\\.([0-9_]*)$/,\n\n  resolve(str, frac) {\n    const node = new resolveSeq.Scalar(parseFloat(str.replace(/_/g, '')));\n\n    if (frac) {\n      const f = frac.replace(/_/g, '');\n      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;\n    }\n\n    return node;\n  },\n\n  stringify: resolveSeq.stringifyNumber\n}], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);\n\nconst schemas = {\n  core,\n  failsafe,\n  json,\n  yaml11\n};\nconst tags = {\n  binary: warnings.binary,\n  bool: boolObj,\n  float: floatObj,\n  floatExp: expObj,\n  floatNaN: nanObj,\n  floatTime: warnings.floatTime,\n  int: intObj,\n  intHex: hexObj,\n  intOct: octObj,\n  intTime: warnings.intTime,\n  map,\n  null: nullObj,\n  omap: warnings.omap,\n  pairs: warnings.pairs,\n  seq,\n  set: warnings.set,\n  timestamp: warnings.timestamp\n};\n\nfunction findTagObject(value, tagName, tags) {\n  if (tagName) {\n    const match = tags.filter(t => t.tag === tagName);\n    const tagObj = match.find(t => !t.format) || match[0];\n    if (!tagObj) throw new Error(`Tag ${tagName} not found`);\n    return tagObj;\n  } // TODO: deprecate/remove class check\n\n\n  return tags.find(t => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);\n}\n\nfunction createNode(value, tagName, ctx) {\n  if (value instanceof resolveSeq.Node) return value;\n  const {\n    defaultPrefix,\n    onTagObj,\n    prevObjects,\n    schema,\n    wrapScalars\n  } = ctx;\n  if (tagName && tagName.startsWith('!!')) tagName = defaultPrefix + tagName.slice(2);\n  let tagObj = findTagObject(value, tagName, schema.tags);\n\n  if (!tagObj) {\n    if (typeof value.toJSON === 'function') value = value.toJSON();\n    if (typeof value !== 'object') return wrapScalars ? new resolveSeq.Scalar(value) : value;\n    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;\n  }\n\n  if (onTagObj) {\n    onTagObj(tagObj);\n    delete ctx.onTagObj;\n  } // Detect duplicate references to the same object & use Alias nodes for all\n  // after first. The `obj` wrapper allows for circular references to resolve.\n\n\n  const obj = {};\n\n  if (value && typeof value === 'object' && prevObjects) {\n    const prev = prevObjects.get(value);\n\n    if (prev) {\n      const alias = new resolveSeq.Alias(prev); // leaves source dirty; must be cleaned by caller\n\n      ctx.aliasNodes.push(alias); // defined along with prevObjects\n\n      return alias;\n    }\n\n    obj.value = value;\n    prevObjects.set(value, obj);\n  }\n\n  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;\n  if (tagName && obj.node instanceof resolveSeq.Node) obj.node.tag = tagName;\n  return obj.node;\n}\n\nfunction getSchemaTags(schemas, knownTags, customTags, schemaId) {\n  let tags = schemas[schemaId.replace(/\\W/g, '')]; // 'yaml-1.1' -> 'yaml11'\n\n  if (!tags) {\n    const keys = Object.keys(schemas).map(key => JSON.stringify(key)).join(', ');\n    throw new Error(`Unknown schema \"${schemaId}\"; use one of ${keys}`);\n  }\n\n  if (Array.isArray(customTags)) {\n    for (const tag of customTags) tags = tags.concat(tag);\n  } else if (typeof customTags === 'function') {\n    tags = customTags(tags.slice());\n  }\n\n  for (let i = 0; i < tags.length; ++i) {\n    const tag = tags[i];\n\n    if (typeof tag === 'string') {\n      const tagObj = knownTags[tag];\n\n      if (!tagObj) {\n        const keys = Object.keys(knownTags).map(key => JSON.stringify(key)).join(', ');\n        throw new Error(`Unknown custom tag \"${tag}\"; use one of ${keys}`);\n      }\n\n      tags[i] = tagObj;\n    }\n  }\n\n  return tags;\n}\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\n\nclass Schema {\n  // TODO: remove in v2\n  // TODO: remove in v2\n  constructor({\n    customTags,\n    merge,\n    schema,\n    sortMapEntries,\n    tags: deprecatedCustomTags\n  }) {\n    this.merge = !!merge;\n    this.name = schema;\n    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;\n    if (!customTags && deprecatedCustomTags) warnings.warnOptionDeprecation('tags', 'customTags');\n    this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);\n  }\n\n  createNode(value, wrapScalars, tagName, ctx) {\n    const baseCtx = {\n      defaultPrefix: Schema.defaultPrefix,\n      schema: this,\n      wrapScalars\n    };\n    const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;\n    return createNode(value, tagName, createCtx);\n  }\n\n  createPair(key, value, ctx) {\n    if (!ctx) ctx = {\n      wrapScalars: true\n    };\n    const k = this.createNode(key, ctx.wrapScalars, null, ctx);\n    const v = this.createNode(value, ctx.wrapScalars, null, ctx);\n    return new resolveSeq.Pair(k, v);\n  }\n\n}\n\nPlainValue._defineProperty(Schema, \"defaultPrefix\", PlainValue.defaultTagPrefix);\n\nPlainValue._defineProperty(Schema, \"defaultTags\", PlainValue.defaultTags);\n\nexports.Schema = Schema;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\n\n/* global atob, btoa, Buffer */\nconst binary = {\n  identify: value => value instanceof Uint8Array,\n  // Buffer inherits from Uint8Array\n  default: false,\n  tag: 'tag:yaml.org,2002:binary',\n\n  /**\n   * Returns a Buffer in node and an Uint8Array in browsers\n   *\n   * To use the resulting buffer as an image, you'll want to do something like:\n   *\n   *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n   *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n   */\n  resolve: (doc, node) => {\n    const src = resolveSeq.resolveString(doc, node);\n\n    if (typeof Buffer === 'function') {\n      return Buffer.from(src, 'base64');\n    } else if (typeof atob === 'function') {\n      // On IE 11, atob() can't handle newlines\n      const str = atob(src.replace(/[\\n\\r]/g, ''));\n      const buffer = new Uint8Array(str.length);\n\n      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);\n\n      return buffer;\n    } else {\n      const msg = 'This environment does not support reading binary tags; either Buffer or atob is required';\n      doc.errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    }\n  },\n  options: resolveSeq.binaryOptions,\n  stringify: ({\n    comment,\n    type,\n    value\n  }, ctx, onComment, onChompKeep) => {\n    let src;\n\n    if (typeof Buffer === 'function') {\n      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');\n    } else if (typeof btoa === 'function') {\n      let s = '';\n\n      for (let i = 0; i < value.length; ++i) s += String.fromCharCode(value[i]);\n\n      src = btoa(s);\n    } else {\n      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n    }\n\n    if (!type) type = resolveSeq.binaryOptions.defaultType;\n\n    if (type === PlainValue.Type.QUOTE_DOUBLE) {\n      value = src;\n    } else {\n      const {\n        lineWidth\n      } = resolveSeq.binaryOptions;\n      const n = Math.ceil(src.length / lineWidth);\n      const lines = new Array(n);\n\n      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n        lines[i] = src.substr(o, lineWidth);\n      }\n\n      value = lines.join(type === PlainValue.Type.BLOCK_LITERAL ? '\\n' : ' ');\n    }\n\n    return resolveSeq.stringifyString({\n      comment,\n      type,\n      value\n    }, ctx, onComment, onChompKeep);\n  }\n};\n\nfunction parsePairs(doc, cst) {\n  const seq = resolveSeq.resolveSeq(doc, cst);\n\n  for (let i = 0; i < seq.items.length; ++i) {\n    let item = seq.items[i];\n    if (item instanceof resolveSeq.Pair) continue;else if (item instanceof resolveSeq.YAMLMap) {\n      if (item.items.length > 1) {\n        const msg = 'Each pair must have its own sequence indicator';\n        throw new PlainValue.YAMLSemanticError(cst, msg);\n      }\n\n      const pair = item.items[0] || new resolveSeq.Pair();\n      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? `${item.commentBefore}\\n${pair.commentBefore}` : item.commentBefore;\n      if (item.comment) pair.comment = pair.comment ? `${item.comment}\\n${pair.comment}` : item.comment;\n      item = pair;\n    }\n    seq.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);\n  }\n\n  return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n  const pairs = new resolveSeq.YAMLSeq(schema);\n  pairs.tag = 'tag:yaml.org,2002:pairs';\n\n  for (const it of iterable) {\n    let key, value;\n\n    if (Array.isArray(it)) {\n      if (it.length === 2) {\n        key = it[0];\n        value = it[1];\n      } else throw new TypeError(`Expected [key, value] tuple: ${it}`);\n    } else if (it && it instanceof Object) {\n      const keys = Object.keys(it);\n\n      if (keys.length === 1) {\n        key = keys[0];\n        value = it[key];\n      } else throw new TypeError(`Expected { key: value } tuple: ${it}`);\n    } else {\n      key = it;\n    }\n\n    const pair = schema.createPair(key, value, ctx);\n    pairs.items.push(pair);\n  }\n\n  return pairs;\n}\nconst pairs = {\n  default: false,\n  tag: 'tag:yaml.org,2002:pairs',\n  resolve: parsePairs,\n  createNode: createPairs\n};\n\nclass YAMLOMap extends resolveSeq.YAMLSeq {\n  constructor() {\n    super();\n\n    PlainValue._defineProperty(this, \"add\", resolveSeq.YAMLMap.prototype.add.bind(this));\n\n    PlainValue._defineProperty(this, \"delete\", resolveSeq.YAMLMap.prototype.delete.bind(this));\n\n    PlainValue._defineProperty(this, \"get\", resolveSeq.YAMLMap.prototype.get.bind(this));\n\n    PlainValue._defineProperty(this, \"has\", resolveSeq.YAMLMap.prototype.has.bind(this));\n\n    PlainValue._defineProperty(this, \"set\", resolveSeq.YAMLMap.prototype.set.bind(this));\n\n    this.tag = YAMLOMap.tag;\n  }\n\n  toJSON(_, ctx) {\n    const map = new Map();\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const pair of this.items) {\n      let key, value;\n\n      if (pair instanceof resolveSeq.Pair) {\n        key = resolveSeq.toJSON(pair.key, '', ctx);\n        value = resolveSeq.toJSON(pair.value, key, ctx);\n      } else {\n        key = resolveSeq.toJSON(pair, '', ctx);\n      }\n\n      if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');\n      map.set(key, value);\n    }\n\n    return map;\n  }\n\n}\n\nPlainValue._defineProperty(YAMLOMap, \"tag\", 'tag:yaml.org,2002:omap');\n\nfunction parseOMap(doc, cst) {\n  const pairs = parsePairs(doc, cst);\n  const seenKeys = [];\n\n  for (const {\n    key\n  } of pairs.items) {\n    if (key instanceof resolveSeq.Scalar) {\n      if (seenKeys.includes(key.value)) {\n        const msg = 'Ordered maps must not include duplicate keys';\n        throw new PlainValue.YAMLSemanticError(cst, msg);\n      } else {\n        seenKeys.push(key.value);\n      }\n    }\n  }\n\n  return Object.assign(new YAMLOMap(), pairs);\n}\n\nfunction createOMap(schema, iterable, ctx) {\n  const pairs = createPairs(schema, iterable, ctx);\n  const omap = new YAMLOMap();\n  omap.items = pairs.items;\n  return omap;\n}\n\nconst omap = {\n  identify: value => value instanceof Map,\n  nodeClass: YAMLOMap,\n  default: false,\n  tag: 'tag:yaml.org,2002:omap',\n  resolve: parseOMap,\n  createNode: createOMap\n};\n\nclass YAMLSet extends resolveSeq.YAMLMap {\n  constructor() {\n    super();\n    this.tag = YAMLSet.tag;\n  }\n\n  add(key) {\n    const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);\n    const prev = resolveSeq.findPair(this.items, pair.key);\n    if (!prev) this.items.push(pair);\n  }\n\n  get(key, keepPair) {\n    const pair = resolveSeq.findPair(this.items, key);\n    return !keepPair && pair instanceof resolveSeq.Pair ? pair.key instanceof resolveSeq.Scalar ? pair.key.value : pair.key : pair;\n  }\n\n  set(key, value) {\n    if (typeof value !== 'boolean') throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n    const prev = resolveSeq.findPair(this.items, key);\n\n    if (prev && !value) {\n      this.items.splice(this.items.indexOf(prev), 1);\n    } else if (!prev && value) {\n      this.items.push(new resolveSeq.Pair(key));\n    }\n  }\n\n  toJSON(_, ctx) {\n    return super.toJSON(_, ctx, Set);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');\n  }\n\n}\n\nPlainValue._defineProperty(YAMLSet, \"tag\", 'tag:yaml.org,2002:set');\n\nfunction parseSet(doc, cst) {\n  const map = resolveSeq.resolveMap(doc, cst);\n  if (!map.hasAllNullValues()) throw new PlainValue.YAMLSemanticError(cst, 'Set items must all have null values');\n  return Object.assign(new YAMLSet(), map);\n}\n\nfunction createSet(schema, iterable, ctx) {\n  const set = new YAMLSet();\n\n  for (const value of iterable) set.items.push(schema.createPair(value, null, ctx));\n\n  return set;\n}\n\nconst set = {\n  identify: value => value instanceof Set,\n  nodeClass: YAMLSet,\n  default: false,\n  tag: 'tag:yaml.org,2002:set',\n  resolve: parseSet,\n  createNode: createSet\n};\n\nconst parseSexagesimal = (sign, parts) => {\n  const n = parts.split(':').reduce((n, p) => n * 60 + Number(p), 0);\n  return sign === '-' ? -n : n;\n}; // hhhh:mm:ss.sss\n\n\nconst stringifySexagesimal = ({\n  value\n}) => {\n  if (isNaN(value) || !isFinite(value)) return resolveSeq.stringifyNumber(value);\n  let sign = '';\n\n  if (value < 0) {\n    sign = '-';\n    value = Math.abs(value);\n  }\n\n  const parts = [value % 60]; // seconds, including ms\n\n  if (value < 60) {\n    parts.unshift(0); // at least one : is required\n  } else {\n    value = Math.round((value - parts[0]) / 60);\n    parts.unshift(value % 60); // minutes\n\n    if (value >= 60) {\n      value = Math.round((value - parts[0]) / 60);\n      parts.unshift(value); // hours\n    }\n  }\n\n  return sign + parts.map(n => n < 10 ? '0' + String(n) : String(n)).join(':').replace(/000000\\d*$/, '') // % 60 may introduce error\n  ;\n};\n\nconst intTime = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,\n  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),\n  stringify: stringifySexagesimal\n};\nconst floatTime = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*)$/,\n  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),\n  stringify: stringifySexagesimal\n};\nconst timestamp = {\n  identify: value => value instanceof Date,\n  default: true,\n  tag: 'tag:yaml.org,2002:timestamp',\n  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n  // may be omitted altogether, resulting in a date format. In such a case, the time part is\n  // assumed to be 00:00:00Z (start of day, UTC).\n  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n  '(?:(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n  '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n  ')?' + ')$'),\n  resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {\n    if (millisec) millisec = (millisec + '00').substr(1, 3);\n    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);\n\n    if (tz && tz !== 'Z') {\n      let d = parseSexagesimal(tz[0], tz.slice(1));\n      if (Math.abs(d) < 30) d *= 60;\n      date -= 60000 * d;\n    }\n\n    return new Date(date);\n  },\n  stringify: ({\n    value\n  }) => value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, '')\n};\n\n/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */\nfunction shouldWarn(deprecation) {\n  const env = typeof process !== 'undefined' && process.env || {};\n\n  if (deprecation) {\n    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;\n    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;\n  }\n\n  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;\n  return !env.YAML_SILENCE_WARNINGS;\n}\n\nfunction warn(warning, type) {\n  if (shouldWarn(false)) {\n    const emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to\n    // https://github.com/facebook/jest/issues/2549\n\n    if (emit) emit(warning, type);else {\n      // eslint-disable-next-line no-console\n      console.warn(type ? `${type}: ${warning}` : warning);\n    }\n  }\n}\nfunction warnFileDeprecation(filename) {\n  if (shouldWarn(true)) {\n    const path = filename.replace(/.*yaml[/\\\\]/i, '').replace(/\\.js$/, '').replace(/\\\\/g, '/');\n    warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, 'DeprecationWarning');\n  }\n}\nconst warned = {};\nfunction warnOptionDeprecation(name, alternative) {\n  if (!warned[name] && shouldWarn(true)) {\n    warned[name] = true;\n    let msg = `The option '${name}' will be removed in a future release`;\n    msg += alternative ? `, use '${alternative}' instead.` : '.';\n    warn(msg, 'DeprecationWarning');\n  }\n}\n\nexports.binary = binary;\nexports.floatTime = floatTime;\nexports.intTime = intTime;\nexports.omap = omap;\nexports.pairs = pairs;\nexports.set = set;\nexports.timestamp = timestamp;\nexports.warn = warn;\nexports.warnFileDeprecation = warnFileDeprecation;\nexports.warnOptionDeprecation = warnOptionDeprecation;\n","module.exports = require(\"https\");","// The module 'vscode' contains the VS Code extensibility API\n// tslint:disable-next-line: no-implicit-dependencies\nimport * as VSC from 'vscode'\nimport Util from './util'\nimport View from './view'\nimport Fonts from './fonts'\nimport Module from './module'\nimport Template from './template'\nimport Translation from './translation'\n\n// this method is called when your extension is activated\nexport function activate(context: VSC.ExtensionContext) {\n    // The command has been defined in the package.json file\n    // Now provide the implementation of the command with registerCommand\n    // The commandId parameter must match the command field in package.json\n    const LEFT = 1\n    const RIGHT = 2\n    // Define where to open a window when switching.\n    const actions: Array<[string, number]> = [\n        [\"css\", RIGHT],\n        [\"js\", LEFT],\n        [\"test\", RIGHT],\n        [\"json\", RIGHT],\n        [\"yaml\", RIGHT],\n        [\"frag\", LEFT],\n        [\"vert\", LEFT]\n    ]\n    for (const action of actions) {\n        const [extension, viewColumn] = action\n        const id = `toloframework-vscode-extension.switchTo${extension.toUpperCase()}`\n        const disposable = VSC.commands.registerCommand(\n            id,\n            () => switchTo(extension, viewColumn)\n        )\n        context.subscriptions.push(disposable)\n    }\n\n    context.subscriptions.push(\n        VSC.commands.registerCommand(\n            \"toloframework-vscode-extension.compileTranslationYAML\",\n            Translation.compileYAML\n        )\n    )\n\n    context.subscriptions.push(\n        VSC.commands.registerCommand(\n            \"toloframework-vscode-extension.importFont\",\n            Fonts.load\n        )\n    )\n\n    context.subscriptions.push(\n        VSC.commands.registerCommand(\n            \"toloframework-vscode-extension.createModule\",\n            Module.exec\n        )\n    )\n\n    context.subscriptions.push(\n        VSC.commands.registerCommand(\n            \"toloframework-vscode-extension.createFromTemplate\",\n            Template.exec\n        )\n    )\n\n    context.subscriptions.push(\n        VSC.commands.registerCommand(\n            \"toloframework-vscode-extension.createView\",\n            View.exec\n        )\n    )\n\n    context.subscriptions.push(\n        VSC.commands.registerCommand(\n            'toloframework-vscode-extension.help',\n            () => {\n                const panel = VSC.window.createWebviewPanel(\n                    'help',\n                    'TFW Documentation',\n                    VSC.ViewColumn.Beside,\n                    {\n                        enableScripts: true,\n                        enableCommandUris: true\n                    }\n                )\n                panel.webview.html = `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <style>\n        html, body, iframe {\n            position: absolute;\n            left: 0;\n            top: 0;\n            bottom: 0;\n            right: 0;\n            border: none;\n            margin: 0;\n            padding: 0;\n        }\n    </style>\n</head>\n<body>\n    <iframe src=\"https://tolokoban.github.io/tfw\"></iframe>\n</body>\n</html>`\n            }\n        )\n    )\n}\n\n// this method is called when your extension is deactivated\n// tslint:disable-next-line: no-empty\nexport function deactivate() { }\n\n\nconst EXTENSION_FALLBACKS: { [key: string]: string[] } = {\n    js: [\"ts\", \"tsx\", \"js\", \"jsx\"],\n    json: [\"json\", \"jsn\", \"yaml\", \"yml\"],\n    yaml: [\"yaml\", \"yml\", \"json\", \"jsn\"]\n}\nasync function switchTo(extension: string, viewColumn: number) {\n    console.log(\"[switchTo()] extension = \", extension) // @FIXME: Remove this line written on 2021-01-05 at 11:34\n    const activeEditor = VSC.window.activeTextEditor\n    if (!activeEditor) {\n        VSC.window.showErrorMessage(\"No active text editor!\")\n        return\n    }\n\n    const extensions: string[] = getExtensionsToCheck(extension, activeEditor)\n    console.log(\"[switchTo()] extensions = \", extensions) // @FIXME: Remove this line written on 2021-01-05 at 11:36\n    if (await openFileIfExists(extensions, viewColumn, activeEditor)) return\n\n    // File does not exist.\n    // We need to create it.\n    const [preferedExtension] = extensions\n    const filename: string = Util.changeExtension(\n        activeEditor.document.fileName,\n        preferedExtension\n    )\n    Util.writeTextFile(\n        filename,\n        getInitialContent(preferedExtension, activeEditor.document.fileName)\n    )\n    const doc = await Util.openTextDocument(filename)\n    if (doc !== null) {\n        VSC.window.showTextDocument(doc, { viewColumn })\n    } else {\n        VSC.window.showErrorMessage(\n            `File not found:  \\n\\`${filename}\\``\n        )\n    }\n}\n\nasync function openFileIfExists(\n    extensions: string[],\n    viewColumn: number,\n    activeEditor: VSC.TextEditor\n) {\n    for (const ext of extensions) {\n        const filename: string = Util.changeExtension(\n            activeEditor.document.fileName,\n            ext\n        )\n        if (!Util.exists(filename)) continue\n\n        const doc = await Util.openTextDocument(filename)\n        if (doc === null) return false\n        VSC.window.showTextDocument(doc, { viewColumn })\n        return true\n    }\n\n    return false\n}\n\nfunction getExtensionsToCheck(extension: string, activeEditor: VSC.TextEditor): string[] {\n    if (extension !== 'test') {\n        return EXTENSION_FALLBACKS[extension] ?? [extension]\n    }\n\n    const moduleExtensions = EXTENSION_FALLBACKS[\"js\"]\n    for (const modExt of moduleExtensions) {\n        const filename: string = Util.changeExtension(\n            activeEditor.document.fileName,\n            modExt\n        )\n        if (Util.exists(filename)) {\n            return [`test.${modExt}`, `spec.${modExt}`]\n        }\n    }\n\n    const fallbacks: string[] = []\n    for (const modExt of moduleExtensions) {\n        fallbacks.push(`test.${modExt}`, `spec.${modExt}`)\n    }\n\n    return fallbacks\n}\n\nfunction getInitialContent(extension: string, originFileName: string) {\n    if (extension.startsWith(\"test.\") || extension.startsWith(\"spec.\")) {\n        return getInitialContentTest(originFileName)\n    }\n    switch (extension) {\n        case \"yaml\": return getInitialContentYAML(originFileName)\n        case \"frag\": return getInitialContentFRAG(originFileName)\n        case \"vert\": return getInitialContentVERT(originFileName)\n    }\n    return \"\"\n}\n\nfunction getInitialContentVERT(path: string) {\n    const filename = Util.removeExtension(Util.makeRelativeToSource(path))\n\n    return `// ${filename}.vert\nattribute vec4 attPoint;\n\nvoid main() {\n    gl_Position = attPoint;\n}`\n}\n\nfunction getInitialContentFRAG(path: string) {\n    const filename = Util.removeExtension(Util.makeRelativeToSource(path))\n\n    return `// ${filename}.frag\nprecision mediump float;\n\nvoid main() {\n    gl_FragColor = vec4(1.0, 0.5, 0.0, 1.0);\n}`\n}\n\nfunction getInitialContentYAML(originFileName: string) {\n    return \"en:\\n    cancel: Cancel\\n    ok: Ok\\nfr:\\n    cancel: Annuler\\n    ok: Valider\\n\"\n}\n\nfunction getInitialContentTest(originFileName: string) {\n    if (originFileName.endsWith(\"x\")) return getInitialContentTestView(originFileName)\n\n    const modName = Util.fileNameToModuleName(originFileName)\n    const filename = Util.removeExtension(Util.getBasename(originFileName))\n    return `import ${modName} from './${filename}'\n\ndescribe('${Util.makeRelativeToSource(originFileName)}', () => {\n    // @TODO: Implement tests.\n    describe('${modName}.foo()', () => {\n        it('should ...', () => {\n            const got = ${modName}.foo()\n            const exp = null\n            expect(got).toEqual(exp)\n        })\n    })\n})\n`\n}\n\nfunction getInitialContentTestView(originFileName: string) {\n    const viewname = Util.fileNameToModuleName(originFileName)\n    const filename = Util.removeExtension(Util.getBasename(originFileName))\n    const folder = Util.getDirectory(Util.makeRelativeToSource(originFileName))\n\n    return `// To test a React component, you need to install these modules:\n// yarn add --dev react-test-renderer @types/react-test-renderer\n// @see https://jestjs.io/docs/en/snapshot-testing\n//\n// If a test failed because you intended to improve the component, just call\n// jest --updateSnapshot testNamePattern \"${Util.makeRelativeToSource(originFileName)}\"\n\nimport React from 'react'\nimport Renderer from 'react-test-renderer'\nimport ${viewname}, { I${viewname}Props } from './${filename}'\n\nfunction view(partialProps: Partial<I${viewname}Props>) {\n    const props: I${viewname}Props = {\n        // @TODO Set default props.\n        ...partialProps\n    }\n    return Renderer.create(<${viewname} {...props} />).toJSON()\n}\n\ndescribe('<${viewname}/> in ${folder}', () => {\n    it('should be consistent with previous snapshot', () => {\n        expect(view({})).toMatchSnapshot()\n    })\n})\n`\n}\n","export { default } from \"./view\"","import * as X from 'vscode'\nimport * as FS from \"fs\"\nimport * as Path from \"path\"\nimport Util from '../util'\nimport Inputs from '../inputs'\nimport TplView from './tpl/view'\nimport TplStyle from './tpl/style'\nimport TplTester from './tpl/tester'\nimport TplContainer from './tpl/container'\n\nexport default {\n    exec\n}\n\nasync function exec() {\n    const folder = await Inputs.selectFolder(\"Root folder for your new VIEW\")\n    if (!folder) return\n    const relativeFolder = Util.makeRelativeToSource(folder)\n    const folderName = Path.basename(folder)\n    let viewName = await Inputs.promptForName(\"View's filename:\")\n    if (!viewName) return\n    const destinationFolder = Path.resolve(folder, viewName)\n    if (Util.exists(destinationFolder)) {\n        X.window.showErrorMessage(\n            `This folder already exists!\\n${destinationFolder}`,\n            { modal: true }\n        )\n        return\n    }\n    await X.workspace.fs.createDirectory(X.Uri.file(destinationFolder))\n\n    if (folderName !== 'src') {\n        const moduleSuffix = await X.window.showInputBox({\n            prompt: \"View's name suffix (press ESC if you don't want any)\",\n            value: folderName,\n            validateInput: Util.isKebabCase\n        })\n        if (moduleSuffix) {\n            viewName += `-${moduleSuffix.trim()}`\n        }\n    }\n\n    const save = writeFile.bind(null, destinationFolder)\n    save(\"index.ts\", `export { default } from './${viewName}'\\n// export { default } from './${viewName}.container'\\n`)\n    save(`${viewName}.yaml`, `en:\\n    ok: OK\\nfr:\\n    ok: Valider\\n`)\n    save(`${viewName}.tsx`, TplView(viewName, relativeFolder))\n    save(`${viewName}.css`, TplStyle(viewName, relativeFolder))\n    save(`${viewName}.test.tsx`, TplTester(viewName, relativeFolder))\n    save(`${viewName}.container.tsx`, TplContainer(viewName, relativeFolder))\n\n    const fileToOpen = Path.resolve(destinationFolder, `${viewName}.tsx`)\n    await Util.openFileInEditor(fileToOpen)\n}\n\n\nfunction writeFile(folder: string, filename: string, content: string) {\n    const path = Path.resolve(folder, filename)\n    try {\n        FS.writeFileSync(path, content)\n    } catch (ex) {\n        console.error(\"Unable to write file: \", path)\n        console.error(ex)\n        X.window.showErrorMessage(`${ex}`)\n    }\n}\n","// tslint:disable-next-line: no-implicit-dependencies\nimport * as X from 'vscode'\nimport * as Path from 'path'\nimport * as  FS from 'fs'\nimport Util from '../util'\n\n\nexport default {\n    promptForName,\n    selectFolder\n}\n\nasync function promptForName(prompt: string): Promise<string | undefined> {\n    return X.window.showInputBox({\n        prompt, validateInput: Util.isKebabCase\n    })\n}\n\nasync function selectFolder(title = \"Select a folder for the font\"): Promise<string | null> {\n    // tslint:disable-next-line: no-null-undefined-union\n    return new Promise<string | null>((resolve, reject) => {\n        const sourceFolder = Util.getSourceFolder()\n        if (!sourceFolder) {\n            reject(\"Unable to find source folder!\")\n            return null\n        }\n\n        let selectedFolder: string | null = null\n        const folders: string[] = []\n        recursiveSearchForFolders(sourceFolder, folders)\n        const items = folders.map(\n            dir => ({\n                label: `./${Path.relative(sourceFolder, dir)}`\n            }))\n        const picker = X.window.createQuickPick<X.QuickPickItem>()\n        picker.items = items\n        picker.title = title\n        picker.onDidAccept(() => {\n            resolve(selectedFolder)\n            picker.dispose()\n        })\n        picker.onDidChangeActive(\n            activeItems => {\n                selectedFolder = Path.resolve(sourceFolder, activeItems[0].label)\n            }\n        )\n        picker.show()\n    })\n}\n\n\nfunction recursiveSearchForFolders(currentFolder: string, folders: string[]) {\n    folders.push(currentFolder)\n    const dirs = FS.readdirSync(currentFolder, { withFileTypes: true })\n    for (const dir of dirs) {\n        if (dir.name === '.' || dir.name === '..') continue\n\n        if (dir.isDirectory()) {\n            recursiveSearchForFolders(\n                Path.resolve(currentFolder, dir.name),\n                folders\n            )\n        }\n    }\n}\n","import Util from '../../util'\n\nexport default function(filename: string, folder: string) {\n    const viewname = Util.kebabCaseToPascalCase(filename)\n    const className = `${\n        folder.split(\"/\").map(Util.kebabCaseToLowerPascalCase).join(\"-\")\n    }-${viewname}`\n\n    return `import * as React from \"react\"\nimport Tfw from 'tfw'\n\nimport './${filename}.css'\n\n// const _ = Tfw.Intl.make(require('./${filename}.json'))\n\nexport interface I${viewname}Props {\n    className?: string\n}\n\n// tslint:disable-next-line: no-empty-interface\ninterface I${viewname}State {}\n\nexport default class ${viewname} extends React.Component<I${viewname}Props, I${viewname}State> {\n    state: I${viewname}State = {}\n\n    render() {\n        const classNames = ['custom', '${className}']\n        if (typeof this.props.className === 'string') {\n            classNames.push(this.props.className)\n        }\n\n        return <div className={classNames.join(\" \")}>\n        </div>\n    }\n}\n`\n}","import Util from '../../util'\n\nexport default function(filename: string, folder: string) {\n    const viewname = Util.kebabCaseToPascalCase(filename)\n    const className = `${\n        folder.split(\"/\").map(Util.kebabCaseToLowerPascalCase).join(\"-\")\n    }-${viewname}`\n\n    return `.${className} {}\\n`\n}\n\n","import Util from '../../util'\n\nexport default function(filename: string, folder: string) {\n    const viewname = Util.kebabCaseToPascalCase(filename)\n\n    return `// To test a React component, you need to install these modules:\n// yarn add --dev react-test-renderer @types/react-test-renderer\n// @see https://jestjs.io/docs/en/snapshot-testing\n//\n// If a test failed just because you intended to improve the component,\n// just call \\`jest --updateSnapshot\\`.\n\nimport React from 'react';\nimport Renderer from 'react-test-renderer'\nimport ${viewname}, { I${viewname}Props } from './${filename}'\n\nfunction view(partialProps: Partial<I${viewname}Props>) {\n    const props: I${viewname}Props = {\n        // @TODO Set default props.\n        ...partialProps\n    }\n    return Renderer.create(<${viewname} {...props} />).toJSON()\n}\n\ndescribe('<${viewname}/> in ${folder}', () => {\n    it('should be consistent with previous snapshot', () => {\n        expect(view({})).toMatchSnapshot()\n    })\n})\n`\n}","import Util from '../../util'\n\nexport default function(filename: string, folder: string) {\n    const viewname = Util.kebabCaseToPascalCase(filename)\n    const back = folder.split(\"/\")\n        .map(x => \"..\")\n        .join(\"/\")\n\n    return `import { connect } from 'react-redux'\nimport ${viewname}, { I${viewname}Props } from './${filename}'\nimport { IAppState, IAction } from '${back}/../types'\n\nfunction mapStateToProps(\n    state: IAppState,\n    props: Partial<I${viewname}Props>\n): I${viewname}Props {\n    return { ...props }\n}\n\nfunction mapDispatchToProps(\n    dispatch: (action: IAction) => void,\n    props: Partial<I${viewname}Props>\n) {\n    // @see https://redux.js.org/basics/usage-with-react/#implementing-container-components\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${viewname})\n`\n}","export { default } from \"./fonts\"","// tslint:disable: no-implicit-dependencies\nimport * as X from 'vscode'\nimport * as FS from 'fs'\nimport * as Path from 'path'\nimport fetch from 'node-fetch'\nimport Util from '../util'\nimport Slicer from './slicer'\nimport Inputs from '../inputs'\n\nexport default {\n    load\n}\n\nasync function load() {\n    try {\n        const fontURL = await X.window.showInputBox({\n            prompt: \"Please enter the URL of the font CSS.\\nYou will find it after the @import directive.\",\n            value: \"https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap\"\n        })\n        if (!fontURL) return\n        const disposableMessage = X.window.setStatusBarMessage(`Fetching ${fontURL}`)\n        const asyncContentLoading = loadContentFromURL(fontURL)\n\n        const fontName = await X.window.showInputBox({\n            prompt: \"Please enter the font family name.\",\n            value: \"noto\",\n            validateInput: Util.isKebabCase\n        })\n        if (!fontName) return\n        const cssContent = await asyncContentLoading\n        disposableMessage.dispose()\n        if (!cssContent) return\n\n        const asyncLoadAll = loadAllFonts(cssContent)\n\n        const destination = await Inputs.selectFolder()\n        X.window.showInformationMessage(destination || \"NULL\")\n        if (!destination) return\n\n        const path = Path.resolve(destination, fontName)\n        if (FS.existsSync(path)) {\n            X.window.showErrorMessage(\n                `This directory already exists:\\n${path}`,\n                { modal: true }\n            )\n            return\n        }\n        await X.workspace.fs.createDirectory(X.Uri.file(path))\n        const files = await asyncLoadAll\n        for (const fontFile of files.fonts) {\n            if (!fontFile.data) continue\n\n            FS.writeFileSync(\n                Path.resolve(path, fontFile.filename),\n                new Uint8Array(fontFile.data)\n            )\n        }\n        const cssFilename = Path.resolve(path, `${fontName}.css`)\n        FS.writeFileSync(cssFilename, files.css)\n        await Util.openFileInEditor(cssFilename, X.ViewColumn.Active)\n\n        const fontClassFilename = Path.resolve(path, \"..\", \"font.ts\")\n        if (FS.existsSync(fontClassFilename)) {\n            FS.writeFileSync(\n                Path.resolve(path, \"index.ts\"),\n                `export { default } from './${fontName}'\\n`\n            )\n            const modFilename = Path.resolve(path, `${fontName}.ts`)\n            FS.writeFileSync(\n                modFilename,\n                `import FontClass from '../font'\nimport './${fontName}.css'\n\n// @TODO Check the font name in the CSS file: \"${fontName}.css\"\nexport default new FontClass(\"${fontName}\")\n`\n            )\n            await Util.openFileInEditor(modFilename, X.ViewColumn.Beside)\n        } else {\n            X.window.showInformationMessage(fontClassFilename)\n        }\n    } catch (ex) {\n        X.window.showErrorMessage(\n            `${ex}`,\n            { modal: true }\n        )\n    }\n}\n\nfunction getCurrentURI(): X.Uri | undefined {\n    const editor = X.window.activeTextEditor\n    if (editor) {\n        const path: string = Path.dirname(editor.document.fileName)\n        return X.Uri.file(path)\n    }\n\n    const folders = X.workspace.workspaceFolders\n    if (!folders) return undefined\n    return folders[0].uri\n}\n\nasync function loadContentFromURL(url: string): Promise<string> {\n    try {\n        const styleResponse = await fetch(url)\n        const styleContent = await styleResponse.text()\n        return styleContent\n    } catch (ex) {\n        throw `Unable to load from URL \\\"${url}\\\"!\\n\\n${ex}`\n    }\n}\n\ninterface IFont {\n    data: ArrayBuffer | null\n    filename: string\n}\n\ninterface IAllFonts {\n    css: string,\n    fonts: IFont[]\n}\n\nasync function loadAllFonts(cssContent: string): Promise<IAllFonts> {\n    const slices = Slicer.slice(cssContent)\n\n    let disposableMessage = X.window.setStatusBarMessage(`Loading font files...`)\n    for (let i = 0; i < slices.urls.length; i++) {\n        const url = slices.urls[i]\n        try {\n            disposableMessage.dispose()\n            disposableMessage = X.window.setStatusBarMessage(`Loading font ${i + 1} / ${slices.urls.length}`)\n            const response = await fetch(url)\n            if (!response.ok) {\n                throw `Error ${response.status}: ${response.statusText}`\n            }\n            const arrayBuffer = await response.arrayBuffer()\n            slices.data.push(arrayBuffer)\n        } catch (ex) {\n            slices.data.push(null)\n            X.window.showErrorMessage(\n                `Unable to load font ${i + 1} / ${slices.urls.length}:\\n${url}\\n\\n${ex}`\n            )\n        }\n    }\n    disposableMessage.dispose()\n\n    return {\n        css: slices.pieces.map((piece, index) => {\n            if (typeof piece === 'number') {\n                return `./${piece}.${getExtension(slices.urls[piece])}`\n            }\n            return piece\n        }).join(\"\"),\n        fonts: slices.data.map((data, index) => ({\n            data,\n            filename: `${index}.${getExtension(slices.urls[index])}`\n        }))\n    }\n}\n\nfunction getExtension(filename: string): string {\n    const NOT_FOUND = -1\n    const dotIndex = filename.lastIndexOf(\".\")\n    if (dotIndex === NOT_FOUND) return \"\"\n    return filename.substr(dotIndex + 1)\n}\n\n","import Stream from 'stream';\nimport http from 'http';\nimport Url from 'url';\nimport https from 'https';\nimport zlib from 'zlib';\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof Stream) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof Stream) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof Stream)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\t\tif (!res) {\n\t\t\tres = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\t\t\tif (res) {\n\t\t\t\tres.pop(); // drop last quote\n\t\t\t}\n\t\t}\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof Stream && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof Stream) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n\nconst streamDestructionSupported = 'destroy' in Stream.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parse_url(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parse_url(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parse_url(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\nconst resolve_url = Url.resolve;\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\trequest.body.destroy(error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\t\t\tfinalize();\n\t\t});\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tconst locationURL = location === null ? null : resolve_url(request.url, location);\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout,\n\t\t\t\t\t\t\tsize: request.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\nexport default fetch;\nexport { Headers, Request, Response, FetchError };\n","export default {\n    removeComments,\n    slice\n}\n\nconst NOT_FOUND = -1\n\ninterface ISlices {\n    urls: string[]\n    data: Array<ArrayBuffer | null>\n    pieces: Array<string | number>\n}\n\nfunction slice(cssContent: string): ISlices {\n    const urls: string[] = []\n    const pieces: Array<string | number> = []\n    const content = removeComments(cssContent)\n    let cursor = 0\n\n    while (true) {\n        const indexOpen = content.indexOf(\"url(\", cursor)\n        if (indexOpen === NOT_FOUND) {\n            pieces.push(content.substr(cursor))\n            break\n        }\n        pieces.push(content.substring(cursor, indexOpen + \"url(\".length))\n        const indexClose = content.indexOf(\")\", indexOpen + \"url(\".length)\n        if (indexClose === NOT_FOUND) break\n\n        pieces.push(urls.length)\n        const url = content.substring(indexOpen + \"url(\".length, indexClose)\n        urls.push(url)\n        cursor = indexClose\n    }\n\n    return { urls, pieces, data: [] }\n}\n\nfunction removeComments(content: string): string {\n    const pieces: string[] = []\n    let cursor = 0\n\n    while (true) {\n        const indexOpen = content.indexOf(\"/*\", cursor)\n        if (indexOpen === NOT_FOUND) {\n            pieces.push(content.substr(cursor))\n            break\n        }\n        pieces.push(content.substring(cursor, indexOpen))\n        const indexClose = content.indexOf(\"*/\", cursor + \"/*\".length)\n        if (indexClose === NOT_FOUND) break\n        cursor = indexClose + \"*/\".length\n    }\n\n    return pieces.join(\"\")\n}","export { default } from \"./module\"","import * as X from 'vscode'\nimport * as FS from \"fs\"\nimport * as Path from \"path\"\nimport Util from '../util'\nimport Inputs from '../inputs'\n\nexport default {\n    exec\n}\n\nasync function exec() {\n    const folder = await Inputs.selectFolder(\"Root folder for your new module\")\n    if (!folder) return\n    const folderName = Path.basename(folder)\n    let moduleName = await X.window.showInputBox({\n        prompt: \"Module's name\",\n        validateInput: Util.isKebabCase\n    })\n    if (!moduleName) return\n    const destinationFolder = Path.resolve(folder, moduleName)\n    if (Util.exists(destinationFolder)) {\n        X.window.showErrorMessage(\n            `This folder already exists!\\n${destinationFolder}`,\n            { modal: true }\n        )\n        return\n    }\n    await X.workspace.fs.createDirectory(X.Uri.file(destinationFolder))\n\n    if (folderName !== 'src') {\n        const moduleSuffix = await X.window.showInputBox({\n            prompt: \"Module's name suffix (press ESC if you don't want any)\",\n            value: folderName,\n            validateInput: Util.isKebabCase\n        })\n        if (moduleSuffix) {\n            moduleName += `-${moduleSuffix.trim()}`\n        }\n    }\n\n    const save = writeFile.bind(null, destinationFolder)\n    save(\"index.ts\", `export { default } from './${moduleName}'\\n`)\n    save(`${moduleName}.ts`, getModuleContent())\n    save(`${moduleName}.test.ts`, getTestContent(moduleName))\n\n    const fileToOpen = Path.resolve(folder, `${moduleName}.ts`)\n    await Util.openFileInEditor(fileToOpen)\n}\n\n\nfunction writeFile(folder: string, filename: string, content: string) {\n    const path = Path.resolve(folder, filename)\n    try {\n        FS.writeFileSync(path, content)\n    } catch (ex) {\n        console.error(\"Unable to write file: \", path)\n        console.error(ex)\n        X.window.showErrorMessage(`${ex}`)\n    }\n}\n\nfunction getModuleContent(): string {\n    return `export default { exec }\n\nfunction exec() {}\n`\n}\n\nfunction getTestContent(moduleName: string): string {\n    const pascalName = Util.kebabCaseToPascalCase(moduleName)\n    return `import ${pascalName} from './${moduleName}'\n\ndescribe(\"Module ${moduleName}\", () => {\n    // @TODO Write tests for module ${moduleName}\n})\n`\n}","export { default } from './template'\n","export default { exec }\n\nfunction exec() {}\n","// tslint:disable-next-line: no-implicit-dependencies\nimport * as VSC from 'vscode'\nimport * as YAML from 'yaml'\nimport { YAMLError, YAMLSemanticError } from 'yaml/util'\nimport Util from './util'\n\nexport default { compileYAML }\n\nconst DEFAULT_INDENTATION = \"    \"\nconst NOT_FOUND = -1\n\ninterface IYamlException {\n    name: string\n    source: string\n    message: string\n    makePretty(): string\n}\n\nfunction isYamlException(ex: any): ex is IYamlException {\n    if (!ex) return false\n    if (typeof ex !== 'object') return false\n    if (typeof (ex as { [key: string]: any }).makePretty !== 'function') return false\n    return true\n}\n\nasync function compileYAML() {\n    const activeEditor = VSC.window.activeTextEditor\n    if (!activeEditor) {\n        VSC.window.showErrorMessage(\"No active text editor!\")\n        return\n    }\n    const filename = activeEditor.document.fileName\n    if (!filename.endsWith(\".yaml\") && !filename.endsWith(\".yml\")) {\n        VSC.window.showErrorMessage(\"This is not a YAML file!\")\n        return\n    }\n\n    const content = activeEditor.document.getText().replace(\"\\t\", \"    \")\n    let value: any = null\n    try {\n        value = YAML.parse(\n            content, {\n            indent: 4,\n            prettyErrors: true\n        }\n        )\n    }\n    catch (ex) {\n        console.error(\"================================================================================\")\n        console.error(ex) // @TODO Remove this line written on 2020-09-18 at 12:05\n        let errorMessage = `Invalid YAML file!\\n${ex}`\n        if (ex instanceof YAMLSemanticError) {\n            errorMessage = `YAML Semantic Error at line ${ex.linePos?.start.line\n                }!\\n${ex.message\n                }\\n`\n        }\n        else if (ex instanceof YAMLError) {\n            errorMessage = `YAML Error!\\n${ex.message}\\n`\n        }\n        if (errorMessage.indexOf(\"cannot start with a tab character\") !== NOT_FOUND) {\n            errorMessage += \"\\nTry to execute the following command from the palette:\\n\"\n            errorMessage += '\"Convert indentation to spaces\"'\n        }\n        VSC.window.showErrorMessage(\n            errorMessage,\n            { modal: true }\n        )\n        return\n    }\n    const destination = Util.changeExtension(filename, \"json\")\n    Util.writeTextFile(\n        destination,\n        JSON.stringify(value, null, DEFAULT_INDENTATION)\n    )\n    await Util.openFileInEditor(destination)\n}\n","module.exports = require('./dist').YAML\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar parseCst = require('./parse-cst.js');\nrequire('./resolveSeq-4a68b39b.js');\nvar Document$1 = require('./Document-2cf6b08c.js');\nvar Schema = require('./Schema-42e9705c.js');\nvar warnings = require('./warnings-39684f17.js');\n\nfunction createNode(value, wrapScalars = true, tag) {\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  const options = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);\n  const schema = new Schema.Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nclass Document extends Document$1.Document {\n  constructor(options) {\n    super(Object.assign({}, Document$1.defaultOptions, options));\n  }\n\n}\n\nfunction parseAllDocuments(src, options) {\n  const stream = [];\n  let prev;\n\n  for (const cstDoc of parseCst.parse(src)) {\n    const doc = new Document(options);\n    doc.parse(cstDoc, prev);\n    stream.push(doc);\n    prev = doc;\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  const cst = parseCst.parse(src);\n  const doc = new Document(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    const errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  const doc = parseDocument(src, options);\n  doc.warnings.forEach(warning => warnings.warn(warning));\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify(value, options) {\n  const doc = new Document(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nconst YAML = {\n  createNode,\n  defaultOptions: Document$1.defaultOptions,\n  Document,\n  parse,\n  parseAllDocuments,\n  parseCST: parseCst.parse,\n  parseDocument,\n  scalarOptions: Document$1.scalarOptions,\n  stringify\n};\n\nexports.YAML = YAML;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nclass BlankLine extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  get includesTrailingLines() {\n    // This is never called from anywhere, but if it were,\n    // this is the value it should return.\n    return true;\n  }\n  /**\n   * Parses a blank line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first \\n character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    this.range = new PlainValue.Range(start, start + 1);\n    return start + 1;\n  }\n\n}\n\nclass CollectionItem extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.node = null;\n  }\n\n  get includesTrailingLines() {\n    return !!this.node && this.node.includesTrailingLines;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      atLineStart,\n      lineStart\n    } = context;\n    if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM) this.error = new PlainValue.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n    const indent = atLineStart ? start - lineStart : context.indent;\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    let ch = src[offset];\n    const inlineComment = ch === '#';\n    const comments = [];\n    let blankLine = null;\n\n    while (ch === '\\n' || ch === '#') {\n      if (ch === '#') {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        comments.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        atLineStart = true;\n        lineStart = offset + 1;\n        const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n        if (src[wsEnd] === '\\n' && comments.length === 0) {\n          blankLine = new BlankLine();\n          lineStart = blankLine.parse({\n            src\n          }, lineStart);\n        }\n\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n      }\n\n      ch = src[offset];\n    }\n\n    if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {\n      this.node = parseNode({\n        atLineStart,\n        inCollection: false,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n    } else if (ch && lineStart > start + 1) {\n      offset = lineStart - 1;\n    }\n\n    if (this.node) {\n      if (blankLine) {\n        // Only blank lines preceding non-empty nodes are captured. Note that\n        // this means that collection item range start indices do not always\n        // increase monotonically. -- eemeli/yaml#126\n        const items = context.parent.items || context.parent.contents;\n        if (items) items.push(blankLine);\n      }\n\n      if (comments.length) Array.prototype.push.apply(this.props, comments);\n      offset = this.node.range.end;\n    } else {\n      if (inlineComment) {\n        const c = comments[0];\n        this.props.push(c);\n        offset = c.end;\n      } else {\n        offset = PlainValue.Node.endOfLine(src, start + 1);\n      }\n    }\n\n    const end = this.node ? this.node.valueRange.end : offset;\n    this.valueRange = new PlainValue.Range(start, end);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      node,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Comment extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const offset = this.parseComment(start);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nfunction grabCollectionEndComments(node) {\n  let cnode = node;\n\n  while (cnode instanceof CollectionItem) cnode = cnode.node;\n\n  if (!(cnode instanceof Collection)) return null;\n  const len = cnode.items.length;\n  let ci = -1;\n\n  for (let i = len - 1; i >= 0; --i) {\n    const n = cnode.items[i];\n\n    if (n.type === PlainValue.Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      const {\n        indent,\n        lineStart\n      } = n.context;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === PlainValue.Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  const ca = cnode.items.splice(ci, len - ci);\n  const prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\nclass Collection extends PlainValue.Node {\n  static nextContentHasIndent(src, offset, indent) {\n    const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;\n    offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n    const ch = src[offset];\n    if (!ch) return false;\n    if (offset >= lineStart + indent) return true;\n    if (ch !== '#' && ch !== '\\n') return false;\n    return Collection.nextContentHasIndent(src, offset, indent);\n  }\n\n  constructor(firstItem) {\n    super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);\n\n    for (let i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        const itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    this.items = [firstItem];\n    const ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(this.items, ec);\n  }\n\n  get includesTrailingLines() {\n    return this.items.length > 0;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context; // It's easier to recalculate lineStart here rather than tracking down the\n    // last context from which to read it -- eemeli/yaml#2\n\n    let lineStart = PlainValue.Node.startOfLine(src, start);\n    const firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n    // -- eemeli/yaml#17\n\n    firstItem.context.parent = this;\n    this.valueRange = PlainValue.Range.copy(firstItem.valueRange);\n    const indent = firstItem.range.start - firstItem.context.lineStart;\n    let offset = start;\n    offset = PlainValue.Node.normalizeOffset(src, offset);\n    let ch = src[offset];\n    let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;\n    let prevIncludesTrailingLines = false;\n\n    while (ch) {\n      while (ch === '\\n' || ch === '#') {\n        if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n          const blankLine = new BlankLine();\n          offset = blankLine.parse({\n            src\n          }, offset);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n\n          this.items.push(blankLine);\n          offset -= 1; // blankLine.parse() consumes terminal newline\n        } else if (ch === '#') {\n          if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n            return offset;\n          }\n\n          const comment = new Comment();\n          offset = comment.parse({\n            indent,\n            lineStart,\n            src\n          }, offset);\n          this.items.push(comment);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n        }\n\n        lineStart = offset + 1;\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n        if (PlainValue.Node.atBlank(src, offset)) {\n          const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);\n          const next = src[wsEnd];\n\n          if (!next || next === '\\n' || next === '#') {\n            offset = wsEnd;\n          }\n        }\n\n        ch = src[offset];\n        atLineStart = true;\n      }\n\n      if (!ch) {\n        break;\n      }\n\n      if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n        if (offset < lineStart + indent) {\n          if (lineStart > start) offset = lineStart;\n          break;\n        } else if (!this.error) {\n          const msg = 'All collection items must start at the same column';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      if (firstItem.type === PlainValue.Type.SEQ_ITEM) {\n        if (ch !== '-') {\n          if (lineStart > start) offset = lineStart;\n          break;\n        }\n      } else if (ch === '-' && !this.error) {\n        // map key may start with -, as long as it's followed by a non-whitespace char\n        const next = src[offset + 1];\n\n        if (!next || next === '\\n' || next === '\\t' || next === ' ') {\n          const msg = 'A collection cannot be both a mapping and a sequence';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      const node = parseNode({\n        atLineStart,\n        inCollection: true,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n      if (!node) return offset; // at next document start\n\n      this.items.push(node);\n      this.valueRange.end = node.valueRange.end;\n      offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n      ch = src[offset];\n      atLineStart = false;\n      prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n      // has advanced to check the current line's indentation level\n      // -- eemeli/yaml#10 & eemeli/yaml#38\n\n      if (ch) {\n        let ls = offset - 1;\n        let prev = src[ls];\n\n        while (prev === ' ' || prev === '\\t') prev = src[--ls];\n\n        if (prev === '\\n') {\n          lineStart = ls + 1;\n          atLineStart = true;\n        }\n      }\n\n      const ec = grabCollectionEndComments(node);\n      if (ec) Array.prototype.push.apply(this.items, ec);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n    for (let i = 1; i < items.length; ++i) {\n      const item = items[i];\n      const {\n        atLineStart,\n        indent\n      } = item.context;\n      if (atLineStart) for (let i = 0; i < indent; ++i) str += ' ';\n      str += String(item);\n    }\n\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Directive extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.DIRECTIVE);\n    this.name = null;\n  }\n\n  get parameters() {\n    const raw = this.rawValue;\n    return raw ? raw.trim().split(/[ \\t]+/) : [];\n  }\n\n  parseName(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') ch = src[offset += 1];\n\n    this.name = src.slice(start, offset);\n    return offset;\n  }\n\n  parseParameters(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '#') ch = src[offset += 1];\n\n    this.valueRange = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n  parse(context, start) {\n    this.context = context;\n    let offset = this.parseName(start + 1);\n    offset = this.parseParameters(offset);\n    offset = this.parseComment(offset);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nclass Document extends PlainValue.Node {\n  static startCommentOrEndBlankLine(src, start) {\n    const offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    const ch = src[offset];\n    return ch === '#' || ch === '\\n' ? offset : start;\n  }\n\n  constructor() {\n    super(PlainValue.Type.DOCUMENT);\n    this.directives = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.documentEndMarker = null;\n  }\n\n  parseDirectives(start) {\n    const {\n      src\n    } = this.context;\n    this.directives = [];\n    let atLineStart = true;\n    let hasDirectives = false;\n    let offset = start;\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.directives.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.directives.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        case '%':\n          {\n            const directive = new Directive();\n            offset = directive.parse({\n              parent: this,\n              src\n            }, offset);\n            this.directives.push(directive);\n            hasDirectives = true;\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          if (hasDirectives) {\n            this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n          } else if (this.directives.length > 0) {\n            this.contents = this.directives;\n            this.directives = [];\n          }\n\n          return offset;\n      }\n    }\n\n    if (src[offset]) {\n      this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);\n      return offset + 3;\n    }\n\n    if (hasDirectives) {\n      this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n    } else if (this.directives.length > 0) {\n      this.contents = this.directives;\n      this.directives = [];\n    }\n\n    return offset;\n  }\n\n  parseContents(start) {\n    const {\n      parseNode,\n      src\n    } = this.context;\n    if (!this.contents) this.contents = [];\n    let lineStart = start;\n\n    while (src[lineStart - 1] === '-') lineStart -= 1;\n\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    let atLineStart = lineStart === start;\n    this.valueRange = new PlainValue.Range(offset);\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.contents.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          lineStart = offset;\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.contents.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          {\n            const iEnd = PlainValue.Node.endOfIndent(src, offset);\n            const context = {\n              atLineStart,\n              indent: -1,\n              inFlow: false,\n              inCollection: false,\n              lineStart,\n              parent: this\n            };\n            const node = parseNode(context, iEnd);\n            if (!node) return this.valueRange.end = iEnd; // at next document start\n\n            this.contents.push(node);\n            offset = node.range.end;\n            atLineStart = false;\n            const ec = grabCollectionEndComments(node);\n            if (ec) Array.prototype.push.apply(this.contents, ec);\n          }\n      }\n\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n    }\n\n    this.valueRange.end = offset;\n\n    if (src[offset]) {\n      this.documentEndMarker = new PlainValue.Range(offset, offset + 3);\n      offset += 3;\n\n      if (src[offset]) {\n        offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n\n        if (src[offset] === '#') {\n          const comment = new Comment();\n          offset = comment.parse({\n            src\n          }, offset);\n          this.contents.push(comment);\n        }\n\n        switch (src[offset]) {\n          case '\\n':\n            offset += 1;\n            break;\n\n          case undefined:\n            break;\n\n          default:\n            this.error = new PlainValue.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n        }\n      }\n    }\n\n    return offset;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    context.root = this;\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n    offset = this.parseDirectives(offset);\n    offset = this.parseContents(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.directives.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n    this.contents.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n    return offset;\n  }\n\n  toString() {\n    const {\n      contents,\n      directives,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = directives.join('');\n\n    if (contents.length > 0) {\n      if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT) str += '---\\n';\n      str += contents.join('');\n    }\n\n    if (str[str.length - 1] !== '\\n') str += '\\n';\n    return str;\n  }\n\n}\n\nclass Alias extends PlainValue.Node {\n  /**\n   * Parses an *alias from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = PlainValue.Node.endOfIdentifier(src, start + 1);\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nconst Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\nclass BlockValue extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.blockIndent = null;\n    this.chomping = Chomp.CLIP;\n    this.header = null;\n  }\n\n  get includesTrailingLines() {\n    return this.chomping === Chomp.KEEP;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (this.valueRange.isEmpty()) return '';\n    let lastNewLine = null;\n    let ch = src[end - 1];\n\n    while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n      end -= 1;\n\n      if (end <= start) {\n        if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n      }\n\n      if (ch === '\\n') lastNewLine = end;\n      ch = src[end - 1];\n    }\n\n    let keepStart = end + 1;\n\n    if (lastNewLine) {\n      if (this.chomping === Chomp.KEEP) {\n        keepStart = lastNewLine;\n        end = this.valueRange.end;\n      } else {\n        end = lastNewLine;\n      }\n    }\n\n    const bi = indent + this.blockIndent;\n    const folded = this.type === PlainValue.Type.BLOCK_FOLDED;\n    let atStart = true;\n    let str = '';\n    let sep = '';\n    let prevMoreIndented = false;\n\n    for (let i = start; i < end; ++i) {\n      for (let j = 0; j < bi; ++j) {\n        if (src[i] !== ' ') break;\n        i += 1;\n      }\n\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (sep === '\\n') str += '\\n';else sep = '\\n';\n      } else {\n        const lineEnd = PlainValue.Node.endOfLine(src, i);\n        const line = src.slice(i, lineEnd);\n        i = lineEnd;\n\n        if (folded && (ch === ' ' || ch === '\\t') && i < keepStart) {\n          if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n          str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n          sep = lineEnd < end && src[lineEnd] || '';\n          prevMoreIndented = true;\n        } else {\n          str += sep + line;\n          sep = folded && i < keepStart ? ' ' : '\\n';\n          prevMoreIndented = false;\n        }\n\n        if (atStart && line !== '') atStart = false;\n      }\n    }\n\n    return this.chomping === Chomp.STRIP ? str : str + '\\n';\n  }\n\n  parseBlockHeader(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start + 1;\n    let bi = '';\n\n    while (true) {\n      const ch = src[offset];\n\n      switch (ch) {\n        case '-':\n          this.chomping = Chomp.STRIP;\n          break;\n\n        case '+':\n          this.chomping = Chomp.KEEP;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          bi += ch;\n          break;\n\n        default:\n          this.blockIndent = Number(bi) || null;\n          this.header = new PlainValue.Range(start, offset);\n          return offset;\n      }\n\n      offset += 1;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      src\n    } = this.context;\n    const explicit = !!this.blockIndent;\n    let offset = start;\n    let valueEnd = start;\n    let minBlockIndent = 1;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      offset += 1;\n      if (PlainValue.Node.atDocumentBoundary(src, offset)) break;\n      const end = PlainValue.Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n      if (end === null) break;\n      const ch = src[end];\n      const lineIndent = end - (offset + indent);\n\n      if (!this.blockIndent) {\n        // no explicit block indent, none yet detected\n        if (src[end] !== '\\n') {\n          // first line with non-whitespace content\n          if (lineIndent < minBlockIndent) {\n            const msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n            this.error = new PlainValue.YAMLSemanticError(this, msg);\n          }\n\n          this.blockIndent = lineIndent;\n        } else if (lineIndent > minBlockIndent) {\n          // empty line with more whitespace\n          minBlockIndent = lineIndent;\n        }\n      } else if (ch && ch !== '\\n' && lineIndent < this.blockIndent) {\n        if (src[end] === '#') break;\n\n        if (!this.error) {\n          const src = explicit ? 'explicit indentation indicator' : 'first line';\n          const msg = `Block scalars must not be less indented than their ${src}`;\n          this.error = new PlainValue.YAMLSemanticError(this, msg);\n        }\n      }\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        offset = valueEnd = PlainValue.Node.endOfLine(src, end);\n      }\n    }\n\n    if (this.chomping !== Chomp.KEEP) {\n      offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n    }\n\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    return offset;\n  }\n  /**\n   * Parses a block value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * BS\n   * block\n   * lines\n   *\n   * BS #comment\n   * block\n   * lines\n   * ```\n   * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n   * are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this block\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = this.parseBlockHeader(start);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    offset = this.parseBlockValue(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.header ? this.header.setOrigRange(cr, offset) : offset;\n  }\n\n}\n\nclass FlowCollection extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.items = null;\n  }\n\n  prevNodeIsJsonLike(idx = this.items.length) {\n    const node = this.items[idx - 1];\n    return !!node && (node.jsonLike || node.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      indent,\n      lineStart\n    } = context;\n    let char = src[start]; // { or [\n\n    this.items = [{\n      char,\n      offset: start\n    }];\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    char = src[offset];\n\n    while (char && char !== ']' && char !== '}') {\n      switch (char) {\n        case '\\n':\n          {\n            lineStart = offset + 1;\n            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n            if (src[wsEnd] === '\\n') {\n              const blankLine = new BlankLine();\n              lineStart = blankLine.parse({\n                src\n              }, lineStart);\n              this.items.push(blankLine);\n            }\n\n            offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n            if (offset <= lineStart + indent) {\n              char = src[offset];\n\n              if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                const msg = 'Insufficient indentation in flow collection';\n                this.error = new PlainValue.YAMLSemanticError(this, msg);\n              }\n            }\n          }\n          break;\n\n        case ',':\n          {\n            this.items.push({\n              char,\n              offset\n            });\n            offset += 1;\n          }\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.items.push(comment);\n          }\n          break;\n\n        case '?':\n        case ':':\n          {\n            const next = src[offset + 1];\n\n            if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n            char === ':' && this.prevNodeIsJsonLike()) {\n              this.items.push({\n                char,\n                offset\n              });\n              offset += 1;\n              break;\n            }\n          }\n        // fallthrough\n\n        default:\n          {\n            const node = parseNode({\n              atLineStart: false,\n              inCollection: false,\n              inFlow: true,\n              indent: -1,\n              lineStart,\n              parent: this\n            }, offset);\n\n            if (!node) {\n              // at next document start\n              this.valueRange = new PlainValue.Range(start, offset);\n              return offset;\n            }\n\n            this.items.push(node);\n            offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n          }\n      }\n\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n      char = src[offset];\n    }\n\n    this.valueRange = new PlainValue.Range(start, offset + 1);\n\n    if (char) {\n      this.items.push({\n        char,\n        offset\n      });\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);\n      offset = this.parseComment(offset);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      if (node instanceof PlainValue.Node) {\n        offset = node.setOrigRanges(cr, offset);\n      } else if (cr.length === 0) {\n        node.origOffset = node.offset;\n      } else {\n        let i = offset;\n\n        while (i < cr.length) {\n          if (cr[i] > node.offset) break;else ++i;\n        }\n\n        node.origOffset = node.offset + i;\n        offset = i;\n      }\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const nodes = items.filter(item => item instanceof PlainValue.Node);\n    let str = '';\n    let prevEnd = range.start;\n    nodes.forEach(node => {\n      const prefix = src.slice(prevEnd, node.range.start);\n      prevEnd = node.range.end;\n      str += prefix + String(node);\n\n      if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n        // Comment range does not include the terminal newline, but its\n        // stringified value does. Without this fix, newlines at comment ends\n        // get duplicated.\n        prevEnd += 1;\n      }\n    });\n    str += src.slice(prevEnd, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass QuoteDouble extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\"') {\n      offset += ch === '\\\\' ? 2 : 1;\n      ch = src[offset];\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== '\"') errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n    // escaped backslashes; also, this should be faster.\n\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n      } else if (ch === '\\\\') {\n        i += 1;\n\n        switch (src[i]) {\n          case '0':\n            str += '\\0';\n            break;\n          // null character\n\n          case 'a':\n            str += '\\x07';\n            break;\n          // bell character\n\n          case 'b':\n            str += '\\b';\n            break;\n          // backspace\n\n          case 'e':\n            str += '\\x1b';\n            break;\n          // escape character\n\n          case 'f':\n            str += '\\f';\n            break;\n          // form feed\n\n          case 'n':\n            str += '\\n';\n            break;\n          // line feed\n\n          case 'r':\n            str += '\\r';\n            break;\n          // carriage return\n\n          case 't':\n            str += '\\t';\n            break;\n          // horizontal tab\n\n          case 'v':\n            str += '\\v';\n            break;\n          // vertical tab\n\n          case 'N':\n            str += '\\u0085';\n            break;\n          // Unicode next line\n\n          case '_':\n            str += '\\u00a0';\n            break;\n          // Unicode non-breaking space\n\n          case 'L':\n            str += '\\u2028';\n            break;\n          // Unicode line separator\n\n          case 'P':\n            str += '\\u2029';\n            break;\n          // Unicode paragraph separator\n\n          case ' ':\n            str += ' ';\n            break;\n\n          case '\"':\n            str += '\"';\n            break;\n\n          case '/':\n            str += '/';\n            break;\n\n          case '\\\\':\n            str += '\\\\';\n            break;\n\n          case '\\t':\n            str += '\\t';\n            break;\n\n          case 'x':\n            str += this.parseCharCode(i + 1, 2, errors);\n            i += 2;\n            break;\n\n          case 'u':\n            str += this.parseCharCode(i + 1, 4, errors);\n            i += 4;\n            break;\n\n          case 'U':\n            str += this.parseCharCode(i + 1, 8, errors);\n            i += 8;\n            break;\n\n          case '\\n':\n            // skip escaped newlines, but still trim the following line\n            while (src[i + 1] === ' ' || src[i + 1] === '\\t') i += 1;\n\n            break;\n\n          default:\n            errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));\n            str += '\\\\' + src[i];\n        }\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n\n  parseCharCode(offset, length, errors) {\n    const {\n      src\n    } = this.context;\n    const cc = src.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n\n    if (isNaN(code)) {\n      errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));\n      return src.substr(offset - 2, length + 2);\n    }\n\n    return String.fromCodePoint(code);\n  }\n  /**\n   * Parses a \"double quoted\" value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteDouble.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nclass QuoteSingle extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch) {\n      if (ch === \"'\") {\n        if (src[offset + 1] !== \"'\") break;\n        ch = src[offset += 2];\n      } else {\n        ch = src[offset += 1];\n      }\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, \"Missing closing 'quote\"));\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n      } else if (ch === \"'\") {\n        str += ch;\n        i += 1;\n        if (src[i] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n  /**\n   * Parses a 'single quoted' value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteSingle.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case PlainValue.Type.ALIAS:\n      return new Alias(type, props);\n\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case PlainValue.Type.MAP_KEY:\n    case PlainValue.Type.MAP_VALUE:\n    case PlainValue.Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case PlainValue.Type.COMMENT:\n    case PlainValue.Type.PLAIN:\n      return new PlainValue.PlainValue(type, props);\n\n    case PlainValue.Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case PlainValue.Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nclass ParseContext {\n  static parseType(src, offset, inFlow) {\n    switch (src[offset]) {\n      case '*':\n        return PlainValue.Type.ALIAS;\n\n      case '>':\n        return PlainValue.Type.BLOCK_FOLDED;\n\n      case '|':\n        return PlainValue.Type.BLOCK_LITERAL;\n\n      case '{':\n        return PlainValue.Type.FLOW_MAP;\n\n      case '[':\n        return PlainValue.Type.FLOW_SEQ;\n\n      case '?':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;\n\n      case ':':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;\n\n      case '-':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;\n\n      case '\"':\n        return PlainValue.Type.QUOTE_DOUBLE;\n\n      case \"'\":\n        return PlainValue.Type.QUOTE_SINGLE;\n\n      default:\n        return PlainValue.Type.PLAIN;\n    }\n  }\n\n  constructor(orig = {}, {\n    atLineStart,\n    inCollection,\n    inFlow,\n    indent,\n    lineStart,\n    parent\n  } = {}) {\n    PlainValue._defineProperty(this, \"parseNode\", (overlay, start) => {\n      if (PlainValue.Node.atDocumentBoundary(this.src, start)) return null;\n      const context = new ParseContext(this, overlay);\n      const {\n        props,\n        type,\n        valueStart\n      } = context.parseProps(start);\n      const node = createNewNode(type, props);\n      let offset = node.parse(context, valueStart);\n      node.range = new PlainValue.Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(`Node#parse consumed no characters`);\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {\n          node.error = new PlainValue.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        const collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new PlainValue.Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  nodeStartsCollection(node) {\n    const {\n      inCollection,\n      inFlow,\n      src\n    } = this;\n    if (inCollection || inFlow) return false;\n    if (node instanceof CollectionItem) return true; // check for implicit key\n\n    let offset = node.range.end;\n    if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    return src[offset] === ':';\n  } // Anchor and tag are before type, which determines the node implementation\n  // class; hence this intermediate step.\n\n\n  parseProps(offset) {\n    const {\n      inFlow,\n      parent,\n      src\n    } = this;\n    const props = [];\n    let lineHasProps = false;\n    offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);\n    let ch = src[offset];\n\n    while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === '\\n') {\n      if (ch === '\\n') {\n        const lineStart = offset + 1;\n        const inEnd = PlainValue.Node.endOfIndent(src, lineStart);\n        const indentDiff = inEnd - (lineStart + this.indent);\n        const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;\n        if (!PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n        this.atLineStart = true;\n        this.lineStart = lineStart;\n        lineHasProps = false;\n        offset = inEnd;\n      } else if (ch === PlainValue.Char.COMMENT) {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        props.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        let end = PlainValue.Node.endOfIdentifier(src, offset + 1);\n\n        if (ch === PlainValue.Char.TAG && src[end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, end + 13))) {\n          // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n          // than an empty but 'foo.bar' private-tagged node in a flow collection\n          // followed without whitespace by a plain string starting with a year\n          // or date divided by something.\n          end = PlainValue.Node.endOfIdentifier(src, end + 5);\n        }\n\n        props.push(new PlainValue.Range(offset, end));\n        lineHasProps = true;\n        offset = PlainValue.Node.endOfWhiteSpace(src, end);\n      }\n\n      ch = src[offset];\n    } // '- &a : b' has an anchor on an empty node\n\n\n    if (lineHasProps && ch === ':' && PlainValue.Node.atBlank(src, offset + 1, true)) offset -= 1;\n    const type = ParseContext.parseType(src, offset, inFlow);\n    return {\n      props,\n      type,\n      valueStart: offset\n    };\n  }\n  /**\n   * Parses a node from the source\n   * @param {ParseContext} overlay\n   * @param {number} start - Index of first non-whitespace character for the node\n   * @returns {?Node} - null if at a document boundary\n   */\n\n\n}\n\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n  const cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, (match, offset) => {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  const documents = [];\n  let offset = 0;\n\n  do {\n    const doc = new Document();\n    const context = new ParseContext({\n      src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = () => {\n    if (cr.length === 0) return false;\n\n    for (let i = 1; i < cr.length; ++i) cr[i] -= i;\n\n    let crOffset = 0;\n\n    for (let i = 0; i < documents.length; ++i) {\n      crOffset = documents[i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = () => documents.join('...\\n');\n\n  return documents;\n}\n\nexports.parse = parse;\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\nvar Schema = require('./Schema-42e9705c.js');\n\nconst defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nconst scalarOptions = {\n  get binary() {\n    return resolveSeq.binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(resolveSeq.binaryOptions, opt);\n  },\n\n  get bool() {\n    return resolveSeq.boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(resolveSeq.boolOptions, opt);\n  },\n\n  get int() {\n    return resolveSeq.intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(resolveSeq.intOptions, opt);\n  },\n\n  get null() {\n    return resolveSeq.nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(resolveSeq.nullOptions, opt);\n  },\n\n  get str() {\n    return resolveSeq.strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(resolveSeq.strOptions, opt);\n  }\n\n};\nconst documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: PlainValue.defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  '1.1': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  },\n  '1.2': {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    const priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`;\n  }\n\n  let p = doc.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);\n\n  if (!p) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);\n  }\n\n  if (!p) return tag[0] === '!' ? tag : `!<${tag}>`;\n  const suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, ch => ({\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n  })[ch]);\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;\n\n  if (item.tag) {\n    const match = tags.filter(t => t.tag === item.tag);\n    if (match.length > 0) return match.find(t => t.format === item.format) || match[0];\n  }\n\n  let tagObj, obj;\n\n  if (item instanceof resolveSeq.Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    const match = tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);\n    tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);\n  } else {\n    obj = item;\n    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n  }\n\n  if (!tagObj) {\n    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;\n    throw new Error(`Tag not resolved for ${name} value`);\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, {\n  anchors,\n  doc\n}) {\n  const props = [];\n  const anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(`&${anchor}`);\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify(item, ctx, onComment, onChompKeep) {\n  const {\n    anchors,\n    schema\n  } = ctx.doc;\n  let tagObj;\n\n  if (!(item instanceof resolveSeq.Node)) {\n    const createCtx = {\n      aliasNodes: [],\n      onTagObj: o => tagObj = o,\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    for (const alias of createCtx.aliasNodes) {\n      alias.source = alias.source.node;\n      let name = anchors.getName(alias.source);\n\n      if (!name) {\n        name = anchors.newName();\n        anchors.map[name] = alias.source;\n      }\n    }\n  }\n\n  if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  const props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof resolveSeq.Scalar || str[0] === '{' || str[0] === '[' ? `${props} ${str}` : `${props}\\n${ctx.indent}${str}`;\n}\n\nclass Anchors {\n  static validAnchorNode(node) {\n    return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;\n  }\n\n  constructor(prefix) {\n    PlainValue._defineProperty(this, \"map\", {});\n\n    this.prefix = prefix;\n  }\n\n  createAlias(node, name) {\n    this.setAnchor(node, name);\n    return new resolveSeq.Alias(node);\n  }\n\n  createMergePair(...sources) {\n    const merge = new resolveSeq.Merge();\n    merge.value.items = sources.map(s => {\n      if (s instanceof resolveSeq.Alias) {\n        if (s.source instanceof resolveSeq.YAMLMap) return s;\n      } else if (s instanceof resolveSeq.YAMLMap) {\n        return this.createAlias(s);\n      }\n\n      throw new Error('Merge sources must be Map nodes or their Aliases');\n    });\n    return merge;\n  }\n\n  getName(node) {\n    const {\n      map\n    } = this;\n    return Object.keys(map).find(a => map[a] === node);\n  }\n\n  getNames() {\n    return Object.keys(this.map);\n  }\n\n  getNode(name) {\n    return this.map[name];\n  }\n\n  newName(prefix) {\n    if (!prefix) prefix = this.prefix;\n    const names = Object.keys(this.map);\n\n    for (let i = 1; true; ++i) {\n      const name = `${prefix}${i}`;\n      if (!names.includes(name)) return name;\n    }\n  } // During parsing, map & aliases contain CST nodes\n\n\n  resolveNodes() {\n    const {\n      map,\n      _cstAliases\n    } = this;\n    Object.keys(map).forEach(a => {\n      map[a] = map[a].resolved;\n    });\n\n    _cstAliases.forEach(a => {\n      a.source = a.source.resolved;\n    });\n\n    delete this._cstAliases;\n  }\n\n  setAnchor(node, name) {\n    if (node != null && !Anchors.validAnchorNode(node)) {\n      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n    }\n\n    if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n      throw new Error('Anchor names must not contain whitespace or control characters');\n    }\n\n    const {\n      map\n    } = this;\n    const prev = node && Object.keys(map).find(a => map[a] === node);\n\n    if (prev) {\n      if (!name) {\n        return prev;\n      } else if (prev !== name) {\n        delete map[prev];\n        map[name] = node;\n      }\n    } else {\n      if (!name) {\n        if (!node) return null;\n        name = this.newName();\n      }\n\n      map[name] = node;\n    }\n\n    return name;\n  }\n\n}\n\nconst visit = (node, tags) => {\n  if (node && typeof node === 'object') {\n    const {\n      tag\n    } = node;\n\n    if (node instanceof resolveSeq.Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(n => visit(n, tags));\n    } else if (node instanceof resolveSeq.Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof resolveSeq.Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nconst listTagNames = node => Object.keys(visit(node, {}));\n\nfunction parseContents(doc, contents) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let body = undefined;\n  let spaceBefore = false;\n\n  for (const node of contents) {\n    if (node.valueRange) {\n      if (body !== undefined) {\n        const msg = 'Document contains trailing content not separated by a ... or --- line';\n        doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n        break;\n      }\n\n      const res = resolveSeq.resolveNode(doc, node);\n\n      if (spaceBefore) {\n        res.spaceBefore = true;\n        spaceBefore = false;\n      }\n\n      body = res;\n    } else if (node.comment !== null) {\n      const cc = body === undefined ? comments.before : comments.after;\n      cc.push(node.comment);\n    } else if (node.type === PlainValue.Type.BLANK_LINE) {\n      spaceBefore = true;\n\n      if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n        // space-separated comments at start are parsed as document comments\n        doc.commentBefore = comments.before.join('\\n');\n        comments.before = [];\n      }\n    }\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? `${cb}\\n${cbNode.commentBefore}` : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective({\n  tagPrefixes\n}, directive) {\n  const [handle, prefix] = directive.parameters;\n\n  if (!handle || !prefix) {\n    const msg = 'Insufficient parameters given for %TAG directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(p => p.handle === handle)) {\n    const msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  return {\n    handle,\n    prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  let [version] = directive.parameters;\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    const msg = 'Insufficient parameters given for %YAML directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    const v0 = doc.version || doc.options.version;\n    const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  const directiveComments = [];\n  let hasDirectives = false;\n\n  for (const directive of directives) {\n    const {\n      comment,\n      name\n    } = directive;\n\n    switch (name) {\n      case 'TAG':\n        try {\n          doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      case 'YAML':\n      case 'YAML:1.0':\n        if (doc.version) {\n          const msg = 'The %YAML directive must only be given at most once per document.';\n          doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));\n        }\n\n        try {\n          doc.version = resolveYamlDirective(doc, directive);\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      default:\n        if (name) {\n          const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;\n          doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n        }\n\n    }\n\n    if (comment) directiveComments.push(comment);\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    const copyTagPrefix = ({\n      handle,\n      prefix\n    }) => ({\n      handle,\n      prefix\n    });\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof resolveSeq.Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nclass Document {\n  constructor(options) {\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  add(value) {\n    assertCollection(this.contents);\n    return this.contents.add(value);\n  }\n\n  addIn(path, value) {\n    assertCollection(this.contents);\n    this.contents.addIn(path, value);\n  }\n\n  delete(key) {\n    assertCollection(this.contents);\n    return this.contents.delete(key);\n  }\n\n  deleteIn(path) {\n    if (resolveSeq.isEmptyPath(path)) {\n      if (this.contents == null) return false;\n      this.contents = null;\n      return true;\n    }\n\n    assertCollection(this.contents);\n    return this.contents.deleteIn(path);\n  }\n\n  getDefaults() {\n    return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n  }\n\n  get(key, keepScalar) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : undefined;\n  }\n\n  getIn(path, keepScalar) {\n    if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : undefined;\n  }\n\n  has(key) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;\n  }\n\n  hasIn(path) {\n    if (resolveSeq.isEmptyPath(path)) return this.contents !== undefined;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;\n  }\n\n  set(key, value) {\n    assertCollection(this.contents);\n    this.contents.set(key, value);\n  }\n\n  setIn(path, value) {\n    if (resolveSeq.isEmptyPath(path)) this.contents = value;else {\n      assertCollection(this.contents);\n      this.contents.setIn(path, value);\n    }\n  }\n\n  setSchema(id, customTags) {\n    if (!id && !customTags && this.schema) return;\n    if (typeof id === 'number') id = id.toFixed(1);\n\n    if (id === '1.0' || id === '1.1' || id === '1.2') {\n      if (this.version) this.version = id;else this.options.version = id;\n      delete this.options.schema;\n    } else if (id && typeof id === 'string') {\n      this.options.schema = id;\n    }\n\n    if (Array.isArray(customTags)) this.options.customTags = customTags;\n    const opt = Object.assign({}, this.getDefaults(), this.options);\n    this.schema = new Schema.Schema(opt);\n  }\n\n  parse(node, prevDoc) {\n    if (this.options.keepCstNodes) this.cstNode = node;\n    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n    const {\n      directives = [],\n      contents = [],\n      directivesEndMarker,\n      error,\n      valueRange\n    } = node;\n\n    if (error) {\n      if (!error.source) error.source = this;\n      this.errors.push(error);\n    }\n\n    parseDirectives(this, directives, prevDoc);\n    if (directivesEndMarker) this.directivesEndMarker = true;\n    this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n    this.setSchema();\n    this.anchors._cstAliases = [];\n    parseContents(this, contents);\n    this.anchors.resolveNodes();\n\n    if (this.options.prettyErrors) {\n      for (const error of this.errors) if (error instanceof PlainValue.YAMLError) error.makePretty();\n\n      for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();\n    }\n\n    return this;\n  }\n\n  listNonDefaultTags() {\n    return listTagNames(this.contents).filter(t => t.indexOf(Schema.Schema.defaultPrefix) !== 0);\n  }\n\n  setTagPrefix(handle, prefix) {\n    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n    if (prefix) {\n      const prev = this.tagPrefixes.find(p => p.handle === handle);\n      if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n        handle,\n        prefix\n      });\n    } else {\n      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);\n    }\n  }\n\n  toJSON(arg, onAnchor) {\n    const {\n      keepBlobsInJSON,\n      mapAsMap,\n      maxAliasCount\n    } = this.options;\n    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof resolveSeq.Scalar));\n    const ctx = {\n      doc: this,\n      indentStep: '  ',\n      keep,\n      mapAsMap: keep && !!mapAsMap,\n      maxAliasCount,\n      stringify // Requiring directly in Pair would create circular dependencies\n\n    };\n    const anchorNames = Object.keys(this.anchors.map);\n    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], {\n      alias: [],\n      aliasCount: 0,\n      count: 1\n    }]));\n    const res = resolveSeq.toJSON(this.contents, arg, ctx);\n    if (typeof onAnchor === 'function' && ctx.anchors) for (const {\n      count,\n      res\n    } of ctx.anchors.values()) onAnchor(res, count);\n    return res;\n  }\n\n  toString() {\n    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n    const indentSize = this.options.indent;\n\n    if (!Number.isInteger(indentSize) || indentSize <= 0) {\n      const s = JSON.stringify(indentSize);\n      throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n    }\n\n    this.setSchema();\n    const lines = [];\n    let hasDirectives = false;\n\n    if (this.version) {\n      let vd = '%YAML 1.2';\n\n      if (this.schema.name === 'yaml-1.1') {\n        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n      }\n\n      lines.push(vd);\n      hasDirectives = true;\n    }\n\n    const tagNames = this.listNonDefaultTags();\n    this.tagPrefixes.forEach(({\n      handle,\n      prefix\n    }) => {\n      if (tagNames.some(t => t.indexOf(prefix) === 0)) {\n        lines.push(`%TAG ${handle} ${prefix}`);\n        hasDirectives = true;\n      }\n    });\n    if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n    if (this.commentBefore) {\n      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n      lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n    }\n\n    const ctx = {\n      anchors: {},\n      doc: this,\n      indent: '',\n      indentStep: ' '.repeat(indentSize),\n      stringify // Requiring directly in nodes would create circular dependencies\n\n    };\n    let chompKeep = false;\n    let contentComment = null;\n\n    if (this.contents) {\n      if (this.contents instanceof resolveSeq.Node) {\n        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n        ctx.forceBlockIndent = !!this.comment;\n        contentComment = this.contents.comment;\n      }\n\n      const onChompKeep = contentComment ? null : () => chompKeep = true;\n      const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);\n      lines.push(resolveSeq.addComment(body, '', contentComment));\n    } else if (this.contents !== undefined) {\n      lines.push(stringify(this.contents, ctx));\n    }\n\n    if (this.comment) {\n      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n      lines.push(this.comment.replace(/^/gm, '#'));\n    }\n\n    return lines.join('\\n') + '\\n';\n  }\n\n}\n\nPlainValue._defineProperty(Document, \"defaults\", documentOptions);\n\nexports.Document = Document;\nexports.defaultOptions = defaultOptions;\nexports.scalarOptions = scalarOptions;\n","const util = require('./dist/util')\n\nexports.findPair = util.findPair\nexports.toJSON = util.toJSON\nexports.parseMap = util.parseMap\nexports.parseSeq = util.parseSeq\n\nexports.stringifyNumber = util.stringifyNumber\nexports.stringifyString = util.stringifyString\nexports.Type = util.Type\n\nexports.YAMLError = util.YAMLError\nexports.YAMLReferenceError = util.YAMLReferenceError\nexports.YAMLSemanticError = util.YAMLSemanticError\nexports.YAMLSyntaxError = util.YAMLSyntaxError\nexports.YAMLWarning = util.YAMLWarning\n","'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\n\n\n\nexports.Type = PlainValue.Type;\nexports.YAMLError = PlainValue.YAMLError;\nexports.YAMLReferenceError = PlainValue.YAMLReferenceError;\nexports.YAMLSemanticError = PlainValue.YAMLSemanticError;\nexports.YAMLSyntaxError = PlainValue.YAMLSyntaxError;\nexports.YAMLWarning = PlainValue.YAMLWarning;\nexports.findPair = resolveSeq.findPair;\nexports.parseMap = resolveSeq.resolveMap;\nexports.parseSeq = resolveSeq.resolveSeq;\nexports.stringifyNumber = resolveSeq.stringifyNumber;\nexports.stringifyString = resolveSeq.stringifyString;\nexports.toJSON = resolveSeq.toJSON;\n"],"sourceRoot":""}